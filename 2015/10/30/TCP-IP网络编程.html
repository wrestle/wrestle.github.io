
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>TCP/IP网络编程 | WuShXin&#39;s fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP/IP网络编程">
<meta property="og:url" content="//wushxin.top/2015/10/30/TCP-IP网络编程.html">
<meta property="og:site_name" content="WuShXin's fox">
<meta property="og:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TCP/IP网络编程">
<meta name="twitter:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
  
    <link rel="alternative" href="/atom.xml" title="WuShXin&#39;s fox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b3641d1a0a36f80a0281a32bffce538b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">WuShXin&#39;s fox</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">喜欢编程带来的快乐</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="//wushxin.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-TCP-IP网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/30/TCP-IP网络编程.html" class="article-date">
  <time datetime="2015-10-30T10:16:53.000Z" itemprop="datePublished">2015-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TCP/IP网络编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code><a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>概念模糊的 <strong>DNS</strong><ul>
<li>其实很简单，它的作用就是用来找到域名所对应的 <strong>IP地址</strong></li>
<li>为什么？因为 <strong>IP地址</strong> 太难记了！如果你觉得 <strong>IPv4</strong> 地址还难不倒你，那请你试试 <strong>IPv6</strong></li>
<li>怎么查看域名对应的 <strong>IP地址</strong>，当然先不考虑 <strong>CDN</strong><ul>
<li><code>*nix</code> 和 <code>Windows</code> 都可以通过 <code>ping &lt;domain name&gt;</code> 命令进行查询</li>
</ul>
</li>
</ul>
</li>
<li><strong>MAC地址</strong> 和 <strong>端口号</strong><ul>
<li>对于前者，实际上应该是最熟悉不过的，对于网络上的主机而言，每一台主机就有一个专属的 <strong>MAC地址</strong></li>
<li>后者则是相当于一个房子的门，这个比喻在各大教材中广泛引用，但也的确贴切，假设 <strong>IP地址</strong> 是房子的地址，那么到了别人家要知道门在哪才行。</li>
</ul>
</li>
</ul>
<p>一个完整的应用程序传输数据时候 <strong>封装</strong> 的过程(<strong>从右二向左依次封装</strong>)：</p>
<table>
<thead>
<tr>
<th>以太网首部</th>
<th>IP</th>
<th>TCP/UDP</th>
<th>真实数据</th>
<th>尾部</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC地址</td>
<td>IP地址</td>
<td>TCP或者UDP协议</td>
<td>应用程序数据</td>
<td>效验码</td>
</tr>
<tr>
<td>源和目的MAC地址以及</td>
<td>及前层协议类型</td>
<td>源和目的端口号及前层应用程序首部信息</td>
<td>应用软件信息和真正的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中端口号实际上就是 <strong>应用程序的信息</strong></p>
<p>接收数据时的 <strong>拆解</strong> 顺序与 <strong>封装</strong> 正好相反。</p>
<ul>
<li><p>其中在传输过程中，作为接收方最开始使用的是 <strong>网络接口层/数据链路层</strong> 的驱动程序(即操作系统自带或另行安装，总之不用使用的程序员写就对了)，来判断这个包是否属于我，判断的依据就是 <strong>MAC地址</strong>，如果是再判断什么协议</p>
<ul>
<li>在此处的协议可不止 <strong>IP协议</strong>， 也可能是 <strong>ARP协议</strong> 等。之后就是就事论事交给相应的处理软件去处理(拆解)就行</li>
<li>科普： MAC地址是 <code>48bit</code> 的， 前<code>24bit</code>由 <strong>IEEE</strong> 分配， 后<code>24bit</code> 由厂商分配。原则上是唯一的。</li>
</ul>
</li>
<li><p><strong>MAC地址</strong> 和 <strong>IP地址</strong></p>
<ul>
<li>既然前方说到 <strong>MAC地址</strong> 和 <strong>IP地址</strong> 都能够作为识别另一个主机的唯一标识，但是为什么需要有两个相同功能的东西？</li>
<li>是，在一开始，网络很小的情况下，例如我们在同一个局域网中，我们之间需要<strong>通信</strong>的时候，只需要使用ARP协议，进行<strong>广播</strong>，向在一个网络中的所有主机发送消息就行，剩下的就让其他主机去判断(通过<strong>MAC地址</strong>)这个数据是不是发给我的。<ul>
<li><strong>ARP协议</strong> 的作用就是在同一个网络中，通过 <strong>广播</strong> 找出符合自己要求的主机的 <strong>MAC地址</strong> ，如果不在同一个网络中，又想知道对方的 <strong>MAC地址</strong>， 那只能借助把每个网络链接在一起的 <strong>网关</strong> 来帮助你发送 。 总之进行网络通信时必须知道对方的 <strong>IP地址 和 MAC地址</strong></li>
</ul>
</li>
<li>但是如果是现在整个互联网呢？不算<strong>IPv6</strong>，就算 <strong>IPv4</strong> 也是几十亿的存在，如果我从中国向国外发送信息，广播整个互联网的所有主机，那就炸了！</li>
<li>所以我们需要对世界网络进行分区，让大区域包含小区域，就像<strong>国家-省-市区…</strong> ， 很遗憾的是 <strong>MAC地址</strong> 是跟计算机相关而不是和位置相关的。所以我们有了 <strong>IP协议</strong></li>
<li><strong>IP协议</strong> 所附带的产品 <strong>IP地址</strong> 的作用就在帮助计算机识别自己是否在同一个网络中(<strong>这里省略了子网掩码的作用</strong>)。</li>
</ul>
</li>
<li><p>实际上，在进行网络编程的时候，以上细节几乎都被隐藏起来，留给我们的只是可供使用的接口。</p>
</li>
</ul>
<h2 id="套接字网络编程初始">套接字网络编程初始</h2><blockquote>
<p>选择使用 C 语言进行编程</p>
</blockquote>
<ul>
<li>在网络编程中，最常实用的两种连接方式 <code>TCP</code> 和 <code>UDP</code></li>
<li>最常编程的平台 <code>POSIX 标准-&gt; *nix平台标准</code> 和 <code>Windows 平台标准</code><ul>
<li>实际上，后者也是参考前者进行一些细微的改变(<strong>指的是接口</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比两种不同连接方式的不同地位的创建，使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP服务器</th>
<th>TCP客户端</th>
<th>UDP服务器</th>
<th>UDP客户端</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>创建套接字</td>
</tr>
<tr>
<td>bind()</td>
<td></td>
<td>bind()</td>
<td>bind()</td>
<td>绑定所分配IP地址和端口号</td>
</tr>
<tr>
<td>listen()</td>
<td>connect()</td>
<td></td>
<td></td>
<td>客户端则绑定IP地址和端口号，并等待连接；服务器则是等待连接</td>
</tr>
<tr>
<td>accept()</td>
<td></td>
<td></td>
<td></td>
<td>服务器接受连接</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>sendto/recvfrom</td>
<td>sendto/recvfrom</td>
<td>对于UDP即是连接也是操作</td>
</tr>
<tr>
<td>close()</td>
<td>close()</td>
<td>close()</td>
<td>close</td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p>如此对比虽然有一些小瑕疵，但是能够大体上反映出真个网络编程上不同方式的区别</p>
<blockquote>
<p>注： 实际上 UDP 没有所谓的 服务器和和护短，因为本来就是单纯的互相发来发去。<strong>客户端端口</strong>一般是随机的</p>
<p>以上是 *nix平台下的标准， Windows下的操作方式和 API有细微不同，但大部分是一致的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Windows</th>
<th>*nix</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
</tr>
<tr>
<td>bind()</td>
<td>bind()</td>
</tr>
<tr>
<td>connect()</td>
<td>connect()</td>
</tr>
<tr>
<td>listen()</td>
<td>listen()</td>
</tr>
<tr>
<td>accept()</td>
<td>accept()</td>
</tr>
<tr>
<td>close()</td>
<td>closesocket()</td>
</tr>
<tr>
<td>sendto()</td>
<td>sendto()</td>
</tr>
<tr>
<td>recvfrom()</td>
<td>recvfrom()</td>
</tr>
</tbody>
</table>
<p>不仅仅是接口名字相同，参数个数以及功能也是一致，即使有一个例外，其参数以及使用方法也相同。</p>
<blockquote>
<p>那岂不是可以直接移植了？</p>
<p>并不！</p>
</blockquote>
<p>在 <strong> Windows 套接字编程时</strong>， 由于 <code>Windows</code> 将其实现为动态库，所以在使用时需要将其加载进程序。</p>
<p>故而多加了加载操作。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(
  WORD      wVersionRequested,
  LPWSADATA lpWSAData  <span class="comment">/* 这是一个结构体， 传入类型为WSADATA*  */</span>
)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>每当在 <strong>Windows</strong> 上进行套接字编程时，总要指定某个版本的套接字库：</p>
<pre><code>WSADATA wsaData;
int err_code;
/<span class="keyword">*</span>
<span class="keyword">*</span> MAKEWORD()的作用在于将版本号转为指定格式传入
<span class="keyword">*</span> 当下(2015-10)套接字库的版本号最高是 2.2
<span class="keyword">*</span>/
err_code = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
/<span class="keyword">*</span> TODO Something <span class="keyword">*</span>/
WSACleanup();
</code></pre><p>这是最基本的在 <strong>Windows</strong> 上使用 <strong>套接字</strong> 编程的流程，但是如果本平台的套接字库最高版本并不符合当前要求呢？</p>
<p>那么首先会将套接字版本库尽可能设置到平台的 <strong>最高版本</strong> ，可以通过结构体 <code>WSADATA</code> 进行查询</p>
<pre><code><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)
{
  <span class="built_in">printf</span>(<span class="string">"Could not find a usable version of Winsock.dll\n"</span>);
  WSACleanup();
  <span class="built_in">return</span> <span class="number">1</span>;
}
</code></pre><blockquote>
<p>总体而言， Windows平台 和 *uix平台 的区别在于，前者使用时需要 加载和清除 套接字库<br>其余逻辑流程一致，毕竟只有统一才能越利于编程世界的发展。</p>
</blockquote>
<h2 id="套接字编程">套接字编程</h2><ul>
<li>两种协议 <code>TCP</code> 和 <code>UDP</code><ul>
<li>前者可以理解为有保证的连接，后者是追求快速的连接</li>
<li>当然最后一点有些太过绝对，但是现在不需熬考虑太多，因为初入套接字编程，一切从简</li>
<li>稍微试想便能够大致理解， <code>TCP</code> 追求的是可靠的传输数据， <code>UDP</code> 追求的则是快速的传输数据</li>
<li>前者有繁琐的连接过程，后者则是根本不建立可靠连接(不是绝对)，只是将数据发送而不考虑是否到达。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下例子以 *nix 平台的便准为例，因为 Windows平台需要考虑额外的加载问题。</p>
</blockquote>
<ul>
<li><p><code>UDP</code></p>
<ul>
<li>这是一个十分简洁的连接方式</li>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
struct sockaddr_in recv_host, send_host;

/<span class="keyword">*</span> 创建套接字 <span class="keyword">*</span>/
sock = socket(PF_INET, SOCK_DGRAM, 0);

/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
memset(&amp;recv_host, 0, sizeof(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);

/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><p>上述代码省略了许多必要的 <strong>错误检查</strong> ，在实际编写时要添加</p>
</li>
<li>代码解释：<ol>
<li><strong>PF_INET</strong> 代表协议的类型，此处代表 <strong>IPv4</strong> 网络协议族， 同样 <strong>PF_INET6</strong> 代表 <strong>IPv6</strong> 网络协议族，这个范围在后方单独记录，不与IPv4混在一起。</li>
<li><strong>AF_INET</strong> 代表地址的类型，此处代表 <strong>IPv4</strong> 网络协议使用的地址族， 同样有 <strong>AF_INET6</strong></li>
<li><code>htonl</code> 和 <code>htons</code> 两个函数的使用涉及到 <strong>大端小端问题</strong>， 这里不叙述，需要记住的是在网络编程时一定要使用这种函数将必要信息转为 <strong>大端表示法</strong> 。</li>
<li><code>(struct sockaddr *)</code> 这个强制转换是为了参数的必须，但不会出错，因为 <code>sizeof(struct sockaddr_in) == sizeof(struct sockaddr)</code> 具体可以查询相关信息，之所以这么做是为了方便编写套接字程序的程序员。</li>
</ol>
</li>
<li>发送端：<pre><code><span class="keyword">int</span> sock;
<span class="keyword">const</span> <span class="keyword">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="keyword">struct</span> sockaddr_in recv_host;
socklen_t addr_len;
<span class="comment">/* 创建套接字 */</span>
sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);
<span class="comment">/* 绑定 */</span>
<span class="built_in">memset</span>(&amp;recv_host, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 发送信息 */</span>
sendto(sock, mess, <span class="built_in">strlen</span>(mess), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 完成，关闭 */</span>
close(sock);
</code></pre>上述代码是发送端。</li>
<li>代码解释：<ol>
<li><code>inet_addr</code> 函数是用于将字符串格式的 <strong>IP地址</strong> 转换为 大端表示法的 地址类型，即 <code>s_addr</code> 的类型 <code>in_addr_t</code></li>
<li>与之相反，同样也有功能相反的函数 <code>inet_ntoa</code> 用于将 <code>in_addr_t</code> 类型转为字符串，但是使用时一定要记住及时拷贝返回值<pre><code><span class="type">char</span> <span class="keyword">addr</span>[<span class="number">16</span>];
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
strcpy(<span class="keyword">addr</span>, inet_ntoa(recv_host.sin_addr.s_addr));
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="//wushxin.top/2015/10/30/TCP-IP网络编程.html" data-id="ciggj2opz000lnglt8n3yjp8i" class="article-share-link" data-share="baidu" data-title="TCP/IP网络编程">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/09/20/Linux记录.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Linux记录</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/">Cpp</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Opencv/">Opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂货居/">杂货居</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站/">网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C</a><a href="/tags/Cpp/" style="font-size: 16.67px;">Cpp</a><a href="/tags/Linux/" style="font-size: 10px;">Linux</a><a href="/tags/Opencv/" style="font-size: 10px;">Opencv</a><a href="/tags/Python/" style="font-size: 13.33px;">Python</a><a href="/tags/Qt/" style="font-size: 13.33px;">Qt</a><a href="/tags/杂货居/" style="font-size: 20px;">杂货居</a><a href="/tags/网站/" style="font-size: 10px;">网站</a><a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/30/TCP-IP网络编程.html">TCP/IP网络编程</a>
          </li>
        
          <li>
            <a href="/2015/09/20/Linux记录.html">Linux记录</a>
          </li>
        
          <li>
            <a href="/2015/08/31/《我为什么学C》.html">《我为什么学C》</a>
          </li>
        
          <li>
            <a href="/2015/07/21/Practical-cpp.html">Practical cpp</a>
          </li>
        
          <li>
            <a href="/2015/07/09/Cpp记录10.1k.html">Cpp记录10.1k</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 WuShengXin<br>
      
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
