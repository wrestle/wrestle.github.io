
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>TCP/IP网络编程 | WuShXin&#39;s fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP/IP网络编程">
<meta property="og:url" content="//wushxin.top/2015/10/30/TCP-IP网络编程.html">
<meta property="og:site_name" content="WuShXin's fox">
<meta property="og:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TCP/IP网络编程">
<meta name="twitter:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
  
    <link rel="alternative" href="/atom.xml" title="WuShXin&#39;s fox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b3641d1a0a36f80a0281a32bffce538b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">WuShXin&#39;s fox</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">喜欢编程带来的快乐</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="//wushxin.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-TCP-IP网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/30/TCP-IP网络编程.html" class="article-date">
  <time datetime="2015-10-30T10:16:53.000Z" itemprop="datePublished">2015-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TCP/IP网络编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code><a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>概念模糊的 <strong>DNS</strong><ul>
<li>其实很简单，它的作用就是用来找到域名所对应的 <strong>IP地址</strong></li>
<li>为什么？因为 <strong>IP地址</strong> 太难记了！如果你觉得 <strong>IPv4</strong> 地址还难不倒你，那请你试试 <strong>IPv6</strong></li>
<li>怎么查看域名对应的 <strong>IP地址</strong>，当然先不考虑 <strong>CDN</strong><ul>
<li><code>*nix</code> 和 <code>Windows</code> 都可以通过 <code>ping &lt;domain name&gt;</code> 命令进行查询</li>
</ul>
</li>
</ul>
</li>
<li><strong>MAC地址</strong> 和 <strong>端口号</strong><ul>
<li>对于前者，实际上应该是最熟悉不过的，对于网络上的主机而言，每一台主机就有一个专属的 <strong>MAC地址</strong></li>
<li>后者则是相当于一个房子的门，这个比喻在各大教材中广泛引用，但也的确贴切，假设 <strong>IP地址</strong> 是房子的地址，那么到了别人家要知道门在哪才行。</li>
</ul>
</li>
</ul>
<p>一个完整的应用程序传输数据时候 <strong>封装</strong> 的过程(<strong>从右二向左依次封装</strong>)：</p>
<table>
<thead>
<tr>
<th>以太网首部</th>
<th>IP</th>
<th>TCP/UDP</th>
<th>真实数据</th>
<th>尾部</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC地址</td>
<td>IP地址</td>
<td>TCP或者UDP协议</td>
<td>应用程序数据</td>
<td>效验码</td>
</tr>
<tr>
<td>源和目的MAC地址以及</td>
<td>及前层协议类型</td>
<td>源和目的端口号及前层应用程序首部信息</td>
<td>应用软件信息和真正的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中端口号实际上就是 <strong>应用程序的信息</strong></p>
<p>接收数据时的 <strong>拆解</strong> 顺序与 <strong>封装</strong> 正好相反。</p>
<ul>
<li><p>其中在传输过程中，作为接收方最开始使用的是 <strong>网络接口层/数据链路层</strong> 的驱动程序(即操作系统自带或另行安装，总之不用使用的程序员写就对了)，来判断这个包是否属于我，判断的依据就是 <strong>MAC地址</strong>，如果是再判断什么协议</p>
<ul>
<li>在此处的协议可不止 <strong>IP协议</strong>， 也可能是 <strong>ARP协议</strong> 等。之后就是就事论事交给相应的处理软件去处理(拆解)就行</li>
<li>科普： MAC地址是 <code>48bit</code> 的， 前<code>24bit</code>由 <strong>IEEE</strong> 分配， 后<code>24bit</code> 由厂商分配。原则上是唯一的。</li>
</ul>
</li>
<li><p><strong>MAC地址</strong> 和 <strong>IP地址</strong></p>
<ul>
<li>既然前方说到 <strong>MAC地址</strong> 和 <strong>IP地址</strong> 都能够作为识别另一个主机的唯一标识，但是为什么需要有两个相同功能的东西？</li>
<li>是，在一开始，网络很小的情况下，例如我们在同一个局域网中，我们之间需要<strong>通信</strong>的时候，只需要使用ARP协议，进行<strong>广播</strong>，向在一个网络中的所有主机发送消息就行，剩下的就让其他主机去判断(通过<strong>MAC地址</strong>)这个数据是不是发给我的。<ul>
<li><strong>ARP协议</strong> 的作用就是在同一个网络中，通过 <strong>广播</strong> 找出符合自己要求的主机的 <strong>MAC地址</strong> ，如果不在同一个网络中，又想知道对方的 <strong>MAC地址</strong>， 那只能借助把每个网络链接在一起的 <strong>网关</strong> 来帮助你发送 。 总之进行网络通信时必须知道对方的 <strong>IP地址 和 MAC地址</strong></li>
</ul>
</li>
<li>但是如果是现在整个互联网呢？不算<strong>IPv6</strong>，就算 <strong>IPv4</strong> 也是几十亿的存在，如果我从中国向国外发送信息，广播整个互联网的所有主机，那就炸了！</li>
<li>所以我们需要对世界网络进行分区，让大区域包含小区域，就像<strong>国家-省-市区…</strong> ， 很遗憾的是 <strong>MAC地址</strong> 是跟计算机相关而不是和位置相关的。所以我们有了 <strong>IP协议</strong></li>
<li><strong>IP协议</strong> 所附带的产品 <strong>IP地址</strong> 的作用就在帮助计算机识别自己是否在同一个网络中(<strong>这里省略了子网掩码的作用</strong>)。</li>
</ul>
</li>
<li><p>实际上，在进行网络编程的时候，以上细节几乎都被隐藏起来，留给我们的只是可供使用的接口。</p>
</li>
</ul>
<h2 id="夹在中间">夹在中间</h2><blockquote>
<p>事实上有一些实用且挺炫酷的函数，可以先提一下</p>
</blockquote>
<ul>
<li>域名 和 IP地址 的互查<ul>
<li><code>gethostbyname</code> 用于域名查找 IP信息及各类信息<ul>
<li><code>struct hostent * gethostbyname(const char * hostname)</code></li>
<li><code>struct hostent</code> 是存储查找到的各类型信息，后方会有介绍</li>
<li><code>hostname</code> 即要查询的域名</li>
</ul>
</li>
<li><code>gethostbyaddr</code> 用于IP地址查找 域名及各类信息<ul>
<li><code>struct hostent * gethostbyaddr(const char * addr, socklen_t len, int family)</code><ul>
<li><code>addr</code> 是要查询的 IP地址，之所以是 <code>const char *</code> 是因为C语言历史遗留的原因，实际上其类型应为 <code>struct in_addr *</code>(IPv4)</li>
<li><code>len</code> 地址的长度，即 <strong>IPv4</strong> 为4， <strong>IPv6</strong> 为16</li>
<li><code>family</code> 即协议的种类， <strong>IPv4</strong> 为 <code>AF_INET</code>, <strong>IPv6</strong> 为 <code>AF_INET6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>struct hostent 的成员</th>
<th>.</th>
<th>类型</th>
<th>.</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>h_name</td>
<td></td>
<td>char *</td>
<td></td>
<td>官方名称</td>
</tr>
<tr>
<td>h_aliases</td>
<td></td>
<td>char **</td>
<td></td>
<td>域名集合，以NULL结尾</td>
</tr>
<tr>
<td>h_addrtype</td>
<td></td>
<td>int</td>
<td></td>
<td>地址族的类型 AF_INET 或 AF_INET6</td>
</tr>
<tr>
<td>h_length</td>
<td></td>
<td>int</td>
<td></td>
<td>地址的长度 4 或 16</td>
</tr>
<tr>
<td>h_addr_list</td>
<td></td>
<td>char **</td>
<td></td>
<td>IP的集合，以NULL结尾, 实际上每个元素的类型为 struct in_addr*</td>
</tr>
</tbody>
</table>
<ul>
<li>其中第二和最后一个是关注的重点所在，可以在调用函数之后，输出信息<h2 id="套接字网络编程初始">套接字网络编程初始</h2></li>
</ul>
<blockquote>
<p>选择使用 C 语言进行编程</p>
</blockquote>
<ul>
<li>在网络编程中，最常实用的两种连接方式 <code>TCP</code> 和 <code>UDP</code></li>
<li>最常编程的平台 <code>POSIX 标准-&gt; *nix平台标准</code> 和 <code>Windows 平台标准</code><ul>
<li>实际上，后者也是参考前者进行一些细微的改变(<strong>指的是接口</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比两种不同连接方式的不同地位的创建，使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP服务器</th>
<th>TCP客户端</th>
<th>UDP服务器</th>
<th>UDP客户端</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>创建套接字</td>
</tr>
<tr>
<td>bind()</td>
<td></td>
<td>bind()</td>
<td>bind()</td>
<td>绑定所分配IP地址和端口号</td>
</tr>
<tr>
<td>listen()</td>
<td>connect()</td>
<td></td>
<td></td>
<td>客户端则绑定IP地址和端口号，并等待连接；服务器则是等待连接</td>
</tr>
<tr>
<td>accept()</td>
<td></td>
<td></td>
<td></td>
<td>服务器接受连接</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>sendto/recvfrom()</td>
<td>sendto/recvfrom()</td>
<td>对于UDP即是连接也是操作</td>
</tr>
<tr>
<td>close()</td>
<td>close()</td>
<td>close()</td>
<td>close</td>
<td>双向直接关闭连接</td>
</tr>
<tr>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>可选择方向的关闭连接,即更加灵活</td>
</tr>
</tbody>
</table>
<p>如此对比虽然有一些小瑕疵，但是能够大体上反映出真个网络编程上不同方式的区别</p>
<blockquote>
<p>注： 实际上 UDP 没有所谓的 服务器和和护短，因为本来就是单纯的互相发来发去。<strong>客户端端口</strong>一般是随机的</p>
<p>以上是 *nix平台下的标准， Windows下的操作方式和 API有细微不同，但大部分是一致的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Windows</th>
<th>*nix</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
</tr>
<tr>
<td>bind()</td>
<td>bind()</td>
</tr>
<tr>
<td>connect()</td>
<td>connect()</td>
</tr>
<tr>
<td>listen()</td>
<td>listen()</td>
</tr>
<tr>
<td>accept()</td>
<td>accept()</td>
</tr>
<tr>
<td>close()</td>
<td>closesocket()</td>
</tr>
<tr>
<td>sendto()</td>
<td>sendto()</td>
</tr>
<tr>
<td>recvfrom()</td>
<td>recvfrom()</td>
</tr>
</tbody>
</table>
<p>不仅仅是接口名字相同，参数个数以及功能也是一致，即使有一个例外，其参数以及使用方法也相同。</p>
<blockquote>
<p>那岂不是可以直接移植了？</p>
<p>并不！</p>
</blockquote>
<p>在 <strong> Windows 套接字编程时</strong>， 由于 <code>Windows</code> 将其实现为动态库，所以在使用时需要将其加载进程序。</p>
<p>故而多加了加载操作。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(
  WORD      wVersionRequested,
  LPWSADATA lpWSAData  <span class="comment">/* 这是一个结构体， 传入类型为WSADATA*  */</span>
)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>每当在 <strong>Windows</strong> 上进行套接字编程时，总要指定某个版本的套接字库：</p>
<pre><code>WSADATA wsaData;
int err_code;
/<span class="keyword">*</span>
<span class="keyword">*</span> MAKEWORD()的作用在于将版本号转为指定格式传入
<span class="keyword">*</span> 当下(2015-10)套接字库的版本号最高是 2.2
<span class="keyword">*</span>/
err_code = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
/<span class="keyword">*</span> TODO Something <span class="keyword">*</span>/
WSACleanup();
</code></pre><p>这是最基本的在 <strong>Windows</strong> 上使用 <strong>套接字</strong> 编程的流程，但是如果本平台的套接字库最高版本并不符合当前要求呢？</p>
<p>那么首先会将套接字版本库尽可能设置到平台的 <strong>最高版本</strong> ，可以通过结构体 <code>WSADATA</code> 进行查询</p>
<pre><code><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)
{
  <span class="built_in">printf</span>(<span class="string">"Could not find a usable version of Winsock.dll\n"</span>);
  WSACleanup();
  <span class="built_in">return</span> <span class="number">1</span>;
}
</code></pre><blockquote>
<p>总体而言， Windows平台 和 *uix平台 的区别在于，前者使用时需要 加载和清除 套接字库<br>其余逻辑流程一致，毕竟只有统一才能越利于编程世界的发展。</p>
</blockquote>
<h2 id="套接字编程">套接字编程</h2><ul>
<li>两种协议 <code>TCP</code> 和 <code>UDP</code><ul>
<li>前者可以理解为有保证的连接，后者是追求快速的连接</li>
<li>当然最后一点有些太过绝对，但是现在不需熬考虑太多，因为初入套接字编程，一切从简</li>
<li>稍微试想便能够大致理解， <code>TCP</code> 追求的是可靠的传输数据， <code>UDP</code> 追求的则是快速的传输数据</li>
<li>前者有繁琐的连接过程，后者则是根本不建立可靠连接(不是绝对)，只是将数据发送而不考虑是否到达。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下例子以 *nix 平台的便准为例，因为 Windows平台需要考虑额外的加载问题。</p>
</blockquote>
<h3 id="UDP">UDP</h3><ul>
<li><p><code>UDP</code></p>
<ul>
<li>这是一个十分简洁的连接方式，假设有两台主机进行通信，一台只发送，一台只接收。</li>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in recv_host, send_host;

/<span class="keyword">*</span> 创建套接字 <span class="keyword">*</span>/
sock = socket(PF_INET, SOCK_DGRAM, 0);

/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
memset(&amp;recv_host, 0, sizeof(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);

/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><p>上述代码省略了许多必要的 <strong>错误检查</strong> ，在实际编写时要添加</p>
</li>
<li>代码解释：<ol>
<li><strong>PF_INET</strong> 代表协议的类型，此处代表 <strong>IPv4</strong> 网络协议族， 同样 <strong>PF_INET6</strong> 代表 <strong>IPv6</strong> 网络协议族，这个范围在后方单独记录，不与IPv4混在一起。</li>
<li><strong>AF_INET</strong> 代表地址的类型，此处代表 <strong>IPv4</strong> 网络协议使用的地址族， 同样有 <strong>AF_INET6</strong></li>
<li><code>htonl</code> 和 <code>htons</code> 两个函数的使用涉及到 <strong>大端小端问题</strong>， 这里不叙述，需要记住的是在网络编程时一定要使用这种函数将必要信息转为 <strong>大端表示法</strong> 。</li>
<li><code>(struct sockaddr *)</code> 这个强制转换是为了参数的必须，但不会出错，因为 <code>sizeof(struct sockaddr_in) == sizeof(struct sockaddr)</code> 具体可以查询相关信息，之所以这么做是为了方便编写套接字程序的程序员。</li>
</ol>
</li>
<li>发送端：<pre><code><span class="keyword">int</span> sock;
<span class="keyword">const</span> <span class="keyword">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="keyword">char</span> get_mess[GET_MAX]; <span class="comment">/* 后续版本使用 */</span>
<span class="keyword">struct</span> sockaddr_in recv_host;
socklen_t addr_len;
<span class="comment">/* 创建套接字 */</span>
sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);
<span class="comment">/* 绑定 */</span>
<span class="built_in">memset</span>(&amp;recv_host, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 发送信息 */</span>
<span class="comment">/* 在此处，发送端的IP地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */</span>
sendto(sock, mess, <span class="built_in">strlen</span>(mess), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 完成，关闭 */</span>
close(sock);
</code></pre>上述代码是发送端。</li>
<li>代码解释：<ol>
<li><code>inet_addr</code> 函数是用于将字符串格式的 <strong>IP地址</strong> 转换为 大端表示法的 地址类型，即 <code>s_addr</code> 的类型 <code>in_addr_t</code></li>
<li>与之相反，同样也有功能相反的函数 <code>inet_ntoa</code> 用于将 <code>in_addr_t</code> 类型转为字符串，但是使用时一定要记住及时拷贝返回值<pre><code><span class="type">char</span> <span class="keyword">addr</span>[<span class="number">16</span>];
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
strcpy(<span class="keyword">addr</span>, inet_ntoa(recv_host.sin_addr.s_addr));
</code></pre></li>
</ol>
</li>
<li>从上述代码看出， <code>UDP</code> 协议的使用十分简洁，几乎就是 <strong>创建套接字-&gt;准备数据-&gt;装备套接字-&gt;发送/接收-&gt;结束</strong></li>
<li>其中，都没有连接的操作，但是实际上这是为了方便 <code>UDP</code> 随时和 <strong>不同的主机</strong> 进行通信所默认的设置，如果需要和相同主机一直通信呢？</li>
<li>此中的原由暂时不需要知道，记录方法，即长时间使用 <code>UDP</code> 和同一主机通信时，可以使用 <code>connect</code> 函数来进行优化自身。此时 <strong>假设两台主机的实际功能一致，既接收也发送</strong></li>
<li>发送端：<pre><code><span class="comment">/* 前方高度一致，将 bind函数替换为 */</span>
connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host); <span class="comment">// 将对方的 IP地址和 端口号信息 注册进UDP的套接字中)</span>
<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 循环的发送和接收信息 */</span>
{
  size_t read_len = <span class="number">0</span>;
  <span class="comment">/* 原先使用的 sendto 函数，先择改为使用 write 函数， Windows平台为 send 函数 */</span>
  write(sock, mess, <span class="built_in">strlen</span>(mess));            <span class="comment">/* send(sock, mess, strlen(mess), 0) FOR Windows Platform */</span>
  read_len = read(sock, get_mess, GET_MAX-<span class="number">1</span>); <span class="comment">/* recv(sock, mess, strlen(mess)-1, 0) FOR Windows Platform */</span>
  get_mess[read_len] = <span class="string">'\0'</span>;
  <span class="built_in">printf</span>(<span class="string">"In Client like Host Recvive From Other Host : %s\n"</span>, get_mess);
}
<span class="comment">/* 后方高度一致 */</span>
</code></pre></li>
<li>接收端：<pre><code>/<span class="keyword">*</span> 前方一致， 添加额外的 struct sockaddr_in send_host; 并添加循环，构造收发的现象<span class="keyword">*</span>/
while(1)
{
  size_t read_len = 0;
  char sent_mess[15] = <span class="string">"Hello Sender!"</span>; /<span class="keyword">*</span> 用于发送的信息 <span class="keyword">*</span>/
  sendto(sock, mess, strlen(sent_mess), 0, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
  read_len = recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len)
  printf(<span class="string">"In Sever like Host Recvive From other Host : %s\n"</span>, mess);
}
/<span class="keyword">*</span> 后方高度一致 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> 之所以只在接收端使用 connect 的原因，便在于我们模拟的是 客户端-服务器 的模型，而服务器的各项信息是不会随意变更的
<span class="keyword">*</span> 但是 客户端就不同了，可能由于 ISP(Internet Server Provider) 的原因，你的IP地址不可能总是固定的，所以只能
<span class="keyword">*</span> 保证 在客户端 部分注册了 服务器 的各类信息，而不能在 服务器端 注册 客户端 的信息。
<span class="keyword">*</span> 当然也有例外，例如你就想这个软件作为私密软件，仅供两个人使用， 且你有固定的 IP地址，那么你可以两边都connect，但是
<span class="keyword">*</span> 一定要注意，只要有一点信息变动，这个软件就可能无法正常的收发信息了。
<span class="keyword">*</span>/
</code></pre></li>
<li>代码解释<ul>
<li>故而实际上，虽然前方的表格显示，<code>UDP</code> 似乎并没有 <code>connect</code> 的使用必要，但是实际上还是有用到的地方。</li>
<li>就 <code>*nix</code> 的 <strong>API</strong> 来说，<code>sendto</code> 和  <code>write</code> 的区别十分明显，便是一个需要在参数中提供目标主机的各类信息，而后者则不需要提供。同样的道理<code>recvfrom</code>和<code>read</code>也是如此。</li>
<li>这个代码只是做演示而已，所以将代码置于无限循环当中，现实中可以自行定义出口条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上是 UDP 的一些简单说明，入门足矣，并未详细叙述某些 函数 的具体用法，而是用实际例子来体现。<br>在 记录 TCP 之前，还是需要讲一个函数 shutdown</p>
</blockquote>
<ul>
<li><code>shutdown</code> 与 <code>close(closesocket)</code><ul>
<li>首先要知道，网络通信一般而言是双方的共同进行的，换而言之就是双向的，一个方向只用来发送消息，一个方向只用来读取消息。</li>
<li>这就导致了，在结束套接字通信的时候，需要关闭两个方向的通道(暂时叫它们通道)，那同时关闭不行吗？可以啊<ul>
<li><code>close(sock); // closesocket(sock); FOR Windows PlatForm</code> 就是这么干的，同时断开两个方向的连接。</li>
<li>简单的通信程序或者单向通信程序这么做的确无甚大碍，但是万一在结束通信的时候需要接收最后一个信息那该怎么办？<ul>
<li>假设通信结束，客户端向服务器发送 “Thank you”</li>
<li>服务器需要接收这个信息，之后才能关闭通信</li>
<li>问题就在这之间，服务器并不知道客户端会在通信结束后的什么时刻传来信息</li>
<li>所以我们选择在通信完成后先关闭 服务器的 发送通道(写流)，等待客户端发来消息后，关闭剩下的 接收通道(读流)</li>
</ul>
</li>
</ul>
</li>
<li>发送端：<pre><code><span class="comment">/* 假设有一个 TCP 的连接，此为客户端 */</span>
write<span class="comment">(sock, "Thank you", 10)</span>;
close<span class="comment">(sock)</span>; <span class="comment">// 写完直接关闭通信</span>
</code></pre></li>
<li>接收端：<pre><code><span class="comment">/* 此为服务器 */</span>
<span class="comment">/* 首先关闭写流 */</span>
shutdown(sock_c, SHUT_WR);
<span class="keyword">read</span>(sock_c, get_mess, GET_MAX);
printf(<span class="string">"Message : %s\n"</span>, get_mess);
<span class="keyword">close</span>(sock_c);
<span class="keyword">close</span>(sock_s); <span class="comment">// 关闭两个套接字是因为 TCP 服务器端的需要，后续会记录</span>
</code></pre></li>
<li>代码解释<ul>
<li><code>shutdown</code> 函数的作用就是 可选择的关闭那个方向的输出<ul>
<li><code>int shutdown(int sock, int howto);</code></li>
<li><code>sock</code> 代表要操作的套接字</li>
<li><code>howto</code>有几个选择  <ul>
<li><strong> *nix </strong> : <code>SHUT_RD</code> <code>SHUT_WR</code> <code>SHUT_RDWR</code></li>
<li><strong> Windows </strong> : <code>SD_RECEIVE</code> <code>SD_SEND</code> <code>SD_BOTH</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP">TCP</h3>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="//wushxin.top/2015/10/30/TCP-IP网络编程.html" data-id="ciggj33zi000l1wltl7qd6t79" class="article-share-link" data-share="baidu" data-title="TCP/IP网络编程">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/09/20/Linux记录.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Linux记录</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/">Cpp</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Opencv/">Opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂货居/">杂货居</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站/">网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C</a><a href="/tags/Cpp/" style="font-size: 16.67px;">Cpp</a><a href="/tags/Linux/" style="font-size: 10px;">Linux</a><a href="/tags/Opencv/" style="font-size: 10px;">Opencv</a><a href="/tags/Python/" style="font-size: 13.33px;">Python</a><a href="/tags/Qt/" style="font-size: 13.33px;">Qt</a><a href="/tags/杂货居/" style="font-size: 20px;">杂货居</a><a href="/tags/网站/" style="font-size: 10px;">网站</a><a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/30/TCP-IP网络编程.html">TCP/IP网络编程</a>
          </li>
        
          <li>
            <a href="/2015/09/20/Linux记录.html">Linux记录</a>
          </li>
        
          <li>
            <a href="/2015/08/31/《我为什么学C》.html">《我为什么学C》</a>
          </li>
        
          <li>
            <a href="/2015/07/21/Practical-cpp.html">Practical cpp</a>
          </li>
        
          <li>
            <a href="/2015/07/09/Cpp记录10.1k.html">Cpp记录10.1k</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 WuShengXin<br>
      
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
