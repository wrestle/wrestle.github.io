
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>现代TCP/IP网络编程-启航 | WuShXin&#39;s fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta property="og:type" content="article">
<meta property="og:title" content="现代TCP/IP网络编程-启航">
<meta property="og:url" content="http://www.wushxin.top/2015/10/30/现代TCP-IP网络编程-启航.html">
<meta property="og:site_name" content="WuShXin's fox">
<meta property="og:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="现代TCP/IP网络编程-启航">
<meta name="twitter:description" content="概念
最具误导性的当属于 TCP/IP 协议了
所谓 TCP/IP 协议指的并不是一个协议，往往在生活中听见的术语如：IP地址， TCP连接 等，总会被误导，以为就是一个东西
实际上它们都是彼此独立的 协议 ，只不过会相互合作罢了
TCP/IP说的是一个 协议族 ，也就是说是一堆协议的统称


对比 OSI 和 TCP/IP 参考模型：




OSI
TCP/IP




应用层 表示层 会话层">
  
    <link rel="alternative" href="/atom.xml" title="WuShXin&#39;s fox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73783743-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->

  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b3641d1a0a36f80a0281a32bffce538b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">WuShXin&#39;s fox</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">狐狸永远是我的</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="www.wushxin.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-现代TCP-IP网络编程-启航" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/30/现代TCP-IP网络编程-启航.html" class="article-date">
  <time datetime="2015-10-30T10:16:53.000Z" itemprop="datePublished">2015-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      现代TCP/IP网络编程-启航
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的，实际上还有一个但这里不记录。</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code><a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>概念模糊的 <strong>DNS</strong><ul>
<li>其实很简单，它的作用就是用来找到域名所对应的 <strong>IP地址</strong></li>
<li>为什么？因为 <strong>IP地址</strong> 太难记了！如果你觉得 <strong>IPv4</strong> 地址还难不倒你，那请你试试 <strong>IPv6</strong></li>
<li>怎么查看域名对应的 <strong>IP地址</strong>，当然先不考虑 <strong>CDN</strong><ul>
<li><code>*nix</code> 和 <code>Windows</code> 都可以通过 <code>ping &lt;domain name&gt;</code> 命令进行查询</li>
</ul>
</li>
</ul>
</li>
<li><strong>MAC地址</strong> 和 <strong>端口号</strong><ul>
<li>对于前者，实际上应该是最熟悉不过的，对于网络上的主机而言，每一台主机就有一个专属的 <strong>MAC地址</strong></li>
<li>后者则是相当于一个房子的门，这个比喻在各大教材中广泛引用，但也的确贴切，假设 <strong>IP地址</strong> 是房子的地址，那么到了别人家要知道门在哪才行。</li>
</ul>
</li>
</ul>
<p>一个完整的应用程序传输数据时候 <strong>封装</strong> 的过程(<strong>从右二向左依次封装</strong>)：</p>
<table>
<thead>
<tr>
<th>以太网首部</th>
<th>IP</th>
<th>TCP/UDP</th>
<th>真实数据</th>
<th>尾部</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC地址</td>
<td>IP地址</td>
<td>TCP或者UDP协议</td>
<td>应用程序数据</td>
<td>效验码</td>
</tr>
<tr>
<td>源和目的MAC地址以及</td>
<td>及前层协议类型</td>
<td>源和目的端口号及前层应用程序首部信息</td>
<td>应用软件信息和真正的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中端口号实际上就是 <strong>应用程序的信息</strong></p>
<p>接收数据时的 <strong>拆解</strong> 顺序与 <strong>封装</strong> 正好相反。</p>
<ul>
<li><p>其中在传输过程中，作为接收方最开始使用的是 <strong>网络接口层/数据链路层</strong> 的驱动程序(即操作系统自带或另行安装，总之不用使用的程序员写就对了)，来判断这个包是否属于我，判断的依据就是 <strong>MAC地址</strong>，如果是再判断什么协议</p>
<ul>
<li>在此处的协议可不止 <strong>IP协议</strong>， 也可能是 <strong>ARP协议</strong> 等。之后就是就事论事交给相应的处理软件去处理(拆解)就行</li>
<li>科普： MAC地址是 <code>48bit</code> 的， 前<code>24bit</code>由 <strong>IEEE</strong> 分配， 后<code>24bit</code> 由厂商分配。原则上是唯一的。</li>
</ul>
</li>
<li><p><strong>MAC地址</strong> 和 <strong>IP地址</strong></p>
<ul>
<li>既然前方说到 <strong>MAC地址</strong> 和 <strong>IP地址</strong> 都能够作为识别另一个主机的唯一标识，但是为什么需要有两个相同功能的东西？</li>
<li>是，在一开始，网络很小的情况下，例如我们在同一个局域网中，我们之间需要<strong>通信</strong>的时候，只需要使用ARP协议，进行<strong>广播</strong>，向在一个网络中的所有主机发送消息就行，剩下的就让其他主机去判断(通过<strong>MAC地址</strong>)这个数据是不是发给我的。<ul>
<li><strong>ARP协议</strong> 的作用就是在同一个网络中，通过 <strong>广播</strong> 找出符合自己要求的主机的 <strong>MAC地址</strong> ，如果不在同一个网络中，又想知道对方的 <strong>MAC地址</strong>， 那只能借助把每个网络链接在一起的 <strong>网关</strong> 来帮助你发送 。 总之进行网络通信时必须知道对方的 <strong>IP地址 和 MAC地址</strong></li>
</ul>
</li>
<li>但是如果是现在整个互联网呢？不算 <strong>IPv6</strong> ，就算 <strong>IPv4</strong> 也是几十亿的存在，如果我从中国向国外发送信息，广播整个互联网的所有主机，那就炸了！</li>
<li>所以我们需要对世界网络进行分区，让大区域包含小区域，就像<strong>国家-省-市区…</strong> ， 很遗憾的是 <strong>MAC地址</strong> 是跟计算机相关而不是和位置相关的。所以我们有了 <strong>IP协议</strong></li>
<li><strong>IP协议</strong> 所附带的产品 <strong>IP地址</strong> 的作用就在帮助计算机识别自己是否在同一个网络中( <strong>这里省略了子网掩码的作用</strong> )。</li>
</ul>
</li>
<li><p>实际上，在进行网络编程的时候，以上细节几乎都被隐藏起来，留给我们的只是可供使用的接口。</p>
</li>
</ul>
<blockquote>
<p>也许，许多大学计算机基础课程，会讲到 IP地址 有种类，分为 A,B,C…类，老师还介绍了各种类型的地址范围。</p>
<p>但是在现代，这种分类早已经失效，或者说正在逐渐消失，因为当下的 IP 地址的 子网掩码 可以是任意位，并以反斜杠跟在 IP地址后方。</p>
<p>现代的 IP地址 形式一般如此 1.185.223.1/24 代表着子网掩码是由 24个 从左至右连续的的二进制1 组合而成，其余位为0。</p>
</blockquote>
<h2 id="夹在中间">夹在中间</h2><blockquote>
<p>事实上有一些实用且挺炫酷的函数，可以先提一下</p>
</blockquote>
<ul>
<li>域名 和 IP地址 的互查<ul>
<li><code>gethostbyname</code> 用于域名查找 IP信息及各类信息<ul>
<li><code>struct hostent * gethostbyname(const char * hostname)</code></li>
<li><code>struct hostent</code> 是存储查找到的各类型信息，后方会有介绍</li>
<li><code>hostname</code> 即要查询的域名</li>
</ul>
</li>
<li><code>gethostbyaddr</code> 用于IP地址查找 域名及各类信息<ul>
<li><code>struct hostent * gethostbyaddr(const char * addr, socklen_t len, int family)</code><ul>
<li><code>addr</code> 是要查询的 IP地址，之所以是 <code>const char *</code> 是因为C语言历史遗留的原因，实际上其类型应为 <code>struct in_addr *</code>(IPv4)</li>
<li><code>len</code> 地址的长度，即 <strong>IPv4</strong> 为4， <strong>IPv6</strong> 为16</li>
<li><code>family</code> 即协议的种类， <strong>IPv4</strong> 为 <code>AF_INET</code>, <strong>IPv6</strong> 为 <code>AF_INET6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>struct hostent 的成员</th>
<th>.</th>
<th>类型</th>
<th>.</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>h_name</td>
<td></td>
<td>char *</td>
<td></td>
<td>官方名称</td>
</tr>
<tr>
<td>h_aliases</td>
<td></td>
<td>char **</td>
<td></td>
<td>域名集合，以NULL结尾</td>
</tr>
<tr>
<td>h_addrtype</td>
<td></td>
<td>int</td>
<td></td>
<td>地址族的类型 AF_INET 或 AF_INET6</td>
</tr>
<tr>
<td>h_length</td>
<td></td>
<td>int</td>
<td></td>
<td>地址的长度 4 或 16</td>
</tr>
<tr>
<td>h_addr_list</td>
<td></td>
<td>char **</td>
<td></td>
<td>IP的集合，以NULL结尾, 实际上每个元素的类型为 struct in_addr*</td>
</tr>
</tbody>
</table>
<ul>
<li>其中第二和最后一个是关注的重点所在，可以在调用函数之后，输出信息<blockquote>
<p>实际上，这并不是一个好的方法，在后方将记录 现代人的我们 该如何做到这些事情，以上只是以前的TCP/IP 编程</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>只适用于 IPv4</p>
</blockquote>
<h2 id="套接字网络编程初始">套接字网络编程初始</h2><blockquote>
<p>选择使用 C 语言进行编程</p>
</blockquote>
<ul>
<li>在网络编程中，最常实用的两种连接方式 <code>TCP</code> 和 <code>UDP</code></li>
<li>最常编程的平台 <code>POSIX 标准-&gt;*nix平台标准</code> 和 <code>Windows 平台标准</code><ul>
<li>实际上，后者也是参考前者进行一些细微的改变(<strong>指的是接口</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比两种不同连接方式的不同地位的创建，使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP服务器</th>
<th>TCP客户端</th>
<th>UDP服务器</th>
<th>UDP客户端</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>创建套接字</td>
</tr>
<tr>
<td>bind()</td>
<td></td>
<td>bind()</td>
<td>bind()</td>
<td>绑定所分配IP地址和端口号</td>
</tr>
<tr>
<td>listen()</td>
<td>connect()</td>
<td></td>
<td></td>
<td>客户端则绑定IP地址和端口号，并等待连接；服务器则是等待连接</td>
</tr>
<tr>
<td>accept()</td>
<td></td>
<td></td>
<td></td>
<td>服务器接受连接</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>sendto/recvfrom()</td>
<td>sendto/recvfrom()</td>
<td>对于UDP即是连接也是操作</td>
</tr>
<tr>
<td>close()</td>
<td>close()</td>
<td>close()</td>
<td>close</td>
<td>双向直接关闭连接</td>
</tr>
<tr>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>可选择方向的关闭连接,即更加灵活</td>
</tr>
</tbody>
</table>
<p>如此对比虽然有一些小瑕疵，但是能够大体上反映出真个网络编程上不同方式的区别</p>
<blockquote>
<p>注1： 对于  sendto recvfrom 这两个接口函数，并不一定是只能用在 UDP类型的 套接字上，同样 TCP类型的 套接字也能使用，但是这么做并没有什么意义。</p>
<p>注2： 实际上 UDP 没有所谓的 服务器和和护短，因为本来就是单纯的互相发来发去。<strong>客户端端口</strong> 一般是随机的</p>
<p>以上是 *nix平台下的标准， Windows下的操作方式和 API有细微不同，但大部分是一致的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Windows</th>
<th>*nix</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
</tr>
<tr>
<td>bind()</td>
<td>bind()</td>
</tr>
<tr>
<td>connect()</td>
<td>connect()</td>
</tr>
<tr>
<td>listen()</td>
<td>listen()</td>
</tr>
<tr>
<td>accept()</td>
<td>accept()</td>
</tr>
<tr>
<td>closesocket()</td>
<td>close()</td>
</tr>
<tr>
<td>send()</td>
<td>send()</td>
</tr>
<tr>
<td>read()</td>
<td>read()</td>
</tr>
<tr>
<td>sendto()</td>
<td>sendto()</td>
</tr>
<tr>
<td>recvfrom()</td>
<td>recvfrom()</td>
</tr>
</tbody>
</table>
<p>不仅仅是接口名字相同，参数个数以及功能也是一致，即使有一个例外，其参数以及使用方法也相同。</p>
<blockquote>
<p>那岂不是可以直接移植了？</p>
<p>并不！</p>
</blockquote>
<p>在 <strong> Windows 套接字编程时</strong> ， 由于 <code>Windows</code> 将其实现为动态库，所以在使用时需要将其加载进程序。</p>
<p>故而多加了加载操作。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(
  WORD      wVersionRequested,
  LPWSADATA lpWSAData  <span class="comment">/* 这是一个结构体， 传入类型为WSADATA*  */</span>
)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>每当在 <strong>Windows</strong> 上进行套接字编程时，总要指定某个版本的套接字库：</p>
<pre><code>WSADATA wsaData;
int err_code;
/<span class="keyword">*</span>
<span class="keyword">*</span> MAKEWORD()的作用在于将版本号转为指定格式传入
<span class="keyword">*</span> 当下(2015-10)套接字库的版本号最高是 2.2
<span class="keyword">*</span>/
err_code = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
/<span class="keyword">*</span> TODO Something <span class="keyword">*</span>/
WSACleanup();
</code></pre><p>这是最基本的在 <strong>Windows</strong> 上使用 <strong>套接字</strong> 编程的流程，但是如果本平台的套接字库最高版本并不符合当前要求呢？</p>
<p>那么首先会将套接字版本库尽可能设置到平台的 <strong>最高版本</strong> ，可以通过结构体 <code>WSADATA</code> 进行查询</p>
<pre><code><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)
{
  <span class="built_in">printf</span>(<span class="string">"Could not find a usable version of Winsock.dll\n"</span>);
  WSACleanup();
  <span class="built_in">return</span> <span class="number">1</span>;
}
</code></pre><blockquote>
<p>总体而言， <code>Windows平台</code> 和 <code>*uix平台</code> 的区别在于，前者使用时需要 加载和清除 套接字库<br>其余逻辑流程一致，毕竟只有统一才能越利于编程世界的发展。</p>
</blockquote>
<h2 id="套接字编程">套接字编程</h2><ul>
<li>两种协议 <code>TCP</code> 和 <code>UDP</code><ul>
<li>前者可以理解为有保证的连接，后者是追求快速的连接</li>
<li>当然最后一点有些 <strong>太过绝对</strong> ，但是现在不需熬考虑太多，因为初入套接字编程，一切从简</li>
<li>稍微试想便能够大致理解， <code>TCP</code> 追求的是可靠的传输数据， <code>UDP</code> 追求的则是快速的传输数据</li>
<li>前者有繁琐的连接过程，后者则是根本不建立可靠连接(不是绝对)，只是将数据发送而不考虑是否到达。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下例子以 <code>*nix</code> 平台的便准为例，因为 <code>Windows</code>平台需要考虑额外的加载问题，稍作添加就能在 Windows 平台上运行</p>
</blockquote>
<h3 id="UDP">UDP</h3><ul>
<li><p><code>UDP</code></p>
<ul>
<li>这是一个十分简洁的连接方式，假设有两台主机进行通信，一台只发送，一台只接收。</li>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in recv_host, send_host;

/<span class="keyword">*</span> 创建套接字 <span class="keyword">*</span>/
sock = socket(PF_INET, SOCK_DGRAM, 0);

/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
memset(&amp;recv_host, 0, sizeof(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);

/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><p>上述代码省略了许多必要的 <strong>错误检查</strong> ，在实际编写时要添加</p>
</li>
<li>代码解释：<ol>
<li><strong>PF_INET</strong> 代表协议的类型，此处代表 <strong>IPv4</strong> 网络协议族， 同样 <strong>PF_INET6</strong> 代表 <strong>IPv6</strong> 网络协议族，这个范围在后方单独记录，不与IPv4混在一起(并不意味着更复杂，实际上更简便)。</li>
<li><strong>AF_INET</strong> 代表地址的类型，此处代表 <strong>IPv4</strong> 网络协议使用的地址族， 同样有 <strong>AF_INET6</strong> (在操作系统实现中 PF_INET 和 AF_INET 的值一样，<strong>但是还是要写宏更好，而不应该直接用数字或者，混淆使用</strong>)</li>
<li><code>htonl</code> 和 <code>htons</code> 两个函数的使用涉及到 <strong>大端小端问题</strong>， 这里不叙述，需要记住的是在网络编程时一定要使用这种函数将必要信息转为 <strong>大端表示法</strong> 。</li>
<li><code>(struct sockaddr *)</code> 这个强制转换是为了参数的必须，但不会出错，因为 <code>sizeof(struct sockaddr_in) == sizeof(struct sockaddr)</code> 具体可以查询相关信息，之所以这么做是为了方便编写套接字程序的程序员。</li>
</ol>
</li>
<li>发送端：<pre><code><span class="keyword">int</span> sock;
<span class="keyword">const</span> <span class="keyword">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="keyword">char</span> get_mess[GET_MAX]; <span class="comment">/* 后续版本使用 */</span>
<span class="keyword">struct</span> sockaddr_in recv_host;
socklen_t addr_len;
<span class="comment">/* 创建套接字 */</span>
sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);
<span class="comment">/* 绑定 */</span>
<span class="built_in">memset</span>(&amp;recv_host, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
<span class="comment">/* 发送信息 */</span>
<span class="comment">/* 在此处，发送端的IP地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */</span>
sendto(sock, mess, <span class="built_in">strlen</span>(mess), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 完成，关闭 */</span>
close(sock);
</code></pre>上述代码是发送端。</li>
<li>代码解释：<ol>
<li><code>inet_addr</code> 函数是用于将字符串格式的 <strong>IP地址</strong> 转换为 大端表示法的 地址类型，即 <code>s_addr</code> 的类型 <code>in_addr_t</code></li>
<li>与之相反，同样也有功能相反的函数 <code>inet_ntoa</code> 用于将 <code>in_addr_t</code> 类型转为字符串，但是使用时一定要记住及时拷贝返回值<pre><code><span class="type">char</span> <span class="keyword">addr</span>[<span class="number">16</span>];
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
strcpy(<span class="keyword">addr</span>, inet_ntoa(recv_host.sin_addr.s_addr));
</code></pre></li>
</ol>
</li>
<li>从上述代码看出， <code>UDP</code> 协议的使用十分简洁，几乎就是 <strong>创建套接字-&gt;准备数据-&gt;装备套接字-&gt;发送/接收-&gt;结束</strong></li>
<li>其中，都没有连接的操作，但是实际上这是为了方便 <code>UDP</code> 随时和 <strong>不同的主机</strong> 进行通信所默认的设置，如果需要和相同主机一直通信呢？</li>
<li>此中的原由<strong>暂时不需要</strong>知道，记录方法，即长时间使用 <code>UDP</code> 和同一主机通信时，可以使用 <code>connect</code> 函数来进行优化自身。此时 <strong>假设两台主机的实际功能一致，既接收也发送</strong></li>
<li>发送端：<pre><code><span class="comment">/* 前方高度一致，将 bind函数替换为 */</span>
connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host); <span class="comment">// 将对方的 IP地址和 端口号信息 注册进UDP的套接字中)</span>
<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 循环的发送和接收信息 */</span>
{
  size_t read_len = <span class="number">0</span>;
  <span class="comment">/* 原先使用的 sendto 函数，先择改为使用 write 函数， Windows平台为 send 函数 */</span>
  write(sock, mess, <span class="built_in">strlen</span>(mess));            <span class="comment">/* send(sock, mess, strlen(mess), 0) FOR Windows Platform */</span>
  read_len = read(sock, get_mess, GET_MAX-<span class="number">1</span>); <span class="comment">/* recv(sock, mess, strlen(mess)-1, 0) FOR Windows Platform */</span>
  get_mess[read_len-<span class="number">1</span>] = <span class="string">'\0'</span>;
  <span class="built_in">printf</span>(<span class="string">"In Client like Host Recvive From Other Host : %s\n"</span>, get_mess);
}
<span class="comment">/* 后方高度一致 */</span>
</code></pre></li>
<li>接收端：<pre><code>/<span class="keyword">*</span> 前方一致， 添加额外的 struct sockaddr_in send_host; 并添加循环，构造收发的现象<span class="keyword">*</span>/
while(1)
{
  size_t read_len = 0;
  char sent_mess[15] = <span class="string">"Hello Sender!"</span>; /<span class="keyword">*</span> 用于发送的信息 <span class="keyword">*</span>/
  sendto(sock, mess, strlen(sent_mess), 0, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
  read_len = recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len)
  mess[read_len-1] = '\0';
  printf(<span class="string">"In Sever like Host Recvive From other Host : %s\n"</span>, mess);
}
/<span class="keyword">*</span> 后方高度一致 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> 之所以只在接收端使用 connect 的原因，便在于我们模拟的是 客户端-服务器 的模型，而服务器的各项信息是不会随意变更的
<span class="keyword">*</span> 但是 客户端就不同了，可能由于 ISP(Internet Server Provider) 的原因，你的IP地址不可能总是固定的，所以只能
<span class="keyword">*</span> 保证 在客户端 部分注册了 服务器 的各类信息，而不能在 服务器端 注册 客户端 的信息。
<span class="keyword">*</span> 当然也有例外，例如你就想这个软件作为私密软件，仅供两个人使用， 且你有固定的 IP地址，那么你可以两边都connect，但是
<span class="keyword">*</span> 一定要注意，只要有一点信息变动，这个软件就可能无法正常的收发信息了。
<span class="keyword">*</span>/
</code></pre></li>
<li>代码解释<ul>
<li>故而实际上，虽然前方的表格显示，<code>UDP</code> 似乎并没有 <code>connect</code> 的使用必要，但是实际上还是有用到的地方。</li>
<li>就 <code>*nix</code> 的 <strong>API</strong> 来说，<code>sendto</code> 和  <code>write</code> 的区别十分明显，便是一个需要在参数中提供目标主机的各类信息，而后者则不需要提供。同样的道理<code>recvfrom</code>和<code>read</code>也是如此。</li>
<li>这个代码只是做演示而已，所以将代码置于无限循环当中，现实中可以自行定义出口条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上是 UDP 的一些简单说明，入门足矣，并未详细叙述某些 函数 的具体用法，而是用实际例子来体现。<br>在 记录 TCP 之前，还是需要讲一个函数 shutdown</p>
</blockquote>
<ul>
<li><code>shutdown</code> 与 <code>close(closesocket)</code><ul>
<li>首先要知道，网络通信一般而言是双方的共同进行的，换而言之就是双向的，一个方向只用来发送消息，一个方向只用来读取消息。</li>
<li>这就导致了，在结束套接字通信的时候，需要关闭两个方向的通道(暂时叫它们通道)，那同时关闭不行吗？可以啊<ul>
<li><code>close(sock); // closesocket(sock); FOR Windows PlatForm</code> 就是这么干的，同时断开两个方向的连接。</li>
<li>简单的通信程序或者单向通信程序这么做的确无甚大碍，但是万一在结束通信的时候需要接收最后一个信息那该怎么办？<ul>
<li>假设通信结束，客户端向服务器发送 “Thank you”</li>
<li>服务器需要接收这个信息，之后才能关闭通信</li>
<li>问题就在这之间，服务器并不知道客户端会在通信结束后的什么时刻传来信息</li>
<li>所以我们选择在通信完成后先关闭 服务器的 发送通道(写流)，等待客户端发来消息后，关闭剩下的 接收通道(读流)</li>
</ul>
</li>
</ul>
</li>
<li>发送端：<pre><code><span class="comment">/* 假设有一个 TCP 的连接，此为客户端 */</span>
write<span class="comment">(sock, "Thank you", 10)</span>;
close<span class="comment">(sock)</span>; <span class="comment">// 写完直接关闭通信</span>
</code></pre></li>
<li>接收端：<pre><code><span class="comment">/* 此为服务器 */</span>
<span class="comment">/* 首先关闭写流 */</span>
shutdown(sock_c, SHUT_WR);
<span class="keyword">read</span>(sock_c, get_mess, GET_MAX);
printf(<span class="string">"Message : %s\n"</span>, get_mess);
<span class="keyword">close</span>(sock_c);
<span class="keyword">close</span>(sock_s); <span class="comment">// 关闭两个套接字是因为 TCP 服务器端的需要，后续会记录</span>
</code></pre></li>
<li>代码解释<ul>
<li><code>shutdown</code> 函数的作用就是 可选择的关闭那个方向的输出<ul>
<li><code>int shutdown(int sock, int howto);</code></li>
<li><code>sock</code> 代表要操作的套接字</li>
<li><code>howto</code>有几个选择  <ul>
<li><strong> *nix </strong> : <code>SHUT_RD</code> <code>SHUT_WR</code> <code>SHUT_RDWR</code></li>
<li><strong> Windows </strong> : <code>SD_RECEIVE</code> <code>SD_SEND</code> <code>SD_BOTH</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="停下来">停下来</h3><ol>
<li>程序员应该越来越来，做的事情应该越来越少，但是能达到的成就应该越来越多</li>
<li>在 IPv6 出现的今天，网络编程已经开始向简洁和强大靠近，即便是身为底层语言的 C语言</li>
<li>实际上由于 C语言 并没有自己的<strong>网络库</strong>， 故为了能进行网络编程，不得不依赖于系统函数，这就是所谓的<strong>系统编程</strong>， 你已经是一个系统程序员了。</li>
<li>而 系统函数 随着时代的变化，正在不断完善，增加(几乎没有废除的先例，所以不用担心之前的程序无法运行)。</li>
<li>相应的，由于以前的网络编程只适合于 IPv4 的地址，自从出现了 IPv6, 我们需要一套全新的方式，正好他来了。</li>
</ol>
<h3 id="新时代的_套接字网络编程">新时代的 套接字网络编程</h3><ol>
<li>首先有几个结构体，以及一个接口十分重要及常用：<ul>
<li><code>struct sockaddr_in6</code> ： 代表的是 IPv6 的地址信息</li>
<li><code>struct addrinfo</code> : 这是一个通用的结构体，里面可以存储 IPv4 或 IPv6 类型地址的信息</li>
<li><code>getaddrinfo</code> ： 这是一个十分方便的接口，在上述 UDP 程序中许多<strong>手动填写</strong>的部分，都能够省去，有该函数替我们完成</li>
</ul>
</li>
<li><p>改写一下上方的例子：</p>
<ul>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in host_v4; /<span class="keyword">*</span> IPv4 地址 <span class="keyword">*</span>/
struct sockaddr_in6 host_v6; /<span class="keyword">*</span> IPv6 地址 <span class="keyword">*</span>/
struct addrinfo easy_to_use; /<span class="keyword">*</span> 用于设定要获取的信息以及如何获取信息 <span class="keyword">*</span>/
struct addrinfo <span class="keyword">*</span>result;    /<span class="keyword">*</span> 用于存储得到的信息(需要注意内存泄露) <span class="keyword">*</span>/
struct addrinfo <span class="keyword">*</span> p;

/<span class="keyword">*</span> 准备信息 <span class="keyword">*</span>/
memset(&amp;easy_to_use, 0, sizeof easy_to_use);
easy_to_use.ai_family = AF_UNSPEC; /<span class="keyword">*</span> 告诉接口，我现在还不知道地址类型 <span class="keyword">*</span>/
easy_to_use.ai_flags = AI_PASSIVE; /<span class="keyword">*</span> 告诉接口，稍后“你”帮我填写我没明确指定的信息 <span class="keyword">*</span>/
easy_to_use.ai_socktype = SOCK_DGRAM; /<span class="keyword">*</span> UDP 的套接字 <span class="keyword">*</span>/
/<span class="keyword">*</span> 其余位都为 0 <span class="keyword">*</span>/

/<span class="keyword">*</span> 使用 getaddrinfo 接口 <span class="keyword">*</span>/
getaddrinfo(NULL, argv[1], &amp;easy_to_use, &amp;result); /<span class="keyword">*</span> argv[1] 中存放字符串形式的 端口号 <span class="keyword">*</span>/

/<span class="keyword">*</span> 创建套接字，此处会产生两种写法，但更保险，可靠的写法是如此 <span class="keyword">*</span>/
/<span class="keyword">*</span> 旧式方法
<span class="keyword">*</span>  sock = socket(PF_INET, SOCK_DGRAM, 0);
<span class="keyword">*</span>/
/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
/<span class="keyword">*</span> 旧式方法
<span class="keyword">*</span>  memset(&amp;recv_host, 0, sizeof(recv_host));
<span class="keyword">*</span>  recv_host.sin_family = AF_INET;
<span class="keyword">*</span>  recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
<span class="keyword">*</span>  recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
<span class="keyword">*</span>  bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
<span class="keyword">*</span>/

for(p = result; p != NULL; p = p-&gt;ai_next) /<span class="keyword">*</span> 该语法需要开启 -std=gnu99 标准<span class="keyword">*</span>/
{
  sock = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
  if(sock == -1)
    continue;
  if(bind(sock, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1)
  {
    close(sock);
    continue;
  }
  break; /<span class="keyword">*</span> 如果能执行到此，证明建立套接字成功，套接字绑定成功，故不必再尝试。 <span class="keyword">*</span>/
}

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
//recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);
switch(p-&gt;ai_socktype)
{
  case AF_INET :
    addr_len = sizeof host_v4;
    recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_v4, &amp;addr_len);
    break;
  case AF_INET6:
    addr_len = sizeof host_v6
    recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_v6, &amp;addr_len);
    break;
  default:
    break;
}
freeaddrinfo(result); /<span class="keyword">*</span> 释放这个空间，由getaddrinfo分配的 <span class="keyword">*</span>/
/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><ul>
<li><p>代码解释：</p>
<ul>
<li><p>首先解释几个新的结构体</p>
<ol>
<li><p><code>struct addrinfo</code> 这个结构体的内部顺序对于 <code>*nix</code> 和 <code>Windows</code> 稍有不同，以 <code>*nix</code> 为例</p>
<pre><code><span class="keyword">struct</span> addrinfo{
  <span class="keyword">int</span> ai_flags;
  <span class="keyword">int</span> ai_family;
  <span class="keyword">int</span> ai_socktype;
  <span class="keyword">int</span> ai_protocol;
  socklen_t ai_addrlen;
  <span class="keyword">struct</span> sockaddr * ai_addr; <span class="comment">/* 存放结果地址的地方 */</span>
  <span class="keyword">char</span> * ai_canonname; <span class="comment">/* 忽略它吧，很长一段时间你无须关注它 */</span>
  <span class="keyword">struct</span> addrinfo * ai_next; <span class="comment">/* 一个域名/IP地址可能解析出多个不同的 IP */</span>
};
</code></pre></li>
<li><code>ai_family</code> 如果设定为 <code>AF_UNSPEC</code> 那么在调用 <code>getaddrinfo</code> 时，会自动帮你确定，传入的地址是什么类型的</li>
<li><code>ai_flags</code>  如果设定为 <code>AI_PASSIVE</code> 那么调用 <code>getaddrinfo</code> 且向其第一个参数传入 <code>NULL</code> 时会自动绑定自身 IP，相当于设定 <code>INADDR_ANY</code></li>
<li><code>ai_socktype</code> 就是要创建的套接字类型，这个必须明确声明，系统没法预判(日后人工智能说不定呢?)</li>
<li><code>ai_protocol</code> 一般情况下我们设置为 <code>0</code>，含义可以自行查找，例如 <code>MSDN</code> 或者 <code>UNP</code></li>
<li><code>ai_addr</code>    这里保存着结果，可以通过 调用<code>getaddrinfo</code><strong>之后</strong> 的<strong>第四个参数</strong>获得。</li>
<li><code>ai_addrlen</code> 同上</li>
<li><code>ai_next</code>    同上</li>
<li><p><code>getaddrinfo</code> 强大的接口函数</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * node, <span class="keyword">const</span> <span class="keyword">char</span> * service,
                  <span class="keyword">const</span> <span class="keyword">struct</span> addrinfo * hints, <span class="keyword">struct</span> addrinfo ** res)</span></span>;
</code></pre></li>
<li>通俗的说这几个参数的作用</li>
<li><code>node</code> 便是待获取或者待绑定的 <strong>域名</strong> 或是 <strong>IP</strong>，也就是说，这里可以直接填写域名，由操作系统来转换成 <strong>IP</strong> 信息，或者直接填写<strong>IP</strong>亦可，是以字符串的形式</li>
<li><code>service</code> 便是端口号的意思，也是字符串形式</li>
<li><code>hints</code> 通俗的来说就是告诉接口，我需要你反馈哪些信息给我(第四个参数)，并将这些信息填写到第四个参数里。</li>
<li><code>res</code> 便是保存结果的地方，需要注意的是，这个结果在API内部是动态分配内存了，所以使用完之后需要调用另一个接口(<code>freeaddrinfo</code>)将其释放</li>
<li><p>实际上对于现代的　套接字编程 而言，多了几个新的存储 IP 信息的结构体，例如 <code>struct sockaddr_in6</code> 和 <code>struct sockaddr_storage</code> 等。</p>
<ul>
<li><p>其中，前者是后者的大小上的子集，即一个 <code>struct storage</code> 一定能够装下一个 <code>struct sockaddr_in6</code>,具体(实际上根本看不到有意义的实现)</p>
<pre><code><span class="keyword">struct</span> sockaddr_in6{
  u_int16_t sin6_family;
  u_int16_t sin6_port;
  u_int32_t sin6_flowinfo; <span class="comment">/* 暂时忽略它 */</span>
  <span class="keyword">struct</span> in6_addr sin6_addr; <span class="comment">/* IPv6 的地址存放在此结构体中 */</span>
  u_int32_t sin_scope_id;  <span class="comment">/* 暂时忽略它 */</span>
};
<span class="keyword">struct</span> in6_addr{
  <span class="keyword">unsigned</span> <span class="keyword">char</span> s6_addr[<span class="number">16</span>];
}
------------------------------------------------------------
<span class="keyword">struct</span> sockaddr_storage{
  sa_family_t ss_family; <span class="comment">/* 地址的种类 */</span>
  <span class="keyword">char</span> __ss_pad1[_SS_PAD1SIZE]; <span class="comment">/* 从此处开始，不是实现者几乎是没办法理解 */</span>
  <span class="keyword">int64_t</span> __ss_align;           <span class="comment">/* 从名字上可以看出大概是为了兼容两个不同 IP 类型而做出的妥协 */</span>
  <span class="keyword">char</span> __ss_pad2[_SS_PAD2SIZE]; <span class="comment">/* 隐藏了实际内容，除了 IP 的种类以外，无法直接获取其他的任何信息。 */</span>
  <span class="comment">/* 在各个*nix 的具体实现中， 可能有不同的实现，例如 `__ss_pad1` ， `__ss_pad2` , 可能合并成一个 `pad` 。 */</span>
};
</code></pre><p>在实际中，我们往往不需要为不同的IP类型声明不同的存储类型，直接使用 <code>struct sockaddr_storage</code> 就可以，使用时直接<strong>强制转换类型</strong>即可</p>
</li>
</ul>
</li>
<li><p>改写上方  <strong>接收端</strong> 例子中，进入接收信息的状态部分</p>
<pre><code>/<span class="keyword">*</span> 首先将多于的变量化简 <span class="keyword">*</span>/
// - struct sockaddr_in host_v4; /<span class="keyword">*</span> IPv4 地址 <span class="keyword">*</span>/
// - struct sockaddr_in6 host_v6; /<span class="keyword">*</span> IPv6 地址
struct sockaddr_storage host_ver_any; /<span class="keyword">*</span> + 任意类型的 IP 地址 <span class="keyword">*</span>/
...
/<span class="keyword">*</span> 进入接收信息的状态部分 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_ver_any, &amp;addr_len); /<span class="keyword">*</span> 像是又回到了只有 IPv4 的年代<span class="keyword">*</span>/
</code></pre></li>
<li><p>补充完整上方对应的 <strong>发送端</strong> 代码</p>
<pre><code><span class="type">int</span> sock;
<span class="keyword">const</span> <span class="type">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="type">char</span> get_mess[<span class="type">GET_MAX</span>]; /* 后续版本使用 */
struct sockaddr_storage recv_host; /* - struct sockaddr_in recv_host; */
struct addrinfo tmp, *<span class="literal">result</span>;
struct addrinfo *p;
socklen_t addr_len;

/* 获取对端的信息 */
memset(&amp;tmp, <span class="number">0</span>, sizeof tmp);
tmp.ai_family = <span class="type">AF_UNSPEC</span>;
tmp.ai_flags = <span class="type">AI_PASSIVE</span>;
tmp.ai_socktype = <span class="type">SOCK_DGRAM</span>;
getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;tmp, &amp;<span class="literal">result</span>); /* argv[<span class="number">1</span>] 代表对端的 <span class="type">IP</span>地址， argv[<span class="number">2</span>] 代表对端的 端口号 */

/* 创建套接字 */
<span class="keyword">for</span>(p = <span class="literal">result</span>; p != <span class="type">NULL</span>; p = p-&gt;ai_next)
{
  sock = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);  /* - sock = socket(<span class="type">PF_INET</span>, <span class="type">SOCK_DGRAM</span>, <span class="number">0</span>); */
  <span class="keyword">if</span>(sock == -<span class="number">1</span>)
    <span class="keyword">continue</span>;
  /* 此处少了绑定 <span class="keyword">bind</span> 函数，因为作为发送端不需要讲对端的信息 绑定 到创建的套接字上。 */  
  <span class="keyword">break</span>; /* 找到就可以退出了，当然也有可能没找到，那么此时 p 的值一定是 <span class="type">NULL</span> */
}
<span class="keyword">if</span>(p == <span class="type">NULL</span>)
{
  /* 错误处理 */
}
/* -// 设定对端信息
memset(&amp;recv_host, <span class="number">0</span>, sizeof(recv_host));
recv_host.sin_family = <span class="type">AF_INET</span>;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
*/

/* 发送信息 */
/* 在此处，发送端的<span class="type">IP</span>地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */
sendto(sock, mess, strlen(mess), <span class="number">0</span>, p-&gt;ai_addr, p-&gt;ai_addrlen);
/* 完成，关闭 */
freeaddrinfo(<span class="literal">result</span>); /* 实际上这个函数应该在使用完 <span class="literal">result</span> 的地方就予以调用 */
close(sock);                
</code></pre></li>
<li>到了此处，实际上是开了网络编程的一个初始，解除了现代的 UDP 最简单的用法(<strong>甚至还算不上完整的使用</strong>)，但是确实是进行了交互。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="#">#</h3><ul>
<li>首先介绍 UDP 并不是因为它简单，而是因为他简洁，也不是因为它不重要，相反他其实很强大。</li>
<li>永远不要小看一个简洁的东西，就像 <strong>C语言</strong></li>
<li>下一篇将详细记录 <strong>UDP</strong> 的相关记录</li>
</ul>
<h4 id="在这之前">　在这之前</h4><ul>
<li>首先还是科普记录一下协议的知识。</li>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">阮一峰的博客 ： 互联网协议入门(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="external">阮一峰的比克 :  互联网协议入门(二)</a></li>
<li>上述两篇文章十分浅显易懂，十分符合科普二字，下方将对上述两个文章进行适当的补充。</li>
</ul>
<h4 id="ARP_协议">ARP 协议</h4><ul>
<li>最简便的方法就是找一个有 WireShark 软件或者 <code>tcpdump</code> 的 <code>*nix</code> 平台，前者你可以选择随意监听一个机器，不多时就能看见 <strong>ARP</strong><br>协议的使用，因为它使用的太频繁了。</li>
<li>对于 ARP 协议而言，首先对于一台机器 A，想与 机器B 通信，(假设此时 机器A 的<strong>高速缓存区(操作系统一定时间更新一次)</strong>中 没有 机器B的缓存)，<ul>
<li>那么机器A就向广播地址发出 <strong>ARP请求</strong>，如果 机器B 收到了这个请求，就将自己的信息(IP地址，MAC地址)填入 <strong>ARP应答</strong> 中，再发送回去就行。</li>
<li>上述中， <strong>ARP请求</strong> 和 <strong>ARP应答</strong> 是一种报文形式的信息，是 ARP协议 所附带的实现产品，也是用于两台主机之间进行通信。</li>
<li>这是当 机器A 和 机器B 同处于一个网络的情况下，可以借由本网络段的广播地址 发送请求报文。</li>
</ul>
</li>
<li>对于不同网络段的 机器A 与 机器B 而言，想要通过 <strong>ARP协议</strong> 获取 <strong>MAC地址</strong> ，就需要借助路由器的帮助了，可以想象一下，路由器(可以不止一个)在中间，机器A 和 机器B 分别在这些路由器的两边(即在不同子网)<ul>
<li>由于 A 和 B 不在同一个子网内，所以没办法通过通过直接通过广播到达，但是有了路由器，就能进行 <strong>ARP代理</strong> 的操作，大概就是将路由器当成机器B， A向自己的本地路由器发送 <strong>ARP请求</strong></li>
<li>之后路由器判断出是发送给B的ARP请求，又正好 B 在自己的管辖范围之内，就把自己的硬件地址 写入 <strong>ARP应答</strong> 中发回去，之后再有A向B 的数据，就都是A先发送给路由器，再经由路由器发往B了</li>
<li>一篇比较好的资源是 <a href="www.cisco.com/c/en/us/support/docs/ip/dynamic-address-allocation-resolution/13718-5.html">Proxy ARP</a><h4 id="ICMP">ICMP</h4></li>
</ul>
</li>
<li>这个协议比较重要，后方的概念也会涉及。<ul>
<li><strong>请求应答报文</strong> 和 <strong>差错报文</strong> ，重点在于差错报文。</li>
<li>请求应答报文在 <code>ICMP</code> 的应用中可以拿来查询本机的子网掩码之类的信息，大致通过向本子网内的所有主机发送该请求报文(包括自己，实际上就是广播)，后接收应答，得到信息</li>
<li>差错报文在后续中会有提到，这里需要科普一二。</li>
<li>首先对于差错报文的一大部分是关于 <strong>xxx不可达</strong> 的类型，例如主机不可达，端口不可达等等，每次出现错误的时候，ICMP报文总是第一时间返回给对端，(它一次只会出现一份，否则会造成网络风暴)，但是对端是否能够接收到，就不是发送端的问题了。</li>
<li>这点上 套接字的类型 有着一定的联系，例如 UDP 在 <code>unconnected</code> 状态下是会忽略 ICMP报文的。而 TCP 因为总是 <code>connected</code> 的，所以对于 ICMP报文能很好的捕捉。</li>
<li>ICMP差错报文中总是带着 <strong>出错数据报中的一部分真实数据</strong>，用于配对。</li>
</ul>
</li>
</ul>
<p>转载注明: <a href="http://www.wushxin.top/2015/10/30/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%90%AF%E8%88%AA.html" target="_blank" rel="external">http://www.wushxin.top/2015/10/30/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%90%AF%E8%88%AA.html</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.wushxin.top/2015/10/30/现代TCP-IP网络编程-启航.html" data-id="cimsi2zg70005y0ltfh31jybf" class="article-share-link" data-share="baidu" data-title="现代TCP/IP网络编程-启航">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/04/现代TCP-IP网络编程-UDP.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          现代TCP/IP网络编程-UDP
        
      </div>
    </a>
  
  
    <a href="/2015/09/20/Linux记录.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Linux记录</div>
    </a>
  
</nav>

  
</article>


<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            </section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/">Cpp</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/">GDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Opencv/">Opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂货居/">杂货居</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂货居，-Linux/">杂货居， Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站/">网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C</a><a href="/tags/Cpp/" style="font-size: 16px;">Cpp</a><a href="/tags/GDB/" style="font-size: 10px;">GDB</a><a href="/tags/Linux/" style="font-size: 10px;">Linux</a><a href="/tags/Opencv/" style="font-size: 10px;">Opencv</a><a href="/tags/Python/" style="font-size: 12px;">Python</a><a href="/tags/Qt/" style="font-size: 12px;">Qt</a><a href="/tags/分布式/" style="font-size: 10px;">分布式</a><a href="/tags/杂货居/" style="font-size: 18px;">杂货居</a><a href="/tags/杂货居，-Linux/" style="font-size: 10px;">杂货居， Linux</a><a href="/tags/网站/" style="font-size: 10px;">网站</a><a href="/tags/网络编程/" style="font-size: 14px;">网络编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/09/直接理解红黑树旋转.html">直接理解红黑树旋转</a>
          </li>
        
          <li>
            <a href="/2016/03/28/使用tmux.html">使用tmux</a>
          </li>
        
          <li>
            <a href="/2016/03/26/一个HTTP服务器的C之路-下.html">一个HTTP服务器的C之路(下)</a>
          </li>
        
          <li>
            <a href="/2016/03/23/一个HTTP服务器的C之路(上).html">一个HTTP服务器的C之路（上）</a>
          </li>
        
          <li>
            <a href="/2016/03/19/使用gdb.html">使用gdb</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 吴生鑫<br>
      
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
