
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Effective Modern Cpp 概述（二） | WuShXin&#39;s fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="(Item 14)

Item 12 - Declare overriding functions override.
介绍了一个鲜为人知的 C++11 新特性，针对一个类成员函数的
class Widget {
public:
  ...
  void doWork() &amp;amp;;   // 只有当 *this 是 lvalue 时才调用
  void doWork() &amp;amp;&amp;amp;;">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern Cpp 概述（二）">
<meta property="og:url" content="http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-概述（二）.html">
<meta property="og:site_name" content="WuShXin's fox">
<meta property="og:description" content="(Item 14)

Item 12 - Declare overriding functions override.
介绍了一个鲜为人知的 C++11 新特性，针对一个类成员函数的
class Widget {
public:
  ...
  void doWork() &amp;amp;;   // 只有当 *this 是 lvalue 时才调用
  void doWork() &amp;amp;&amp;amp;;">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Modern Cpp 概述（二）">
<meta name="twitter:description" content="(Item 14)

Item 12 - Declare overriding functions override.
介绍了一个鲜为人知的 C++11 新特性，针对一个类成员函数的
class Widget {
public:
  ...
  void doWork() &amp;amp;;   // 只有当 *this 是 lvalue 时才调用
  void doWork() &amp;amp;&amp;amp;;">
  
    <link rel="alternative" href="/atom.xml" title="WuShXin&#39;s fox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73783743-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->

  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b3641d1a0a36f80a0281a32bffce538b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">WuShXin&#39;s fox</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Tech Collector</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="www.wushxin.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Effective-Modern-Cpp-概述（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/22/Effective-Modern-Cpp-概述（二）.html" class="article-date">
  <time datetime="2016-02-22T01:29:50.000Z" itemprop="datePublished">2016-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective Modern Cpp 概述（二）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>(Item 14)</p>
</blockquote>
<h3 id="Item_12_-_Declare_overriding_functions_override-">Item 12 - Declare overriding functions override.</h3><ul>
<li><p>介绍了一个鲜为人知的 <strong>C++11</strong> 新特性，针对一个类成员函数的</p>
<pre><code><span class="keyword">class</span> <span class="title">Widget</span> {
<span class="keyword">public</span>:
  ...
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;   <span class="comment">// 只有当 *this 是 lvalue 时才调用</span>
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;  <span class="comment">// 只有当 *this 是 rvalue 时才调用</span>
};
...
<span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// 制造一个临时的 Widget</span>
<span class="comment">// 调用</span>
Widget w; <span class="comment">// 默认构造函数创建</span>
w.doWork(); <span class="comment">// 调用第一个版本(lvalue)</span>
makeWidget().doWork(); <span class="comment">// 调用第二个版本</span>
</code></pre></li>
<li><p>对于 <strong>重写</strong> 和 <strong>重载</strong>，这两个极易混淆，或者说不是混淆而是十分容易不小心就写错了，的功能，在 <strong>C++98</strong> 之前我们只能选择相信程序员写下的代码是准确无误的。有几个判断 <strong>重写</strong> 的条件</p>
<ol>
<li>基类里的该函数必须是 <code>virtual</code></li>
<li>基类里的该函数和派生类里的该函数的 <strong>函数名</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>参数类型</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>返回值类型</strong> 必须相同或者可以<strong>兼容(即继承关系)</strong></li>
<li>基类里的该函数和派生类里的该函数的 <code>const</code> 属性必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>引用限定词</strong> 必须相同(<strong>C++11新增</strong>)<a id="more"></a></li>
</ol>
</li>
<li><p>上述关系缺一不可。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;  <span class="comment">// C++11 </span>
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;
};
<span class="comment">// C++98</span>
<span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">public</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(unsigned <span class="keyword">int</span> x)</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;
};        
<span class="comment">// C++11</span>
<span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">public</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(unsigned <span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;
};
</code></pre><p>  其中 <code>Derived</code> 类中的 <strong>重写</strong> 函数前面的 <code>virtual</code> 不是强制性要求。相比于<strong>C++98</strong> 而言对了一个关键字<code>override</code>，其作用就是帮助我们在编译期检查到是否在重写的时候出了差错</p>
<p>  <strong>C++98</strong> 版本的<code>mf2</code>函数可以通过编译，但是 <strong>C++11</strong> 版本的<code>mf2</code>函数便无法通过编译，因为<code>override</code>告诉编译器这是一个<strong>重写</strong>函数，但是实际上我们的 <code>mf2</code> 并不符合要求。</p>
</li>
<li><code>override</code>的作用便在于让编译器替我们检查错误，并且在实现一个工程时，往往需要改变某个函数来修改原有的内容业务，这时候可以借助编译器的<strong>错误提示</strong>看看修改这个函数，会对整个工程造成多大的影响，以及是否值得如此做。</li>
<li><p>对于新的 <strong>引用限定词</strong> 的用法，大体上会用在判断 <strong>lvalue</strong> 和 <strong>rvalue</strong> 上，其目的是为了避免某些不必要的开销，而不是依赖 <strong>编译器优化</strong> 这种虚无飘渺的说法。</p>
<pre><code><span class="keyword">class</span> Widget {
<span class="keyword">public</span>:
  <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;
  ...
DataType&amp; data() &amp; { <span class="keyword">return</span> values; }
<span class="function">DataType  <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::move(values); }
...

<span class="keyword">private</span>:
  DataType values;
};
</code></pre><p> 可以很明显的看出，两个版本的<code>data</code>函数，是为了适应不同情况下对于 <code>values</code>的使用。</p>
</li>
</ul>
<h3 id="Item_13_Prefer_const_iterators_to_iterators">Item 13 Prefer const_iterators to iterators</h3><ul>
<li>很简短，尽量去使用 <code>const_iterator</code>，原因就是安全。</li>
<li><p><strong>C++11</strong> 提供了十分简便(还不够完善)的获取上限</p>
<ol>
<li>容器中自带的 <code>begin(), end()</code> 和 <code>cbegin(), cend()</code> ……</li>
<li>非容器自带(非成员函数) <code>std::begin&lt;...&gt;(), std::end&lt;...&gt;()</code></li>
<li>在 <strong>C++14</strong> 中补全了对 <strong>1</strong> 的非容器实现</li>
</ol>
</li>
<li><p>更加建议使用 非容器的版本。</p>
</li>
</ul>
<h3 id="Item_14_Declare_functions_noexcept_if_they_won’t_emit_exceptions">Item 14 Declare functions noexcept if they won’t emit exceptions</h3><ul>
<li><code>noexcept</code> 是 <strong>C++11</strong> 新的标准语法</li>
<li><code>noexcept</code> 的意义就是，告诉编译器这个函数绝对不会抛出异常。</li>
<li>让一个函数成为 <code>noexcept</code> 会让编译器对它做<strong>极大的优化</strong>，但是这并不是建议你尽量的使用<code>noexcept</code>，你必须谨慎再谨慎的使用它</li>
<li>实际上，<code>noexcept</code> 对于 <strong>移动语义</strong>，<strong>swap函数</strong>，<strong>delete</strong>，和 <strong>析构函数</strong>十分有意义，后两者一般情况下要是<code>noexcept</code>。</li>
<li>但事实上，大部分函数是 <strong>“中立的”</strong>，也就是不清楚是否会抛出异常<ul>
<li>因为有时候写一个函数时，会调用其他函数，这个被调用的函数是否会抛出异常，往往无从得知。</li>
</ul>
</li>
<li><p><code>noexcept</code>是作为函数接口的一部分 <code>int f(int x) noexcept;</code></p>
<ul>
<li>在<strong>C++98</strong>时代，有一种同样意义(效果不同)的写法 <code>int f(int x) throw();</code> </li>
</ul>
</li>
<li><p>首先，是对于<strong>移动语义</strong>和<code>swap</code>函数而言，<code>noexcept</code>意义非凡</p>
<ul>
<li>移动语义也就是<strong>C++11</strong>新的特性，右值引用的意义所在，众所周知它可能会带来极大的性能提升，例如在拷贝一组不小的数据时。</li>
<li>但问题就在于<strong>“拷贝”</strong>这组数据时(实际上应该说是移动它们)，假如在移动的过程中突然发生异常那该如何？因为是移动，而不是拷贝，<strong>所以之前移动的那部分数据就算是丢失了！</strong></li>
<li>相比较而言，拷贝的做法就较为妥当，因为不管会不会在拷贝过程中发生异常，原始数据始终是不会丢失的。</li>
<li>所以我们必须确保 <strong>移动操作</strong> 是 <code>noexcept</code>，这样它才能在必要时对<strong>拷贝构造函数</strong>进行替换，以此来达到提升性能的作用。</li>
<li>例如对一个容器(<code>std::vector</code>)进行<code>push_back</code>操作，编译器除非能确定操作对象的<strong>移动操作</strong>是<code>noexcept</code>的，否则是不会<strong>默默(隐式)</strong> 地将<strong>拷贝换成移动</strong>。</li>
</ul>
</li>
<li><p>其次 <code>swap</code> 函数也是如此</p>
<pre><code>// 只有当swap数组中的元素是noexcept，这个函数才是noexcept
<span class="keyword">template</span> &lt;class T, size_t N&gt;
<span class="type">void</span> swap(T (&amp;a)[N]),
          T (@b)[N])noexcept(noexcept(swap(*a, *b)));

//只有当对pair内部元素进行swap是noexcept时，对pair进行swap才是noexcept
<span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span>&gt;
struct pair {
    ...
    <span class="type">void</span> swap(pair&amp; p)noexcept(noexcept(swap(first, p.first)) &amp;&amp;
                                  noexcept(swap(second, p.second)));
};
</code></pre><p>  这段代码出自 <strong>标准库</strong>，这种语法的意思就是，只有当<code>noexcept</code>括号内的是<code>noexcept</code>时，才是<code>noexcept</code>，绕口却好理解。</p>
<p>  总结起来就是，对高级封装的数据结构进行操作的<code>swap</code>函数是否是<code>noexcept</code>，取决于这个高级封装的数据结构内部的成员是否对于<code>swap</code>操作是<code>noexcept</code>(并且是对于每一成员都必须成立)</p>
</li>
<li><p>如果硬是把一个不确定的函数，设定为<code>except</code>，那是在是有些本末倒置，但对于<strong>移动语义</strong>和<code>swap</code>函数而言，却是一个很有意义的做法。</p>
</li>
<li>总之本节最主要的目的就是，当我们十分确定某个函数一定不会抛出异常，那就让它成为<code>noexcept</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-概述（二）.html" data-id="cikxfh92n001gmwltasrlgtt2" class="article-share-link" data-share="baidu" data-title="Effective Modern Cpp 概述（二）">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/">Cpp</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/12/15/Effective-Modern-Cpp-概述（一）.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Effective Modern C++概述（一）</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/">Cpp</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Opencv/">Opencv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂货居/">杂货居</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站/">网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C</a><a href="/tags/Cpp/" style="font-size: 20px;">Cpp</a><a href="/tags/Linux/" style="font-size: 10px;">Linux</a><a href="/tags/Opencv/" style="font-size: 10px;">Opencv</a><a href="/tags/Python/" style="font-size: 13.33px;">Python</a><a href="/tags/Qt/" style="font-size: 13.33px;">Qt</a><a href="/tags/杂货居/" style="font-size: 20px;">杂货居</a><a href="/tags/网站/" style="font-size: 10px;">网站</a><a href="/tags/网络编程/" style="font-size: 13.33px;">网络编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/22/Effective-Modern-Cpp-概述（二）.html">Effective Modern Cpp 概述（二）</a>
          </li>
        
          <li>
            <a href="/2015/12/15/Effective-Modern-Cpp-概述（一）.html">Effective Modern C++概述（一）</a>
          </li>
        
          <li>
            <a href="/2015/12/04/现代TCP-IP网络编程-UDP.html">现代TCP/IP网络编程-UDP</a>
          </li>
        
          <li>
            <a href="/2015/10/30/现代TCP-IP网络编程-启航.html">现代TCP/IP网络编程-启航</a>
          </li>
        
          <li>
            <a href="/2015/09/20/Linux记录.html">Linux记录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 吴生鑫<br>
      
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
