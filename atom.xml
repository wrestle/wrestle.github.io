<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[WuShXin's fox]]></title>
  <subtitle><![CDATA[狐狸永远是我的]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.wushxin.top//"/>
  <updated>2016-08-16T01:47:49.227Z</updated>
  <id>http://www.wushxin.top//</id>
  
  <author>
    <name><![CDATA[吴生鑫]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用Vim]]></title>
    <link href="http://www.wushxin.top/2016/08/15/%E4%BD%BF%E7%94%A8Vim.html"/>
    <id>http://www.wushxin.top/2016/08/15/使用Vim.html</id>
    <published>2016-08-15T06:35:40.000Z</published>
    <updated>2016-08-16T01:47:49.227Z</updated>
    <content type="html"><![CDATA[<h3 id="开始Vim">开始Vim</h3><ol>
<li>使用编辑器，最主要的目的就是编辑，即使你不愿意使用Vim这类终端编辑器，也会在某时候不得不靠他勉强编辑一些东西，例如中国人Geek们最起码都干过的改<strong>Linux Source list</strong>。</li>
<li>所以无论你是情愿还是不情愿，当你执行这行命令 <code>vim filename</code> 之后，就算是进入了一个有意思，但又不怎么听话的界面，所以书上学来终是浅，实践才是最重要的。</li>
<li>首先在家目录 <code>cd ~</code> 下创建或打开 <code>.vimrc</code> 这个文件，直接执行 <code>vim .vimrc</code>这个命令即可，无论有这个文件还是，没有这个文件都能够正确达到目的。</li>
<li><p>进入<code>.vimrc</code>文件之后，在其中追加以下内容(追加就是摁键盘上的<code>i</code>，光标移动暂时用<strong>方向键</strong>):</p>
<pre><code><span class="keyword">syntax</span> <span class="keyword">on</span>
<span class="keyword">set</span> number
<span class="keyword">set</span> cindent
<span class="keyword">set</span> autoindent
<span class="keyword">set</span> smartindent
<span class="keyword">set</span> ruler
<span class="keyword">set</span> backspace=indent,eol,start
<span class="keyword">set</span> tabstop=4
<span class="keyword">set</span> shiftwidth=4
<span class="keyword">set</span> encoding=utf-8
<span class="keyword">set</span> termencoding=utf-8
<span class="keyword">set</span> fileencodings=utf-8,gbk
<span class="keyword">set</span> hls
<span class="keyword">set</span> laststatus=2
<span class="keyword">set</span> <span class="keyword">list</span>
<span class="keyword">set</span> incsearch
<span class="keyword">set</span> showmatch
<span class="keyword">set</span> statusline=[%F]%y%r%<span class="keyword">m</span>%*%=[<span class="keyword">Line</span>:%<span class="keyword">l</span>/%<span class="keyword">L</span>,Column:%c][%p%%]
<span class="keyword">set</span> listchars=<span class="keyword">tab</span>:&gt;-,trail:-
</code></pre><p>有这些功能开启就够了，也不需要有其他的第三方插件，也不需要再多了，就这样足矣。所以请简单使用<code>Vim</code></p>
</li>
</ol>
<blockquote>
<p>先不要问这些命令的意义所在，轻松一点，书读百遍其意自现，工具也一样，一开始这些规矩根本没必要记住，用久了自然就懂了。<br><a id="more"></a></p>
</blockquote>
<ol>
<li>追加完以后，接下来执行一个连贯的操作:<ol>
<li><code>Shift + ;</code> 也就是冒号<code>:</code></li>
<li>输入<code>wq</code></li>
<li>回车</li>
</ol>
</li>
</ol>
<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/wq.png" alt=""></li>
</ul>
<ol>
<li>成了！接下来就能开心的进入<code>Vim</code>状态了。</li>
</ol>
<h4 id="直接进阶">直接进阶</h4><ol>
<li>对于编辑器这种东西，我们自然是图个方便快速，不然干嘛不用<strong>IDE</strong>, (没X-Windows的别打我)</li>
<li><p>所以编辑室第一要义:</p>
<ol>
<li>记住，<code>i</code>(看好了是，小写的)就是在你光标那里进行插入，别管在光标前插入还是光标后插入，你的方向键还在那里呐！移动啊！(<strong>hjkl党</strong>放过我)</li>
<li><code>Esc</code>键就是进入<strong>上帝模式</strong>，也就是99%的 <strong>vim</strong> 功能所在的模式里，唯一不在其中的就是你刚刚退出的<strong>插入模式</strong></li>
<li>回顾一下，可以输入内容的模式叫做 <strong>插入模式</strong>，在上帝模式中摁<code>i</code>进入，想要返回上帝模式，那就是嗯<code>Esc</code>，在你键盘的左上角。</li>
</ol>
</li>
<li><p>一般在用编辑器的时候，我们希望的是翻页功能，如果只能一行一行的往下，虽然速度也马马虎虎，但是终究有人不习惯</p>
<ol>
<li>很简单</li>
<li><code>Ctrl + f</code> 向前翻页</li>
<li><code>Ctrl + b</code> 向后翻页</li>
<li>有一点歧义，更明白一点的说就是，向前翻页(往文章头部走)，向后翻页(往文章尾部走)，自己实践一下前面说的这几个操作。</li>
</ol>
</li>
</ol>
<blockquote>
<p>快速回到顶部是什么命令呢？ 在上帝模式下连续摁两次 <code>[</code> 就行了，猜一下回到底部是什么？</p>
</blockquote>
<ol>
<li><p>有了插入编辑和翻页，我们已经能满足一般的小需求了，例如看文件内容，稍微修改一点地方。</p>
<ol>
<li>但是如果我想快速修改某个地方呢？</li>
<li>我事先知道那个地方的关键字</li>
<li>我事先知道在哪一行</li>
<li>我看到光标附近的某个关键字，想要快速定位到其他地方的这个关键字处</li>
</ol>
</li>
<li><p>针对上面的三种情况，一一解答</p>
<ol>
<li>我事先知道那个地方的关键字<ul>
<li>顾名思义，就是搜索呗：<ol>
<li>在<strong>上帝模式</strong>下 <code>Shift + ;</code></li>
<li>输入 <code>/</code> 斜杠</li>
<li>再输入你要查找的关键字信息，例如你想要查找 <code>xenial</code> 这个关键字，那最后在下方的命令栏内会看到这些字符 <code>:/xenial</code><ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/search-1.png" alt=""></li>
</ul>
</li>
<li>这时候你摁回车，你会发现，你搜索的关键字都亮起来了，这时候你完成了目标的一大半。<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/search-2.png" alt=""></li>
</ul>
</li>
<li>为什么说一大半，请问你现在要怎么移动到那些高亮起来的地方，<strong>方向键移动</strong>？太智障了吧。</li>
<li>一个字母就能实现快速跳转: <code>n</code>，这里的字母<code>n</code>，小写时候向后跳至下一个高亮处，大写的时候就是向前跳，支持循环跳转，也就是说即使你只记得一个方向跳转，最后也能到达你的目的地。</li>
<li>这一套组合有些长，自己最好实验三次，如果是纯看的客官，你现在就可以保存一下本页面，去干别的了，因为你不自己动手，是绝对记不住的。前面说的知识点，刚好到达人类短时记忆的顶峰。</li>
</ol>
</li>
</ul>
</li>
<li>我事先知道在哪一行<ul>
<li>那很简单啊，就是一个命令而已</li>
<li>在上帝模式下，键盘摁 <code>numbergg</code></li>
<li>什么意思？就是<code>number</code>就是你要去的行数，<code>gg</code>就是连续摁两下键盘上的小写<code>g</code></li>
<li>假设你要快速<strong>跳转到第231行</strong>，进入上帝模式后，在键盘上摁 <code>231gg</code>，行了。就是这么简单。</li>
</ul>
</li>
<li>我看到光标附近的某个关键字，想要快速定位到其他地方的这个关键字处<ul>
<li>这个也很简单，也是一个命令而已</li>
<li>在上帝模式下，确保光标移动到那个关键词语上面(上面这个词后面解释)，键盘摁 <code>gd</code> 就行了<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/gd跳转.png" alt=""></li>
</ul>
</li>
<li>你发现，你要查的这个关键字都亮了起来，怎么跳转就不用再说一次了吧。</li>
<li>这个功能简直就是神器。想想函数跳转</li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>上面这个词就是，只要是这个单词里面都可以，例如 hello 这个单词，你光标只要停在 <code>h</code> 到 <code>o</code> 之间的任意一个单词都行，闭区间。</p>
</blockquote>
<ol>
<li>上面说了哪些命令，来回顾一下:<ul>
<li><strong>插入</strong><code>i</code>和<strong>退出保存</strong><code>:wq</code></li>
<li><strong>移动</strong>： 方向键</li>
<li><strong>向前翻页</strong>: <code>Ctrl+f</code>, <strong>向后翻页</strong>: <code>Ctrl+b</code></li>
<li><strong>搜索</strong>: <code>:/search-key</code></li>
<li><strong>跳转指定行</strong>: <code>numbergg</code></li>
<li><strong>快速检索某关键字</strong>: <code>gd</code> </li>
<li><strong>有高亮状态时向后跳转</strong>: <code>n</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>所以实际上<code>gg</code>的作用就是跳转，那有没有想过，不加数字直接使用<code>gg</code>是什么效果？猜猜看就能知道一定是跳转的意思。再换大写的<code>GG</code>试试啊。很有意思的</p>
<p>额外补充一个，也是用来快速检索某关键字的，<code>#</code>，用法一样。记不记都无所谓了。</p>
<p>有了这些操作，看一个文件的内容简直就是飞一样，如果你只需要看，少量或者不需要改，那么你根本不用往下看了，这些就足矣。</p>
</blockquote>
<h4 id="进阶之后">进阶之后</h4><ol>
<li>回想一下在其他图形编辑器里面，最经常干什么？</li>
<li>前面我们漏讲了好多最常用的操作，<strong>编辑操作</strong><ul>
<li>所谓，<strong>增删改查</strong>，我们只讲了<strong>查</strong></li>
</ul>
</li>
</ol>
<h4 id="增删改">增删改</h4><ol>
<li><p>增加可以分为，<strong>字符插入</strong>和<strong>粘贴</strong></p>
<ul>
<li>插入就是前方说的<code>i</code>，后面会讲一个写程序时候很方便的调试方法，和插入有关。</li>
<li>粘贴就比较有意思，也比较有用了，说到粘贴就不得不说<strong>剪切</strong>了</li>
<li>剪切有多个方法<code>dd</code>, 和<code>cc</code>都行，当然我说的都是在<strong>上帝模式</strong>下进行的操作。</li>
<li>上面说的就是剪切当前行。</li>
<li>和剪切类似的就是复制了<code>yy</code>，代表复制当前行。</li>
<li>那么黏贴是什么，记住这些命令都必须是在上帝模式下使用，黏贴是<code>p</code></li>
<li>现在你会了快速<strong>剪切/复制</strong>某一行，并黏贴。</li>
</ul>
</li>
<li><p>说完增加，要说说删除了</p>
<ul>
<li>很简单，在上帝模式下用<code>x</code>就行了，有人说直接进编辑模式不就行了</li>
<li>当然可以啊，你愿意的话，怎么方便怎么来，<code>x</code>的左右就是删除当前光标的字符。一直摁住就是一直删除。</li>
<li>还有一个<strong>误区</strong>，很多网上的教程说<code>dd</code>是删除，实际上并不是，这是剪切的效果，如果你之前有复制的效果，就被他覆盖了。</li>
<li>当然你也可以用<code>dd</code>或者<code>cc</code>代替删除。</li>
</ul>
</li>
<li><p>改，就是替换，这里用一个很经典的例子来说</p>
<ol>
<li>如何替换这个文本内的<code>Tab</code>键</li>
<li>因为有时候有的地方的<code>Tab</code>是四个空格，有的不是，我们想统一一下怎么办</li>
<li><code>:%s/Ctrl+v + Tab/你想替换成什么/g</code></li>
<li>解释一下中间那段<code>Ctrl+v + Tab</code>，也就是先摁组合键<code>Ctrl+v</code>，再摁<code>Tab</code>键，你会发现命令栏变成了<code>^I</code>，那就对了。</li>
<li>最后的完整样子<code>:/%s/^I/    /g</code>，代表我想把<code>Tab</code>键都替换成四个空格。(<strong>为了显示效果，我替换成四个@</strong>)<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/replace-1.png" alt=""></li>
<li><img src="http://o8taitpxn.bkt.clouddn.com/replace-2.png" alt=""></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="高级用法">高级用法</h3><ol>
<li><p>搜索某个关键字</p>
<ul>
<li>假设文件中有一个字符串<code>hello-arntity-is-so-long-in-word</code>,我想查询<code>-arntity-is-so-long</code>, 怎么办？我不想一个字母一个字符输入命令栏啊</li>
<li>这时候就用到了复制功能，和前面的快速复制某行不同，这回是精确复制某些。</li>
<li>在上帝模式下，移动光标到你要选择的词语开头，摁小写的<code>v</code>，移动方向键选择一直到末尾，摁<code>y</code>，这样就将这些文字复制下来了。</li>
<li>你现在可以用<code>p</code>试试是不是复制成功了。</li>
<li>接下来<code>:/Ctrl+r&quot;</code> 回车即可</li>
<li>解释一下： 进去命令栏，先输入一个斜杠<code>/</code>，代表搜索的意思，再摁<code>Ctrl+r</code>，后接一个<strong>引号</strong><code>&quot;</code>，也就是<code>Shift + &#39;</code>。你会发现命令栏出现了你复制的东西。</li>
</ul>
</li>
<li><p>快速注释某些行</p>
<ul>
<li>需要用到一种叫做<strong>块选择</strong>的东西，不想懂也行，记住操作</li>
<li>首先找到你要注释的那些行，嗯<code>Ctrl+v</code>进入某个模式，向下选择你需要的行，这时候选择出来的像是一列小方块，这就是正确的。<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/快选择-1.png" alt=""></li>
</ul>
</li>
<li>选择好一个，摁大写的<code>I</code>，在输入你的注释符号，例如<code>C++</code>是两个斜杠<code>//</code></li>
<li>输完之后，连摁两下<code>Esc</code>，成啦！<ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/快选择-2.png" alt=""></li>
</ul>
</li>
<li>想要取消注释怎么办？</li>
<li>自己想想，提示： 块选择之后，用<code>x</code><ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/块选择-3.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>撤销操作</p>
<ol>
<li>就是在上帝模式下摁小写的<code>u</code>就行了。</li>
</ol>
</li>
<li><p>自动补全</p>
<ol>
<li>不必去依赖那些第三方库，是真的安装的很头疼</li>
<li>自带一个<code>Ctrl+n</code>的补全功能，已经能够满足编程的需求了，别太依赖IDE啊。</li>
</ol>
</li>
<li><p>剪切从当前光标到该行末尾</p>
<ol>
<li>这个也是使用的很频繁的一个操作</li>
<li>操作很简单，就是大写的<code>D</code>，随后使用<code>p</code>进行粘贴。</li>
</ol>
</li>
</ol>
<h3 id="分屏">分屏</h3><ol>
<li>实际上不太想记录，因为这个可以由<code>tmux</code>来做，但是还是说一下，有的时候挺方便</li>
<li><code>split</code>和<code>vsplit</code>是分屏的命令，前者是上下分屏，后者是左右分屏</li>
<li>使用方法是： <code>split filename</code></li>
<li>使用<code>Ctrl + w</code> 在窗口间进行切换</li>
</ol>
<h3 id="结束语">结束语</h3><ul>
<li><p>熟练了上述操作，基本上能很好的应对各种需求了，基本需求指的是编程写代码，修改配置文件等。</p>
</li>
<li><p>转载请注明出处 <a href="http://www.wushxin.top/2016/08/15/%E4%BD%BF%E7%94%A8Vim.html" target="_blank" rel="external">http://www.wushxin.top/2016/08/15/使用Vim.html</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="开始Vim">开始Vim</h3><ol>
<li>使用编辑器，最主要的目的就是编辑，即使你不愿意使用Vim这类终端编辑器，也会在某时候不得不靠他勉强编辑一些东西，例如中国人Geek们最起码都干过的改<strong>Linux Source list</strong>。</li>
<li>所以无论你是情愿还是不情愿，当你执行这行命令 <code>vim filename</code> 之后，就算是进入了一个有意思，但又不怎么听话的界面，所以书上学来终是浅，实践才是最重要的。</li>
<li>首先在家目录 <code>cd ~</code> 下创建或打开 <code>.vimrc</code> 这个文件，直接执行 <code>vim .vimrc</code>这个命令即可，无论有这个文件还是，没有这个文件都能够正确达到目的。</li>
<li><p>进入<code>.vimrc</code>文件之后，在其中追加以下内容(追加就是摁键盘上的<code>i</code>，光标移动暂时用<strong>方向键</strong>):</p>
<pre><code><span class="keyword">syntax</span> <span class="keyword">on</span>
<span class="keyword">set</span> number
<span class="keyword">set</span> cindent
<span class="keyword">set</span> autoindent
<span class="keyword">set</span> smartindent
<span class="keyword">set</span> ruler
<span class="keyword">set</span> backspace=indent,eol,start
<span class="keyword">set</span> tabstop=4
<span class="keyword">set</span> shiftwidth=4
<span class="keyword">set</span> encoding=utf-8
<span class="keyword">set</span> termencoding=utf-8
<span class="keyword">set</span> fileencodings=utf-8,gbk
<span class="keyword">set</span> hls
<span class="keyword">set</span> laststatus=2
<span class="keyword">set</span> <span class="keyword">list</span>
<span class="keyword">set</span> incsearch
<span class="keyword">set</span> showmatch
<span class="keyword">set</span> statusline=[%F]%y%r%<span class="keyword">m</span>%*%=[<span class="keyword">Line</span>:%<span class="keyword">l</span>/%<span class="keyword">L</span>,Column:%c][%p%%]
<span class="keyword">set</span> listchars=<span class="keyword">tab</span>:&gt;-,trail:-
</code></pre><p>有这些功能开启就够了，也不需要有其他的第三方插件，也不需要再多了，就这样足矣。所以请简单使用<code>Vim</code></p>
</li>
</ol>
<blockquote>
<p>先不要问这些命令的意义所在，轻松一点，书读百遍其意自现，工具也一样，一开始这些规矩根本没必要记住，用久了自然就懂了。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.wushxin.top/tags/Linux/"/>
    
      <category term="vim" scheme="http://www.wushxin.top/tags/vim/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[后台开发之架构]]></title>
    <link href="http://www.wushxin.top/2016/07/29/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B9%8B%E6%9E%B6%E6%9E%84.html"/>
    <id>http://www.wushxin.top/2016/07/29/后台开发之架构.html</id>
    <published>2016-07-29T09:11:21.000Z</published>
    <updated>2016-08-03T06:25:11.144Z</updated>
    <content type="html"><![CDATA[<h3 id="实习">实习</h3><ul>
<li>近期在某家公司实习，顺应公司部门文化有一场为期十天左右的实习生小组赛，内容就像<strong>黑客马拉松</strong>一样。</li>
<li>正好在此小组负起后台开发的职责，技术选择是 Python 的 Web框架 <strong>Flask</strong>， 至于本文想要记录的并不是 <code>flask</code>这个框架怎么用，好不好用，而是其他一些一直以来比较零散的知识</li>
<li>也许这是在学校中开发所注意不到的，那就是实际情况总是与理想状态相去甚远。</li>
</ul>
<h3 id="架构图">架构图</h3><ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/empty.png" alt=""></li>
<li>这个结构是我为本小组提供的后台拓扑，包含三个部分：<ol>
<li><strong>Nginx</strong>反向代理</li>
<li><strong>Flask</strong>逻辑服务器</li>
<li><strong>MySQL</strong>数据库服务器</li>
</ol>
</li>
<li>看起来非常朴实，实际上门门道道，细节问题着实费了我两天时间，特别是在逻辑服务器哪里，因为粗心大意，愣是搭了一个晚上还是失败。</li>
<li>本次是将终端和前端的接口进行了统一，实际上这样对一个快速开发项目来说的确是必须的，不必考虑太多细节，追求的是效率，毕竟<strong>Flask</strong>框架追求的的确就是开发效率，至于并发情况实际上在众多框架中，并不能算太好。<a id="more"></a>
<h3 id="开始记录">开始记录</h3></li>
</ul>
<h4 id="Nginx反向代理">Nginx反向代理</h4><ul>
<li>这个的应用应该是非常广泛的，而且十分有效</li>
<li>立竿见影的效果就是屏蔽了后端的大部分细节，提高了容错性，以及其本身就是一个超高性能的静态资源服务器，更是能够帮助很多应用提升性能。</li>
<li>在Linux下安装 Nginx 就像明面上说的那么简单，但是一般主流的发行版中的 Nginx 的版本都<strong>比较低</strong>，所以可能有时候用起来不如传闻中的那么神速。<ul>
<li>于此你可以选择接受它</li>
<li>或者去官方网下载最新的稳定版本，按照步骤一步一步的安装。</li>
</ul>
</li>
<li>在这里就不再详述，这要是详细记录，又是一个独立的话题了。</li>
<li><strong>Nginx</strong>在Ubuntu下，默认配置文件放在了 <ul>
<li><code>/etc/nginx/nginx.conf</code> 以及 <code>/etc/nginx/site-available/default</code> 中</li>
<li>一般情况下，我们修改后者就行，改前记得先备份</li>
</ul>
</li>
<li><strong>Nginx</strong>有自己的URL一套匹配规则，通俗的来说就是将一个完整的链接解析成服务器知道的绝对路径</li>
</ul>
<blockquote>
<p>例如: <a href="http://www.domain.com/index.html" target="_blank" rel="external">http://www.domain.com/index.html</a> 解析成服务器上的 /var/www/html/index.html 路径</p>
</blockquote>
<ul>
<li><p>这个匹配规则，也是可以单独写成一个话题，那么直接看本次配置的时候遇到的一个问题：除了几种特殊情况意外，其他路径都返回 <code>index.html</code> 这个文件，该如何做到？</p>
<pre><code><span class="title">server</span> {
    <span class="title">listen</span>  <span class="number">8080</span>;
    <span class="title">server_name</span> xxx.xxx.xxx.xxx; <span class="comment">#公网地址</span>

    <span class="title">location</span> /api/ {
        <span class="title">include</span>      uwsgi_params;
        <span class="title">uwsgi_pass</span>   <span class="number">127.0.0.1:7001</span>;  <span class="comment"># 指向uwsgi 所应用的内部地址,所有请    求将转发给uwsgi 处理</span>
        <span class="title">uwsgi_param</span> UWSGI_CHDIR  /data/mini/www; <span class="comment"># 指向网站根目录</span>
        <span class="title">uwsgi_param</span> UWSGI_SCRIPT manage:app; <span class="comment"># 指定启动程序</span>
    }
    <span class="title">location</span> <span class="regexp">~ ^/(js|css)/</span>{
        <span class="title">root</span> /data/mini/source/Mini_Production/build;
    }

    <span class="title">location</span> <span class="regexp">~ ^/(img|lib)/</span>{
        <span class="title">root</span> /data/mini/source/Mini_Production/static;
    }    
    <span class="title">location</span> / {
        <span class="title">root</span> /data/mini/source/Mini_Production/;
        <span class="title">index</span> index.html;
        <span class="title">try_files</span> <span class="variable">$uri</span> /index.html;
    }
}
</code></pre><p>  重点在于最后一个<code>location</code>解决了我的问题</p>
<p>  至于其他的规则，网上详细叙述的太多了，这里只是记录一个特殊情况。</p>
</li>
<li><p>说完这个就该来说说，反向代理的简单配置了</p>
<ul>
<li>说是简单配置，因为将会使用<strong>Nginx</strong>自带的功能，而不引入第三方模块的功能</li>
<li>由于服务的需求，我们的应用需要保存<code>session</code>，所以<strong>Nginx</strong>反向代理的时候必须要保证的一个地方就是：同一个<strong>IP</strong>必须反向代理到同一个服务器上，否则会导致某些意想不到的错误。</li>
<li>而Nginx自带的两个策略之一<strong>ip_hash</strong>正为此而生。</li>
</ul>
</li>
<li><p>反向代理的配置分为两个块，<code>upstream</code> 和 <code>server</code></p>
<ul>
<li><p>直接写在<code>/etc/nginx/nginx.conf</code>里就行</p>
<pre><code>upstream yuehuo{
ip_hash;
    <span class="keyword">server</span>  xxx.xxx.xxx.xx1:<span class="number">8080</span>;
    <span class="keyword">server</span>  xxx.xxx.xxx.xx2:<span class="number">8080</span>;
    ...
}

<span class="keyword">server</span> {
    listen <span class="number">9090</span>;
    location / {
        proxy_pass http:<span class="comment">//yuehuo;</span>
        proxy_set_header X-Real-IP $remote_addr;
    }
}
</code></pre><p>有几台在<code>upstream</code>写几个<code>server</code>,以分号结尾，这样一来就实现了一个最简单的反向代理，对于晓得项目而言其实是已经足够了。</p>
<p>不用怀疑什么，<strong>Nginx</strong>是一个很成熟的开源项目，不像某些开源产品只是一副外壳而已。</p>
</li>
</ul>
</li>
<li>实际上，着一些就构成了我们小组后台结构的第一部分，也就是理论上暴露给外部的访问点，就是这台独自承载着<strong>Nginx</strong>反向代理功能的服务器。</li>
<li>任何有效访问只需要访问这台服务器，就能得到他们想要的东西，而不需要去记下多台服务器的域名或者IP。</li>
<li>而我也可以随时替换后端的服务器，并且服务的请求者什么也不会察觉。</li>
<li>甚至还可以配置一个<code>backup</code>，在所有服务器都崩溃的时候，它能挽救一下局面。所谓的最初级的容灾。</li>
</ul>
<h4 id="Flask逻辑服务器">Flask逻辑服务器</h4><ul>
<li>在这个部分，实际上是用的是<strong>Nginx + Supervisor + uwsgi + Flask</strong> 进行的搭建</li>
<li>看起来很复杂，很多组建，实际上也就这样：<ul>
<li>Nginx用来引导所有请求至正确的位置：动态请求转发给 <strong>Flask</strong>，静态资源自己处理就行。</li>
<li><code>uwsgi</code>则是<code>Flask</code>运行的一个平台，不在叙述，可以将两者看成一体，实际上从上面的<strong>Nginx</strong>配置文件中也能发现一些端倪。</li>
<li>其实这样已经能够很好完整的服务各方了，那为什么还有一个<code>Supervisor</code>呢？就是为了让这个服务更加规范和自动化，这相当于一个自动化可配置的 <code>uwsgi</code> 启动器(写过<code>ruby on rails</code>的应该也很熟悉这个东西)。</li>
</ul>
</li>
<li><strong>Nginx</strong>的配置就如上所示，在<code>etc/nginx/sites-available/default</code>里写入上一个模块介绍的内容</li>
<li>安装完<code>Supervisor</code>和<code>uwsgi</code>之后，将<code>uwsgi</code>的配置文件存放好，比如放在<code>flask</code>程序的结构包里，总之记好路径，在之后的<code>Supervisor</code>中会用到，之后写好它的配置文件之后，启动它的服务就行。</li>
<li>讲的有点泛泛但是却没什么难点，细心一些就能配置对，当然是找到网上的配置教程。</li>
<li>从前端上传的图片，被存放在了<code>Flask</code>逻辑服务器上，但是这导致一个缺点，就是如何同步多台逻辑服务器之间的图片资源？<ul>
<li>虽然图片是静态资源的一种，但是它具有动态更新的可能性，所以解决方案可以有两种：多台服务器同步或者单独存放在一个独立的图片服务器上。</li>
<li>前者的缺点很明显，这是当前技术领域最难的分布式同步问题。后者相对容易而且能带来很不错的性能，可以选择专业的图片存储服务商，或者自己搭建。</li>
<li>当前架构还算小规模，暂时使用<code>scp</code>定时拷贝的策略来同步。</li>
</ul>
</li>
</ul>
<blockquote>
<p>总体来说，Flask 服务器被配置成 Nginx -&gt; supervisor(uwsgi -&gt; flask) 的模式</p>
</blockquote>
<ul>
<li><a href="http://jinke.me/2015/12/09/flask-linux.html" target="_blank" rel="external">马马虎虎可以的配置教程</a></li>
</ul>
<h4 id="数据库分离_之_数据库服务器与读写分离">数据库分离 之 数据库服务器与读写分离</h4><ul>
<li>这个部分是耗时比较久的</li>
<li>首先问题描述：<ul>
<li>如果数据库内嵌在<code>flask Server</code>中，万一某台<code>Flask Server</code>宕机，同时也会损失一台数据库服务。</li>
<li>多台<code>flask Server</code>中内嵌的数据库之间的数据该如何做同步？</li>
<li><code>Flask Server</code>服务器是否过于臃肿</li>
</ul>
</li>
<li>综上问题，我们相出将数据库从<code>Flask Server</code> 提出来，以分布式的方式实现</li>
<li>首先需要对<code>Flask Server</code>做一下数据库系统的透明处理，意思就是让无论多少台<code>Flask Server</code>都只感觉在操作同一个数据库。<ul>
<li>首先想到数据库中间件<code>MySQL-Proxy</code>，做一个读写分离</li>
<li>配置主从数据库，以此实现容灾以及性能提升。</li>
</ul>
</li>
<li>首先将数据库放在单独的服务器中，配置成 <strong>一主多从</strong> 的的模式，即<strong>一写多读</strong>，其中<strong>主服务器可读可写</strong><ul>
<li>这个可以实现的是，当主数据库被写的时候，可以同步更新到从服务器上。</li>
<li>这么做的目的就是将读的性能大大提升。</li>
</ul>
</li>
<li>其次对前方屏蔽数据库系统的细节，即增加中间件的存在<ul>
<li>将之前实现的数据库系统，接在<code>MySQL-Proxy</code>的后方，让其帮助我们实现读写分离的功能。</li>
</ul>
</li>
</ul>
<blockquote>
<p>也可以实现<strong>多主多从</strong>的效果，远离和一主多从十分类似，就是将两台 主数据库，互相配置成主从。并在主服务器的MySQL配置的<code>[mysqld]</code>选项中增加<code>log_slave_update</code>标志</p>
</blockquote>
<ul>
<li>两篇好教程：<ol>
<li><a href="http://blog.jobbole.com/94595/" target="_blank" rel="external">MySQL数据库主从配置</a></li>
<li><a href="http://blog.jobbole.com/94606/" target="_blank" rel="external">MySQL-Proxy配置读写分离</a></li>
</ol>
</li>
<li><p>实现上的细节</p>
<ol>
<li>当<code>slave</code>出现：<code>Connecting to master</code> 且错误码为 <code>2003</code>的时候，你需要看看你的<code>MySQL</code>配置中是否有<code>bind-address = 127.0.0.1</code>这个选项，注释掉它</li>
<li><img src="http://o8taitpxn.bkt.clouddn.com/bind-address-problem.png" alt=""></li>
<li>配置完以后，你会发现状态变了，这样才算成功。</li>
</ol>
</li>
<li><p>万年不变的<code>MySQL</code>中文问题</p>
<ul>
<li>在所有方法都查证之后，四方编码都为 <strong>UTF-8</strong>时，却发现还是不行</li>
<li>这时候，可以尝试将整个数据库<code>Drop</code>，之后重建。这样会使刚才的配置生效在这个数据库上</li>
<li>其实数据库可以不必<code>DROP</code>，只需要将表删了重建即可。</li>
</ul>
</li>
</ul>
<h4 id="反思">反思</h4><ul>
<li>一个最大的问题就是，如果数据已经多到一个<code>DB</code>存不下，不得不用多数据库来存储的时候，该怎么办？</li>
<li>这个是我们这个架构最致命的缺点。<ul>
<li>如果有更好的解决方案，我再记录</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实习">实习</h3><ul>
<li>近期在某家公司实习，顺应公司部门文化有一场为期十天左右的实习生小组赛，内容就像<strong>黑客马拉松</strong>一样。</li>
<li>正好在此小组负起后台开发的职责，技术选择是 Python 的 Web框架 <strong>Flask</strong>， 至于本文想要记录的并不是 <code>flask</code>这个框架怎么用，好不好用，而是其他一些一直以来比较零散的知识</li>
<li>也许这是在学校中开发所注意不到的，那就是实际情况总是与理想状态相去甚远。</li>
</ul>
<h3 id="架构图">架构图</h3><ul>
<li><img src="http://o8taitpxn.bkt.clouddn.com/empty.png" alt=""></li>
<li>这个结构是我为本小组提供的后台拓扑，包含三个部分：<ol>
<li><strong>Nginx</strong>反向代理</li>
<li><strong>Flask</strong>逻辑服务器</li>
<li><strong>MySQL</strong>数据库服务器</li>
</ol>
</li>
<li>看起来非常朴实，实际上门门道道，细节问题着实费了我两天时间，特别是在逻辑服务器哪里，因为粗心大意，愣是搭了一个晚上还是失败。</li>
<li>本次是将终端和前端的接口进行了统一，实际上这样对一个快速开发项目来说的确是必须的，不必考虑太多细节，追求的是效率，毕竟<strong>Flask</strong>框架追求的的确就是开发效率，至于并发情况实际上在众多框架中，并不能算太好。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.wushxin.top/tags/Linux/"/>
    
      <category term="Python" scheme="http://www.wushxin.top/tags/Python/"/>
    
      <category term="架构" scheme="http://www.wushxin.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[直接理解红黑树旋转]]></title>
    <link href="http://www.wushxin.top/2016/04/09/%E7%9B%B4%E6%8E%A5%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%97%8B%E8%BD%AC.html"/>
    <id>http://www.wushxin.top/2016/04/09/直接理解红黑树旋转.html</id>
    <published>2016-04-09T01:36:20.000Z</published>
    <updated>2016-04-09T02:09:47.238Z</updated>
    <content type="html"><![CDATA[<h2 id="只需要一张图">只需要一张图</h2><p><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1f2q7jvjqhnj21kw16baf6.jpg" alt=""></p>
<ol>
<li><p>对于新插入的每个节点而言，它都是红色的，那么就有两种情况</p>
<ol>
<li>他父亲是黑色(完美，啥都不用变)</li>
<li>他父亲是红色(需要调整了，从他自己开始，一路向<strong>根节点</strong>调整)</li>
</ol>
</li>
<li><p>所以最外层可以用一个循环，来判断是否到了根，是否父节点是黑色。</p>
</li>
<li>无论是有接触到<code>root</code>节点，在最末尾都给他设置成黑色，这是最省事的做法，也不会有什么性能消耗。</li>
<li><p>红字中的: 左旋，右旋，是按照顺序的，且针对的目标不同，稍微看过的应该能很快知道</p>
<ol>
<li><strong>父为左子-&gt;伯父为黑-&gt;新点为右情况下： </strong> (先对父)左旋，<strong>改颜色</strong>，(再对祖父)右旋。<ul>
<li>无论如何，先对某个节点的父节点进行单旋转，仅仅是改变这两个家伙的位置(只有在颜色相同时才会触发旋转)。</li>
</ul>
</li>
<li><strong>父为左子-&gt;伯父为黑-&gt;新点为左情况下： </strong> <strong>改颜色</strong>， (对祖父)右旋</li>
</ol>
</li>
<li><p>下面的情况就是依此类推</p>
</li>
<li><strong>改颜色</strong>，顾名思义就是，设置颜色的意思，并且将空节点(NULL节点)也<strong>视为黑色的</strong>！</li>
</ol>
<h3 id="以上所述">以上所述</h3><ul>
<li><p>就是所有红黑树在插入或者删除之后的平衡操作时，需要注意以及执行的步骤。</p>
<a id="more"></a>
<h3 id="转载请注明出处">转载请注明出处</h3><p> <a href="http://www.wushxin.top/2016/04/09/直接理解红黑树旋转.html" target="_blank" rel="external">http://www.wushxin.top/2016/04/09/直接理解红黑树旋转.html</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="只需要一张图">只需要一张图</h2><p><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1f2q7jvjqhnj21kw16baf6.jpg" alt=""></p>
<ol>
<li><p>对于新插入的每个节点而言，它都是红色的，那么就有两种情况</p>
<ol>
<li>他父亲是黑色(完美，啥都不用变)</li>
<li>他父亲是红色(需要调整了，从他自己开始，一路向<strong>根节点</strong>调整)</li>
</ol>
</li>
<li><p>所以最外层可以用一个循环，来判断是否到了根，是否父节点是黑色。</p>
</li>
<li>无论是有接触到<code>root</code>节点，在最末尾都给他设置成黑色，这是最省事的做法，也不会有什么性能消耗。</li>
<li><p>红字中的: 左旋，右旋，是按照顺序的，且针对的目标不同，稍微看过的应该能很快知道</p>
<ol>
<li><strong>父为左子-&gt;伯父为黑-&gt;新点为右情况下： </strong> (先对父)左旋，<strong>改颜色</strong>，(再对祖父)右旋。<ul>
<li>无论如何，先对某个节点的父节点进行单旋转，仅仅是改变这两个家伙的位置(只有在颜色相同时才会触发旋转)。</li>
</ul>
</li>
<li><strong>父为左子-&gt;伯父为黑-&gt;新点为左情况下： </strong> <strong>改颜色</strong>， (对祖父)右旋</li>
</ol>
</li>
<li><p>下面的情况就是依此类推</p>
</li>
<li><strong>改颜色</strong>，顾名思义就是，设置颜色的意思，并且将空节点(NULL节点)也<strong>视为黑色的</strong>！</li>
</ol>
<h3 id="以上所述">以上所述</h3><ul>
<li><p>就是所有红黑树在插入或者删除之后的平衡操作时，需要注意以及执行的步骤。</p>]]>
    
    </summary>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
      <category term="算法" scheme="http://www.wushxin.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用tmux]]></title>
    <link href="http://www.wushxin.top/2016/03/28/%E4%BD%BF%E7%94%A8tmux.html"/>
    <id>http://www.wushxin.top/2016/03/28/使用tmux.html</id>
    <published>2016-03-27T23:51:30.000Z</published>
    <updated>2016-03-28T08:20:39.207Z</updated>
    <content type="html"><![CDATA[<h2 id="神级命令行软件_Tmux">神级命令行软件 Tmux</h2><ul>
<li>这是我在大学里认识到的<strong>最好用</strong>的神器，<strong>没有之一</strong>，提高效率那是没得说，主要至今未曾崩溃过，可见其可怕之处</li>
<li>额外提一点就是，由于学校原因，没机会使用到 <code>tmux</code> 的远程连接黑魔法，所以本篇文章记录的是单机情况下的操作，远程连接没有用过，就不好置评</li>
<li>但即便是单机情况下，<code>tmux</code> 也绝对是让人惊艳的一款终端软件</li>
</ul>
<h3 id="说白了它就是一个分屏工具">说白了它就是一个分屏工具</h3><ul>
<li>我不会记录它的每个部件的具体名字，而是用什么地方的作用来描述它，还是那句老话，在其位谋其职。</li>
</ul>
<h3 id="迅速开始">迅速开始</h3><ul>
<li><p>安装，直接从仓库里安装，但是一般而言，<code>Linux</code>会自带</p>
<pre><code>$ sudo apt-<span class="keyword">get</span> install tmux
</code></pre></li>
<li><p>完成之后，不用管其他的，直接在 <code>Shell</code> 里输入：</p>
<pre><code><span class="variable">$ </span>tmux
</code></pre><p>  很好，进入到了另一个异次元，其实看起来和刚才没多大区别，也就是屏幕闪了一下。</p>
</li>
<li><p>这就是最原始的<code>tmux</code>界面，接下来记录进行最有用的，也是最经常用的<strong>三个操作</strong></p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1f2cmx18vogj211j0kk42e.jpg" alt="进入tmux"></p>
</li>
</ul>
<h3 id="Ctrl_+_b">Ctrl + b</h3><ol>
<li>意思就是在进入到<code>tmux</code>之后，先摁<code>Ctrl</code>，再摁 <code>b</code>，发现进入到了<strong>上帝模式</strong>，姑且当这种模式就是能干任何事的上帝模式，进入这个模式要干嘛？</li>
<li>比如创建新的界面，或者分割当前界面，退出当前界面都要靠这个模式。</li>
<li>所以记下这个简单的组合键，<strong>日后会经常用它</strong>。</li>
</ol>
<blockquote>
<p>后面提到上帝模式，就说明摁了 <strong>Ctrl+b</strong></p>
</blockquote>
<h3 id="上帝模式下的屏幕分割">上帝模式下的屏幕分割</h3><ul>
<li>进入上帝模式后，使用 <code>%</code> 进行屏幕的<strong>水平分割</strong>，至于问我怎么竖直分割，<strong>我不喜欢用</strong>，所以忘了。</li>
</ul>
<blockquote>
<p><code>%</code> 的意思就是，先摁住<code>shift</code>键，再摁数字<code>5</code>，不是小键盘的<code>5</code>，而是英文字符上面的那个<code>5</code>。 <strong>: )</strong></p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1f2cmdudg32j211k0kjjvz.jpg" alt="水平分割tmux"></p>
<ul>
<li><p>分割完，要怎么在这两个窗口之间跳转呢？</p>
<ul>
<li>进入<strong>上帝模式</strong>，摁左右方向键切换。每切换一次，都需要<strong>重新进入</strong>上帝模式，才能进行下一次的切换</li>
</ul>
</li>
<li><p>要是不想要当前操作的这个分屏怎么办？</p>
<ul>
<li>进入<strong>上帝模式</strong>， 摁<code>x</code>，就像是右上角的叉叉一样，很好记。</li>
</ul>
</li>
</ul>
<h3 id="退出_tmux">退出 tmux</h3><ul>
<li>进入上帝模式，摁 <code>d</code> ，其实这不是退出，这叫做<strong>断开连接</strong>，意味着你可以再恢复</li>
<li><p>不信，你试试</p>
<pre><code>$ tmux <span class="literal">a</span>
</code></pre></li>
<li><p>原归正转，当你回到原始<code>Shell</code>时，使用命令 <code>tmux ls</code>，看看会出现什么:</p>
<pre><code><span class="variable">$ </span>tmux ls
</code></pre><p>  出现</p>
<pre><code>root<span class="variable">@kali</span><span class="symbol">:~/ClionProjects/httpd3</span><span class="comment"># tmux ls</span>
<span class="number">0</span><span class="symbol">:</span> <span class="number">1</span> windows (created <span class="constant">Mon Mar </span><span class="number">28</span> 08<span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">01</span> <span class="number">2016</span>) [<span class="number">150</span>x4<span class="number">0</span>]****
</code></pre><p>  现在从这行回馈中，能得到对我们最有用的是两个信息：当前有一个 <strong>tmux窗会话</strong>，这个会话的名字是 <code>0</code></p>
</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1f2cmdisl6nj211l0kj0x2.jpg" alt="进入tmux"></p>
<blockquote>
<p><code>tmux</code> 可以有多个会话，一个会话可以有多个窗口， 从外部<code>Shell</code>可以连接到不同会话，从内部会话可以切换不同的窗口。</p>
</blockquote>
<ul>
<li><p>得到了名字有什么用？得到了名字，你就能掌控这个会话的一切，就像<strong>夏目友人帐</strong>，跑题。</p>
<ul>
<li><p>连接到这个会话(如果有多个会话，这就十分有用):</p>
<pre><code><span class="variable">$ </span>tmux attach -t <span class="number">0</span>
</code></pre><p>  或者</p>
<pre><code>$ tmux <span class="tag">a</span> -t <span class="number">0</span>
</code></pre><p>  <code>a</code> 是对 <code>attach</code> 的缩写,现在能理解上面那个<code>d</code>的含义了吧，就是<code>detach</code>的意思。</p>
</li>
<li><p>关闭这个会话:</p>
<pre><code>$ tmux <span class="operator"><span class="keyword">kill</span>-<span class="keyword">session</span> -t <span class="number">0</span></span>
</code></pre><p>  关闭这个会话，这个会话里的一切都消失了(当然你要是重启系统，自然也会消失)</p>
<h3 id="配置_tmux">配置 tmux</h3></li>
</ul>
</li>
<li><p>上面所说的三个组合，是最常用的三个组合键，记好它们，有人会问我，<strong>你的底部状态栏怎么和我的不一样</strong>，当然是配置问题</p>
</li>
<li><p>和<code>vim</code>一样，<code>tmux</code>也有一个配置文件，放在家目录下的<code>.tmux</code>，也就是说在<code>shell</code>里输入</p>
<pre><code>$ <span class="built_in">cd</span> ~
</code></pre><p>  进入的目录里，找到<code>.tmux.conf</code>，如果没有就：</p>
<pre><code>$ touch <span class="class">.tmux</span><span class="class">.conf</span>
</code></pre><p>  不要怕会误删什么东西。打开它，输入如下内容：</p>
<pre><code><span class="operator"><span class="keyword">set</span> -g base-<span class="keyword">index</span> <span class="number">1</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-utf8 <span class="keyword">on</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-bg black
<span class="keyword">set</span> -g <span class="keyword">status</span>-fg white
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">5</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span>-length <span class="number">90</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span>-length <span class="number">60</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=Green]#(whoami)#[fg=white]::#[fg=blue]#(hostname -s)#[fg=white]::#[fg=yellow]#(curl ipecho.net/plain;echo)#[fg=Green] &lt;- "</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-justify <span class="keyword">left</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'#[fg=Cyan]#S #[fg=white]%a %d %b %R'</span></span>
</code></pre><p>  稍微解读一下第八行，这样你也可以自己修改配置文件了，很简单(更高级的请看官方文档，以及这个配置文件也不是我原创是属于<a href="raw.githubusercontent.com/danielmiessler/tmux/master/.tmux.config">这位先生的</a>，当然我进行了一点小小的修改)</p>
<p>  在<code>&quot;&quot;</code>里面包裹着一长串的看不懂的英文， <code>#</code>分割着每个属性，<code>[]</code>里面装放着是下一个<code>#</code>属性的显示颜色，<code>()</code>包裹着的理解为可以在<code>shell</code>下执行的命令，将结果显示出来，想要添加<strong>固定字符串</strong>，直接写就行，例如我在末尾添加了 <code>&lt;-</code>。</p>
<p>  网上有很多介绍 <code>tmux</code> 的文章，<strong>但不要轻易相信他们</strong>，永远相信自己实践出来的效果，因为网页文章的质量没有人监管，很多都是错误的，让初学者摸不着头脑(也许是手误打错，也许是真的不会装懂。)</p>
<p>  我这个配置文件的效果，就在上面的图片中有显示。</p>
</li>
</ul>
<blockquote>
<p>想让这个配置文件生效，必须要将所有的 <code>tmux</code> 窗口都<strong>退出</strong>才行。</p>
</blockquote>
<h3 id="到目前为止的组合键">到目前为止的组合键</h3><ul>
<li>创建且打开<code>tmux</code>的会话 : <code>$ tmux</code></li>
<li>让这个会话的当前窗口水平分割 : <code>Ctrl + b --&gt; %</code><ul>
<li>在分割的两个块中跳转 : <code>Ctrl + b --&gt; 方向键</code></li>
<li>关闭某个分屏 : <code>Ctrl + b --&gt; x</code></li>
</ul>
</li>
<li>让这个会话断开连接，回到原始<code>Shell</code> : <code>Ctrl + b --&gt; d</code></li>
<li>让这个会话恢复连接，回到 <code>tmux</code> : <code>tmux a -t 0</code></li>
<li>从原始<code>Shell</code>把这个会话彻底关闭 : <code>$ tmux kill-session -t 0</code></li>
</ul>
<h3 id="详细的说">详细的说</h3><ol>
<li><p>创建会话的时候，如果不指定名称，那么<code>tmux</code>会帮你给这个会话取名字，也就是前面看到的数字，依次递增，如果想自己指定名称那么：</p>
<pre><code>$ tmux <span class="keyword">new</span> -s session-<span class="number">1</span>-name
</code></pre><p> 会立即进入到你创建的这个新会话内，现在通过<code>detach</code>回到原始<code>Shell</code>，并输入<code>tmux ls</code></p>
<pre><code><span class="tag">session-1-name</span>: 1 <span class="tag">windows</span> (<span class="tag">created</span> <span class="tag">Mon</span> <span class="tag">Mar</span> 28 09<span class="pseudo">:28</span><span class="pseudo">:54</span> 2016) <span class="attr_selector">[150x40]</span>
</code></pre><p> 现在再看看这条信息，应该很清晰明了，<code>:</code>前面是会话名称，后面是这个会话里当前有几个<strong>窗口</strong></p>
<p> 当然你想要重命名这个会话也是可以的，只要进入上帝模式以后，摁 <code>$</code>即可</p>
</li>
<li><p>创建窗口</p>
<ol>
<li>在上帝模式下，摁<code>c</code>，就能创建一个新窗口，并且立即进入到新窗口内，如何在窗口之间切换呢？</li>
<li>这时候看你的底部状态栏，在<code>&lt;-</code>后面是不是多了些什么，没错那些就是新的窗口，每个窗口前面都有序号，在上帝模式下，摁对应的序号就能切换到那个窗口去。</li>
<li>但是有没有发现一个问题，新建的窗口的名字都一样！那怎么区分啊，不急一般在创建窗口之后会立即修改他的名字<ol>
<li>进入上帝模式，摁 <code>,</code> 就能修改了，你会发现下面的状态栏变成黄色，且可编辑，删除原来的名字换成自己想要的名字就行。</li>
</ol>
</li>
</ol>
</li>
<li><p>切换会话</p>
<ol>
<li>如果我就在会话中，想要到别的会话去，拿到一定要先回到原始<code>Shell</code>在去连接吗？当然不</li>
<li>直接进入上帝模式，摁<code>s</code>，就能看见当前存在的会话，移动方向键选择即可。<ol>
<li><code>Ctrl + b --&gt; s</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1f2cme6107vj20f202ut94.jpg" alt="会话切换"></p>
<ol>
<li>切换窗口<ol>
<li>如果我想显示当前会话中的所有窗口，那就进入上帝模式，再摁 : <code>w</code><ol>
<li><code>Ctrl + b --&gt; w</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1f2cmx6c634j20a60270sv.jpg" alt="窗口切换"></p>
<blockquote>
<p>可以仔细观察一下，<strong>窗口的名字</strong>，是否有什么特殊的地方，文末解释</p>
</blockquote>
<h2 id="结束">结束</h2><ul>
<li>在日常中，只需要记住以上说过的命令就可以，其他的可以查看 <code>man</code> 手册就行，不需要记住，最实用的，才是最好的。</li>
</ul>
<h3 id="话内">话内</h3><ul>
<li>上面的操作看起来很复杂，实际上是一个很流畅的一套操作</li>
<li><p>如果是日常个人电脑上的操作，可以这样：</p>
<ul>
<li>打开终端 <code>Terminal</code></li>
<li>直接打开 <code>tmux</code> : <code>$ tmux</code> 不必在意会话的名字(如果是公用的可以考虑用名字区分)</li>
<li><p>直接分屏 <code>Ctrl + b --&gt; %</code> 实际上水平分屏的作用已经足够，对于屏幕小于 <strong>17寸</strong>的显示器而言，对半分已经很完美了，要是分成四份，那真是有点…</p>
<ul>
<li>如果对分开的两个屏幕的大小有要求，可以自行调整，方式有些特别：<strong>摁住</strong><code>Ctrl+b</code>不撒手，左右方向键调节窗口大小。</li>
</ul>
</li>
<li><p>想回到原始<code>Shell</code>就<code>Ctrl + b --&gt; d</code> 当然这个一般很少用，我几乎不用</p>
</li>
<li>回来就直接 <code>$ tmux a</code></li>
</ul>
</li>
</ul>
<h3 id="文末">文末</h3><ul>
<li>前面提到，在一个会话里有多个窗口的时候，窗口的名字会有些许不同</li>
<li>名字末尾带 <code>*</code> 的是当前窗口，名字末尾带 <code>-</code>则是上一个窗口。</li>
<li>至于为什么没有介绍更多的快捷键，那就需要自己凭个人去记就行，对于我而言，我只记了这些操作，认为已经足够</li>
<li>而对于那些说什么 重新绑定快捷键什么的言语，我只说一句，<strong>看个人</strong>，不要想着说服别人，让别人主动去做才是对的。至少我没有感觉到不适应。</li>
</ul>
<h4 id="如转载请注明原处_:_)">如转载请注明原处 : )</h4><p> <a href="http://www.wushxin.top/2016/03/28/%E4%BD%BF%E7%94%A8tmux.html" target="_blank" rel="external">http://www.wushxin.top/2016/03/28/%E4%BD%BF%E7%94%A8tmux.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="神级命令行软件_Tmux">神级命令行软件 Tmux</h2><ul>
<li>这是我在大学里认识到的<strong>最好用</strong>的神器，<strong>没有之一</strong>，提高效率那是没得说，主要至今未曾崩溃过，可见其可怕之处</li>
<li>额外提一点就是，由于学校原因，没机会使用到 <code>tmux</code> 的远程连接黑魔法，所以本篇文章记录的是单机情况下的操作，远程连接没有用过，就不好置评</li>
<li>但即便是单机情况下，<code>tmux</code> 也绝对是让人惊艳的一款终端软件</li>
</ul>
<h3 id="说白了它就是一个分屏工具">说白了它就是一个分屏工具</h3><ul>
<li>我不会记录它的每个部件的具体名字，而是用什么地方的作用来描述它，还是那句老话，在其位谋其职。</li>
</ul>
<h3 id="迅速开始">迅速开始</h3><ul>
<li><p>安装，直接从仓库里安装，但是一般而言，<code>Linux</code>会自带</p>
<pre><code>$ sudo apt-<span class="keyword">get</span> install tmux
</code></pre></li>
<li><p>完成之后，不用管其他的，直接在 <code>Shell</code> 里输入：</p>
<pre><code><span class="variable">$ </span>tmux
</code></pre><p>  很好，进入到了另一个异次元，其实看起来和刚才没多大区别，也就是屏幕闪了一下。</p>
</li>
<li><p>这就是最原始的<code>tmux</code>界面，接下来记录进行最有用的，也是最经常用的<strong>三个操作</strong></p>]]>
    
    </summary>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个HTTP服务器的C之路(下)]]></title>
    <link href="http://www.wushxin.top/2016/03/26/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF-%E4%B8%8B.html"/>
    <id>http://www.wushxin.top/2016/03/26/一个HTTP服务器的C之路-下.html</id>
    <published>2016-03-26T00:00:23.000Z</published>
    <updated>2016-04-21T10:52:37.131Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>趁着早起， 接着昨天</p>
</blockquote>
<h2 id="功能选择">功能选择</h2><ul>
<li>选择使用的<code>epoll</code></li>
<li>实际上，<code>epoll</code>应该是代表单进程的极端表现，最大程度的发挥一个核的最大实力，但是对多核来说就有些无法触及，但是在此处我们可以考虑将<code>epoll</code>扩展出去。</li>
<li><p><code>epoll</code>的作用是监听已被注册到自身的那些文件描述符的各种事件(可读，可写等等)。我们可以考虑让<strong>监听套接字</strong>独享一个<code>epoll</code>(连接epoll)，并且在其之下(逻辑中的下，实际上没有直接连接接触)用多线程/多进程建立几个处理新连接事物的专用<code>epoll</code>(事务epoll)。就是这么简单的思路。</p>
<ul>
<li>对比一下多线程还是多进程：</li>
<li><strong>多进程</strong> 模式是独立性较好，在忽略所谓的进程创建开销(对于本程序而言可以忽略，因为总是创建固定数量的进程，而不是在运行程序是一直创建，销毁)情况下，多进程还有一个缺点，那就是进程间通信(IPC)开销大，即便是使用<strong>共享内存</strong>也是如此，因为需要<strong>打开描述符open，映射mmap，关闭描述符close</strong>，(还隐含着解除映射munmap)，这样的操作。</li>
<li><strong>多线程</strong> 模式是对于数据的独立性差，十分容易出错，特别是竞争条件的产生是多核编程中最为核心的问题。</li>
</ul>
</li>
<li><p>针对上面的问题，可以参考<strong>分布式系统</strong>的设计过程中，有一种叫做<strong>一致性哈希</strong>的设计思想，也就是不要让 <strong>事务epoll</strong> 相互竞争，而是让<strong>连接epoll</strong>自己将新的到的连接，分发给这些固定数量的<strong>事务epoll</strong>中的某一个，并且应该形成<strong>均衡发布</strong>。</p>
<ul>
<li>后期会实现，当某一个线程意外退出以后，事务会均衡发放给离自己最近的线程。<a id="more"></a>
<blockquote>
<p>epoll</p>
</blockquote>
</li>
</ul>
</li>
<li><p>对于<code>epoll</code>而言，<strong>连接epoll</strong>所处理的事情十分简单，就是负责整个网络程序服务端工作中的第四个部分 <code>accept</code>，只需要对监听套接字的 <strong>可读事件(EPOLLIN)</strong> 敏感就行，这样就讲现成的撰写难度降低。而对于<strong>事务epoll</strong>而言，事情会稍微复杂一些。</p>
<ul>
<li><strong>事务epoll</strong> 是真正处理实际连接的，也就是对<strong>HTTP</strong>请求做出回应的。</li>
<li>在这些<code>epoll</code>中，我们需要处理的就是<strong>三种事件</strong> ： (<strong>可读</strong>，<strong>可写</strong>，<strong>错误</strong>)，这里很多刚接触的人(包括我)，都会将可读和可写放在一起处理，其实这是不怎么好的方法，试想这种情况：<ul>
<li>你接受到了一个新连接请求(连接epoll处理了)，并且这个新连接被分发到了某一个<strong>事物epoll</strong>中，且产生了一个可读事件，并被捕捉到了，这时候你处理完可读事件之后，直接向其发送数据。</li>
<li>此时就是一个性能点，如果此时你本机的TCP写缓冲满了怎么办？用程序语言来说就是，如果此时<code>write</code>调用返回<code>-1</code>且<code>errno == EAGAIN</code>,由于你将读写放在一个事件里(读事件)，所以你没办法在这种错误发生时有补救措施。要么你一直循环重试<code>write</code>知道其成功发送(或者对方突然关闭连接，返回<code>0</code>)，这就会导致那个线程所在的CPU核使用率居高不下，都浪费在这里了。要么你就只能关闭连接，让<strong>peer端</strong>去负担这个后果(<strong>这个由服务器端失策造成的后果！</strong>)。</li>
</ul>
</li>
<li>对 可读事件 和 可写事件 进行分离，是一个比较好，且操作起来也比较简洁的方法，这样我们可以不用同时考虑两种事件带来的复杂性，即增加复杂度。</li>
<li>具体做法就是，在<code>连接epoll</code>获得新连接时，将其用<strong>可读事件</strong>注册到<strong>事务epoll</strong>中，一旦<strong>事务epoll</strong>被可读事件激活，就处理这个可读事件，并将需要发送给<strong>peer端</strong>的数据准备好，放在每个连接自己的缓冲区内，将这个连接重新用<strong>可写事件</strong>注册回自身。</li>
<li>这样即便是TCP的写缓冲满了，我们也可以选择下次<strong>发送剩下的数据</strong></li>
</ul>
</li>
<li><p><code>epoll</code>有两种模式，<strong>LT</strong> 和 <strong>ET</strong>, 这两种的区别网上详细讲解的很多，不在赘述，我在这个软件中采用的是 <strong>ET</strong> 模式，且使用了<code>EPOLLONESHOT</code>选项，这个选项在我的设计方式中，实际上是没有什么必要(目前看来)</p>
<ul>
<li><code>EPOLLONESHOT</code>最开始是为了防止使用<strong>线程池技术</strong>时候，对防止<strong>对新连接的竞争</strong>时的措施，也就是说，假设A线程在处理某个新连接(A连接)的某个事件(A事件)时，突然A连接的A事件又被触发了(这是可能的，例如读事件，突然又有新数据到来)，那么B线程可能就接到了这个事件，也开始处理，这就产生了冲突，会导致垃圾数据的产生。</li>
<li>而对这个连接采用<code>EPOLLONESHOT</code>的意义就在于，每次这个连接被处理了，那么就自动从这个epoll中除名，下次想用这个epoll监视这个连接，就需要重新注册(epoll_clt)。</li>
<li>但这对我从一开始就分配好固定的<code>epoll</code>而言，这个属性似乎没有什么必要，留下它是因为它并没有造成额外的工作，而且可以让后续的想法更流畅的实现，万一有新想法了呢：）</li>
</ul>
</li>
</ul>
<h2 id="错误处理">错误处理</h2><blockquote>
<p>前提所有的 文件描述符 都是非阻塞的。</p>
</blockquote>
<ul>
<li><p><code>accept</code></p>
<ul>
<li><p>由于 <code>accept</code> 是在 <strong>连接epoll</strong> 的 <code>epoll_wait</code>成功时，才会调用，所以我们需要对这个<code>accept</code>一直循环，直到其返回`-1</p>
<pre><code><span class="keyword">while</span> (is_work <span class="subst">&gt;</span> <span class="number">0</span>) { <span class="comment">/* New Connect */</span>
    sock <span class="subst">=</span> accept(new_client<span class="built_in">.</span><span class="built_in">data</span><span class="built_in">.</span>fd, <span class="built_in">NULL</span>, <span class="built_in">NULL</span>);
    <span class="keyword">if</span> (sock <span class="subst">&gt;</span> <span class="number">0</span>) {
        fprintf(stderr, <span class="string">"There has a client(%d) Connected\n"</span>, sock);
        set_nonblock(sock);
        <span class="attribute">...</span> 
    } <span class="keyword">else</span> <span class="comment">/* sock == -1 means nothing to accept */</span>
        break;
}
</code></pre><p>之所以需要一直循环，是因为不一定只有一个新连接接上来。</p>
</li>
</ul>
</li>
<li><p><code>read</code></p>
<ul>
<li>如果 <code>read</code>函数返回值大于<code>0</code>，表明正确读到数据，继续循环读</li>
<li>如果 <code>read</code>函数返回值小于<code>0</code>，(1)且<code>errno == EAGAIN || errno == EWOULDBLOCK</code> 代表缓冲区无数据可读了，注册写事件,(2)你需要关闭这个连接了</li>
<li><p>如果 <code>read</code>函数返回值等于<code>0</code>，表明你需要关闭这个连接了。这代表<strong>peer</strong>端发了一个<strong>FIN</strong>给你。</p>
<pre><code><span class="keyword">while</span> (<span class="number">1</span>) {
    <span class="built_in">read</span>_number = <span class="built_in">read</span>(fd, buf+buf_index, BUF_SIZE-buf_index);
    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">read</span>_number) { /* We must close connection */
        <span class="built_in">return</span> READ_FAIL;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == <span class="built_in">read</span>_number) { /* Nothing to <span class="built_in">read</span> */
        <span class="keyword">if</span> (EAGAIN == errno || EWOULDBLOCK == errno) {
            buf[buf_index] = <span class="string">'\0'</span>;
            <span class="built_in">return</span> READ_SUCCESS;
        }
        <span class="built_in">return</span> READ_FAIL;
    }
    <span class="keyword">else</span> { /* Read Success */
            ...
    }
}
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>EAGAIN 和 EWOULDBLOCK 值实际上是一样的</p>
</blockquote>
<ul>
<li><p><code>write</code></p>
<ul>
<li>如果 <code>write</code>函数返回值大于<code>0</code>,表明正确的写了数据，继续循环写</li>
<li>如果 <code>write</code>函数返回值小于<code>0</code>,(1)且<code>errno == EAGAIN</code>代表写缓冲满了，重新注册写事件，(2)且<code>errno == EPIPE</code>，表明你需要关闭这个连接了，这代表<strong>peer</strong>端<code>close</code>这个连接。(3) 表明你需要关闭这个连接了</li>
<li><p>如果 <code>write</code>函数返回值等于<code>0</code>,这种情况应该不会发生，在系统层面来说这应该是不合法的。</p>
<pre><code><span class="keyword">while</span> (nbyte &gt; <span class="number">0</span>) {
    buf += <span class="keyword">count</span>;
    <span class="keyword">count</span> = write(fd, buf, <span class="number">8192</span>);
    <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) {
        <span class="keyword">if</span> (EAGAIN == errno || EWOULDBLOCK == errno) {
            memcpy(<span class="keyword">client</span>-&gt;write_buf, buf, strlen(buf));
            <span class="keyword">client</span>-&gt;write_offset = nbyte;
            <span class="keyword">return</span> HANDLE_WRITE_AGAIN;
        }
        <span class="keyword">else</span>
            <span class="keyword">return</span> HANDLE_WRITE_FAILURE;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">count</span>)
        <span class="keyword">return</span> HANDLE_WRITE_FAILURE;
    nbyte -= <span class="keyword">count</span>;
}
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>EPIPE 会和一个信号 SIGPIPE 一起出现，你需要(必须)处理它，至少在它发生前处理它，不然你的程序就会被中断，最简单的处理方式就是 <strong>忽略它</strong>。</p>
<p>EINTR 这个<code>errno</code>值，在非阻塞的套接字中不需要太过关注，但是如果是阻塞型套接字编程，那就是一个十分重要的值，需要特别关注</p>
</blockquote>
<ul>
<li>以上是三大需要<strong>仔细小心谨慎</strong>处理的比较核心的错误。</li>
<li><p>如果还要加一点，那就是<strong>信号处理</strong>，不过这个用<code>gdb</code>很容易就定位出来了，还不懂怎么用的，可以参考我上一篇文章如何简洁地使用gdb。</p>
</li>
<li><p>最后一点，就是比较难意识到的，一开始我也忽略了这个严重的问题，那就是网络拥塞的情况</p>
<ul>
<li>比如：当对方的请求过大，而你和对端约定的<strong>MTU</strong>比这个请求数据要小的时候，会发生分片，而一旦某个分片先到达，而其他分片由于某些原因没有同时到达</li>
<li>那么也许<code>read</code>返回<code>-1</code> 且 <code>errno == EAGAIN</code>的时候，数据其实并没有读取完毕。</li>
<li>这种情况下，我们需要靠自己来判断数据是否完整<ul>
<li><code>GET,HEAD</code>之类的请求方法时，以收到的数据中是否含有空行<code>\r\n</code>为基准</li>
<li><code>POST</code>则更麻烦些，需要解析出<code>Content-Length</code>属性，用以确定其报文体的尾部。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缺陷">缺陷</h3><ul>
<li>那就是对客户端信息的包装不够</li>
<li>具体体现在，<code>GET</code>方法实现的时候，需要传递的参数很多，应该将这些信息包含进客户端连接的结构体中，而不是临时用变量存储，传递。</li>
<li>一个线程如果挂掉了，很可能引发雪崩似的错误。</li>
<li><p>就算没有崩溃，每崩掉一个线程(<strong>事务epoll</strong>所在线程)整个服务器的性能将下降 <strong>20%</strong>， 如果<strong>连接epoll</strong>所在的线程崩溃，整个程序也就结束了。</p>
</li>
<li><p>具体项目源码 : <a href="https://github.com/wrestle/httpd3" target="_blank" rel="external">httpd3</a>·</p>
</li>
<li>欢迎指正 : )</li>
</ul>
<h3 id="写在最后之前">写在最后之前</h3><ul>
<li>其实对于使用 <strong>多线程</strong> 还是 <strong>多进程</strong>，又是一个话题，这个问题我考虑了许久，实际上两者各有千秋，怎么说呢？</li>
<li>我分享一下我当时的思路，其实我选择多线程，并不是因为多线程比多进程的方案更优，而是我看多线程更顺眼而已。</li>
</ul>
<blockquote>
<p>可以读一读关于 Linux 环境中，线程和进程的区别和联系，其实两者十分相似(不止体现在功能上)</p>
</blockquote>
<ul>
<li>多进程：<ol>
<li>我只说程序模型，而不是讨论他们的运行原理。如果是选择多进程模型，那就应该尽量避免进程间的数据传递，所以多线程的那种 <strong>负载均衡</strong> 方式就不适合了，我们可以选择创建多个进程（地位平等），每个进程都有一个<code>epoll</code>实例，且都注册了同一个<strong>监听套接字</strong>，这样不就也达到了同样的并发目的。</li>
<li>但是随之而来的问题是： 1) <strong>惊群现象</strong>，在 Linux内核<code>4.5</code> 之前没有系统提供的解决方案，而距离主流内核提升到<code>4.5</code>还有漫漫长路要走。至于惊群现象这里不给出赘述，网上的解释很多，简单来说就是一个新连接到来会唤醒所有进程中的<code>epoll_wait</code>，但只有一个<code>epoll_wait</code>会成功返回。 2) <strong>负载不均衡</strong>， 因为每次被<strong>成功</strong>唤醒的进程都不确定，完全是操作系统这个二愣子出的主意，所以有可能(很有可能，到最后会接近99%)会出现一个进程忙死了，有的进程闲死(专业一点叫做<strong>饥饿现象</strong>)。</li>
<li>解决方案当然是有的，而且是很好的一箭双雕(解决方案是<code>nginx</code>的)，就是用锁来解决，大概的意思就是每个进程持有自旋锁(<strong>自己实现的</strong>)，这个自旋锁的设计很巧妙，是有时间限制的自旋锁，且时间可自行调整，通过调整这个时间的值，来达到负载均衡的效果，即本次没有得到新连接的进程，下次锁的时间就减少，这样获得新连接的概率就增大，同时也解决了惊群现象。</li>
</ol>
</li>
</ul>
<blockquote>
<p>惊群现象在内核 <code>3.9</code> 的时候，被提出解决，解决的方案是 <code>EPOLLEXCLUSIVE</code> 这个Event，而在最近发布的 <strong>Linux内核4.5</strong>中被正式的修复(方案就是前面这个)。 其实在这之前还有一个系统调用会导致惊群，那就是 <code>accept</code>，只不过被修复了，忘了是内核多少(<code>2.4</code>or<code>2.6</code>)。</p>
</blockquote>
<ul>
<li>多线程<ol>
<li>在逻辑最上层有一个<code>epoll</code>实例，用于注册<strong>监听套接字</strong>，<code>accept</code>新连接，并将新连接 均衡 的分给，处于逻辑下层的各个线程中的<code>epoll</code>实例。</li>
<li>缺点当然很明显就是，只有一个<code>epoll</code>在逻辑上层接待新连接，要是它崩溃了，那整个程序就完了。所以就健壮性而言，不如多进程的方案。而且要是任意一个线程因为某些原因死掉了，且不说程序是否能够运行的下去，就算程序能够苟活，整个服务器的性能一定会打一个折扣。相比之下，同种情况发生在多进程方案身上最多就是损失点性能，对整个服务器的运行而言，不会造成太大的波动。</li>
</ol>
</li>
</ul>
<blockquote>
<p>所以在我的实现中，处于上层逻辑中的<code>epoll</code>实例，也被我写成了一个数组类型，只不过初始化大小为 <code>1</code>，也就是暂时只有一个，我的想法是后期可以通过配置文件中添加新选项来进行更改。</p>
</blockquote>
<h2 id="末尾">末尾</h2><ul>
<li>这个 <strong>HTTP服务器</strong>程序只是一个预热，我的原计划中是要写一个 <strong>爬虫程序</strong></li>
<li>大致是，用这个<strong>HTTP服务器</strong>熟悉一下我将要战斗的地方的内部运作，考虑到现在大部分使用的都是<code>nginx</code>，我也很认真的看了它的一些(头疼，战斗民族的代码，但是比德国佬的<code>libuv</code>好太多了…)实现源码。</li>
<li>接下来会想做一个爬虫，并且最终的目标是一个分布式架构的爬虫，如果有兴趣的话可以联系我一起，我的<strong>E-mail</strong>在顶部栏的 <strong>关于</strong> 里面。</li>
</ul>
<h4 id="转载请注明原处_:_)">转载请注明原处 : )</h4><p><a href="http://www.wushxin.top/2016/03/26/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF-%E4%B8%8B.html" target="_blank" rel="external">http://www.wushxin.top/2016/03/26/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF-%E4%B8%8B.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>趁着早起， 接着昨天</p>
</blockquote>
<h2 id="功能选择">功能选择</h2><ul>
<li>选择使用的<code>epoll</code></li>
<li>实际上，<code>epoll</code>应该是代表单进程的极端表现，最大程度的发挥一个核的最大实力，但是对多核来说就有些无法触及，但是在此处我们可以考虑将<code>epoll</code>扩展出去。</li>
<li><p><code>epoll</code>的作用是监听已被注册到自身的那些文件描述符的各种事件(可读，可写等等)。我们可以考虑让<strong>监听套接字</strong>独享一个<code>epoll</code>(连接epoll)，并且在其之下(逻辑中的下，实际上没有直接连接接触)用多线程/多进程建立几个处理新连接事物的专用<code>epoll</code>(事务epoll)。就是这么简单的思路。</p>
<ul>
<li>对比一下多线程还是多进程：</li>
<li><strong>多进程</strong> 模式是独立性较好，在忽略所谓的进程创建开销(对于本程序而言可以忽略，因为总是创建固定数量的进程，而不是在运行程序是一直创建，销毁)情况下，多进程还有一个缺点，那就是进程间通信(IPC)开销大，即便是使用<strong>共享内存</strong>也是如此，因为需要<strong>打开描述符open，映射mmap，关闭描述符close</strong>，(还隐含着解除映射munmap)，这样的操作。</li>
<li><strong>多线程</strong> 模式是对于数据的独立性差，十分容易出错，特别是竞争条件的产生是多核编程中最为核心的问题。</li>
</ul>
</li>
<li><p>针对上面的问题，可以参考<strong>分布式系统</strong>的设计过程中，有一种叫做<strong>一致性哈希</strong>的设计思想，也就是不要让 <strong>事务epoll</strong> 相互竞争，而是让<strong>连接epoll</strong>自己将新的到的连接，分发给这些固定数量的<strong>事务epoll</strong>中的某一个，并且应该形成<strong>均衡发布</strong>。</p>
<ul>
<li>后期会实现，当某一个线程意外退出以后，事务会均衡发放给离自己最近的线程。]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
      <category term="网络编程" scheme="http://www.wushxin.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个HTTP服务器的C之路（上）]]></title>
    <link href="http://www.wushxin.top/2016/03/23/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF(%E4%B8%8A).html"/>
    <id>http://www.wushxin.top/2016/03/23/一个HTTP服务器的C之路(上).html</id>
    <published>2016-03-23T07:08:28.000Z</published>
    <updated>2016-04-21T10:45:59.477Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.wushxin.top/2016/03/26/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF-%E4%B8%8B.html" target="_blank" rel="external">一个HTTP服务器的C之路(下)</a></p>
<h3 id="记录近来写的HTTP服务器的_经历，坑，收获">记录近来写的HTTP服务器的 经历，坑，收获</h3><h2 id="万事皆有起因">万事皆有起因</h2><ul>
<li>大三了，又在反思自己和科班的差距，课少了，空闲时间突然多了起来，在这个大学里，这么一路走过来，自己摸索的不容易</li>
<li>天天看着浏览器的<strong>F12</strong>界面和 <strong>Wireshark</strong> 的抓取交互界面，突然想要自己做一个HTTP服务器，首先冷静了三天，发现这个念头依旧强烈，墙裂。</li>
<li>在翻看<strong>TCP/IP卷一协议</strong>无果后，于是我开始蹲点图书馆，借<strong>HTTP权威指南</strong> 和 <strong>图解HTTP</strong>，然而事与愿违，这个号称<strong>“黑龙江最大图书馆”</strong>称呼的学校图书馆竟无法找到这本书。行吧，那我不借了总行吧</li>
<li>回想起自己大二节选看的<strong>深入理解计算机操作系统(CSAPP)</strong>这本著名的书，似乎后面有一个Web服务器实现，虽然知道这大概是一个十分简陋的单处理的程序，但是对于理清自己思路很有帮助，特别是协议的交互</li>
<li>翻看一开，还真的有，说来惭愧前面的进程部分至今还是崭新的。首先看到了<strong>CGI</strong>，后来发现了后方的<strong>GET</strong>方法实现，大概了解了交互的过程，这之间在<strong>w3cschool</strong>查找了(恶补了一下HTTP状态码)一些HTTP的状态，以及<strong>维基百科</strong>里查看了HTTP报文的组成，当然最详细的还是使用WireShark抓取的交互包，而最简单明了的方法则是用 <strong>F12</strong>查看交互信息。</li>
<li><p>这之中有两个网站对我助力很大</p>
<ul>
<li><a href="http://www.softlab.ntua.gr/facilities/documentation/unix/unix-socket-faq/unix-socket-faq-2.html" target="_blank" rel="external">Questions regarding both Clients and Servers</a></li>
<li><a href="http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t/14388707#14388707" target="_blank" rel="external">Socket options SO_REUSEADDR and SO_REUSEPORT, how do they differ?</a></li>
</ul>
</li>
<li><p>Linux 的 <strong>man page</strong> 是另一个最有用的工具。</p>
</li>
</ul>
<h2 id="用C编写一个HTTP服务器？！">用C编写一个HTTP服务器？！</h2><ul>
<li>我说了这个想法给我的一个同学，他以为我疯了。</li>
<li>并没有，我在网上查了近来的许多模型，最后选择参考 <strong>事件驱动的epoll + 多线程</strong>进行实现，一方面直接避免了逻辑上的惊群现象，一方面也能充分利用多核。</li>
<li><p>我怎么想的，在最开始我对照着<strong>CSAPP</strong>对最开始的版本代码进行编写，不得不说里面有一个对系统调用(<code>read</code>, <code>write</code>)的调用在后面给我一个大坑，也给我很多思路上的启发。</p>
<ul>
<li>启发就在于，将系统调用进行自己的包装，可以提供很干净的C代码，并且可以进行良好功能的编写，这里特指对<strong>数据的缓存</strong>和<strong>错误处理</strong>，而这两个都是网络编程里的重头戏</li>
<li>大坑在于，我到后期发现，一个新的客户端在连接上本服务器之后，其信息应该尽可能集中，而不是分散在各处不同的结构体中，不容易维护，而且出了错还不容易发现。特别在于<strong>CSAPP</strong>中的 <code>rio</code>形式的读写封装，无法进行长久性的数据缓存，在这里长久性的数据缓存指的是，假设对端(<strong>peer</strong>)正忙，或者自己的TCP发送缓冲区已满，那这个数据要怎么办？</li>
</ul>
</li>
<li><p>不过读了<strong>CSAPP</strong>之后，最基本的服务器工作原理还是可以知道的，至少我看到了某些让我目瞪口呆的HTTP协议之间的交互方式。</p>
<ul>
<li>比如报文还真的是如我想象那般，完全自己构造的。</li>
<li>对于一个几乎没有高级字符串处理功能的C语言来说，这的确是一个苦活，但是正因为如此，才能接触到相对真实的<strong>HTTP服务器</strong>。<a id="more"></a>
<h2 id="首先">首先</h2></li>
</ul>
</li>
<li><p>每个人最开始学网络编程的时候，或者说几乎每本讲述网络编程的书籍，都会教你实现一个 <strong>echo</strong>程序，无论是<strong>TCP</strong>还是<strong>UDP</strong>， 当然这并不是说没有用，再复杂的网络程序，只要还是使用 套接字进行编程，那就不会走出这个最简单的模型</p>
<ul>
<li>服务器的 <code>socket-&gt;bind-&gt;listen-&gt;accept deal_event</code></li>
<li>客户端的 <code>socket-&gt;bind-&gt;connect      deal_event</code></li>
<li>这是<strong>TCP</strong>的，因为说的是HTTP服务器。</li>
</ul>
</li>
<li><p>HTTP服务器程序也是如此，由于HTTP协议支持几个标准的<strong>方法</strong>，但是一般的浏览器实现会实现两个： <code>GET, POST</code></p>
</li>
<li>用人话科普一下：<ul>
<li><code>GET</code>和<code>POST</code><strong>本质功能</strong>都是查询，只不过有时候用途不同，所以会造成某些人认为这两个的意义不同</li>
<li><code>GET</code> 很明确，就是提供了查询功能，如果使用它对服务器进行访问，那么它所要查询的信息会放在状态信息中： <code>GET /3/18/hello-world.html HTTP/1.1</code>。这就是每个浏览器向一个网站请求时，在成功建立 TCP 连接之后的<strong>第一条信息</strong>，也就是服务器可以从<strong>peer</strong>读取的第一条信息。<ul>
<li>其实<strong>HTTP</strong>协议并没有限制中间那个参数的长度！很多人认为的长度限制是<code>1024</code>，那只是你所用的浏览器的实现中，浏览器规定这个请求资源的参数长度不能超过<code>1024</code>，你要是自己做一个浏览器，你可以放长点。</li>
<li>就某些情况而言，用<code>GET</code>方法会让某些特殊用处<strong>参数</strong>显示在你的地址栏中，例如动态请求一些东西的时候，也就是我们在HTTP服务器中的一个叫做 <strong>CGI</strong>程序的概念。<ul>
<li><code>POST</code> 则是将请求放在报文段，这样就给了很多人误解，就是上面所说的<code>GET</code>所传的参数长度有限，而<code>POST</code>是几乎无限的。两个实际上没有差太多。至少在服务器这一端，只不过是获取参数的时候，方式稍微有些不同。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其次">其次</h2><ul>
<li>在用C写这个HTTP服务器的时候，有几个难点和遇到的磕磕绊绊，在这里记录一下</li>
</ul>
<h2 id="我所踩过的泥">我所踩过的泥</h2><h3 id="说在前头的程序配置">说在前头的程序配置</h3><ul>
<li>对于有网络编程经验的人来说，都不太陌生，哪怕只写过 <code>echo</code> 程序，那些服务器所必须的硬配置，也就是<strong>五元组</strong>里的<code>&lt;IP address, Port&gt;</code></li>
<li>好一些的教科书会告诉我们，将这两个参数硬编码进代码中，是不好的选择，一旦需要修改，调试，测试，就需要重新编译程序。<ul>
<li>所以，他们每次都通过命令行进行传递，并在程序中显式地进行转换。</li>
<li>稍有不慎，就是大错，而且这在调试的时候，十分不方便(还好<code>Shell</code>自带记录功能，不然更累)</li>
</ul>
</li>
<li>所以，在写一个大一些的网络程序之前，请务必写一个<strong>配置文件</strong>，再多花一个函数的时间，写一个能够处理它的小方法，这并不难，甚至还可以给它添上一些注释的小功能。</li>
<li><p>让自己的调试之路更加顺畅，那就用配置文件的形式进行传递参数，不然效率一定会被这个给拖住。</p>
<pre><code><span class="keyword">int</span> init_config(wsx_config_t * config){
    const <span class="keyword">char</span> ** roll = config_path_search;
    <span class="keyword">FILE</span> * <span class="keyword">file</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; roll[i] != <span class="keyword">NULL</span>; ++i) {
            <span class="keyword">file</span> = fopen(roll[i], <span class="string">"r"</span>);
            <span class="keyword">if</span> (<span class="keyword">file</span> != <span class="keyword">NULL</span>)
                <span class="keyword">break</span>;
    }
    <span class="keyword">char</span> buf[PATH_LENGTH] = {<span class="string">"\0"</span>};
    <span class="keyword">char</span> * ret;
    ret = fgets(buf, PATH_LENGTH, <span class="keyword">file</span>);
    <span class="keyword">while</span> (ret != <span class="keyword">NULL</span>) {
        <span class="keyword">char</span> * pos = strchr(buf, <span class="string">':'</span>);
        <span class="keyword">char</span> * check = strchr(buf, <span class="string">'#'</span>); <span class="comment">/* Start with # will be ignore */</span>
        <span class="keyword">if</span> (check != <span class="keyword">NULL</span>)
            *check = <span class="string">'\0'</span>;
        <span class="keyword">if</span> (pos != <span class="keyword">NULL</span>) {
            *pos++ = <span class="string">'\0'</span>;
            <span class="keyword">if</span> (<span class="number">0</span> == strncasecmp(buf, <span class="string">"thread"</span>, <span class="number">6</span>))
                sscanf(pos, <span class="string">"%d"</span>, &amp;config-&gt;core_num);
            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == strncasecmp(buf, <span class="string">"root"</span>, <span class="number">4</span>)) {
                sscanf(pos, <span class="string">"%s"</span>, &amp;config-&gt;root_path);
                    <span class="comment">/* End up without "/", Add it */</span>
                    <span class="keyword">if</span> ((config-&gt;root_path)[strlen(config-&gt;root_path)-<span class="number">1</span>] != <span class="string">'/'</span>)
                        strncat(config-&gt;root_path, <span class="string">"/"</span>, <span class="number">1</span>);
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == strncasecmp(buf, <span class="string">"port"</span>, <span class="number">4</span>))
                sscanf(pos, <span class="string">"%s"</span>, &amp;config-&gt;listen_port);
            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == strncasecmp(buf, <span class="string">"addr"</span>, <span class="number">4</span>))
                sscanf(pos, <span class="string">"%s"</span>, &amp;config-&gt;use_addr);
        }
        ret = fgets(buf, PATH_LENGTH, <span class="keyword">file</span>);
    }<span class="comment">/* while */</span>
    fclose(<span class="keyword">file</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
</ul>
<blockquote>
<p>对于配置文件的驳论， 个人认为只要让配置文件的规模不至于大到需要额外掌握就行，如果真像 <strong>Nginx</strong> 那样，我反而觉得欠妥</p>
</blockquote>
<h3 id="整个程序的构造">整个程序的构造</h3><ol>
<li>由于C语言没有像 Java 那样的包<code>import</code>机制，甚至连C++那样的<code>namespace</code>都没有。那对于C语言程序的整体把握，就都在程序员手里，如果没有办法做好模块化，那真的是世界上最可怕的事情</li>
<li><p>而对于C语言的模块化，唯一能起到作用的就是<strong>文件夹</strong>，没错就是强行做一波解释，让自己相信这就是隔离开的模块。但确实很有效果：有两种形式：</p>
<ol>
<li><strong>发布的库形式</strong> ： 将所有可提供向外的接口 API 分发在不同的头文件中(以功能作为模块划分的标准)，在根目录下建立 <code>include</code> 文件夹，将这些头文件都放进去。而源文件，以及一些自用的头文件放在根目录下的<code>src</code>文件夹中，<code>src</code>文件夹中再进行模块细分，例如<strong>内存管理(manage)</strong>，<strong>页面分发(http_page)</strong>之类的模块文件夹。</li>
<li><strong>工程形式</strong>： 就是消除<strong>include</strong>文件夹，只保留 <strong>src</strong>文件夹，不对外提供作为的API，可以让工作量减少，尽量的使用 <code>static</code> 来修饰函数。</li>
</ol>
</li>
<li><p>在目前阶段，先不要考虑使用外来库，对于一些不必要的库一定要自行编写，而不要采用第三方库，这样会提高编译成本。让用户使用体验降低。</p>
<ol>
<li>在后期可以考虑使用一些优化，强化的库，例如<code>tcmalloc/jemalloc</code>以及<code>ssl</code>的通信加密库之类的，而对于数据结构而言，千万要选择自行编写，而不应该依赖其他库例如<code>glib</code>之类的。</li>
<li>可以选择使用<strong>宏</strong>对标准库函数进行封装，这样提高程序的扩展性，这点体现在，随时可以通过宏来替换调用的版本，而不用在源码中大肆修改，一个最典型的例子就是内存分配的包装。(万恶的<code>realloc</code>)</li>
</ol>
</li>
</ol>
<h3 id="功能封装">功能封装</h3><ol>
<li><p>封装这个词，我也不知道起源何处，只是第一次听说是从面向对象里听来的，但是觉得就算是过程式的编程，也可以有这个方面的用处，当然不像那些概念说的那么严谨，我一直觉得功能拿来用就很好，不要墨守成规，虽然没有规矩不成方圆，但那对于程序员这种职业，如果思维都被限制了，那还怎么改变世界，对吧。</p>
<ol>
<li>就像数据结构<code>Trie</code>树，当初第一眼看到这个数据结构的时候，心里一直打鼓这什么东西，结果仅仅只是去百科了一下这个树的概念，脑海里立即浮现出这个树的构造来，就是每个节点一个字符，依次向下增长，空间换时间的意思，正好依此做了一个生命学院里DNA序列匹配的程序，还实现了一个很纯粹的<strong>KMP</strong>对比了一下，前后不过一天时间而已。</li>
<li>做东西还是不能被已有的事物左右，最起码一开始的时候不行，后期等你形成了自己的思路后再去参考别人的也不迟，就像当初学数据结构的时候，只知道链表的下一个节点指针就应该用本类型的指针指向，从未想过实现一个通用的链表，可以无所谓节点的类型，就能指向下一个节点(Linux内核链表实现)。</li>
<li>所有的一切都说明，思维不该被现有的模式所控制。</li>
</ol>
</li>
<li><p>要尽量将某些零散的功能进行合并，保持代码的模块化，而且容易维护，例如对于打开监听套接字这个功能</p>
<ol>
<li><p><code>socket-&gt;bind</code>，像这种代码就不需要整个塞在<code>main</code>函数里，那样的话错误处理代码会把真个函数挤满。而不如使用一个函数将这些代码包装起来，在 <code>main</code>中调用。</p>
<pre><code><span class="type">int</span> open_listenfd(<span class="keyword">const</span> <span class="type">char</span> * restrict host_addr, <span class="keyword">const</span> <span class="type">char</span> * restrict port, <span class="type">int</span> * restrict sock_type){
    <span class="type">int</span> listenfd = <span class="number">0</span>; /* listen the <span class="type">Port</span>, <span class="type">To</span> accept the new <span class="type">Connection</span> */
    struct addrinfo info_of_host;
    struct addrinfo * <span class="literal">result</span>;
    struct addrinfo * p;
    memset(&amp;info_of_host, <span class="number">0</span>, sizeof(info_of_host));
    info_of_host.ai_family = <span class="type">AF_UNSPEC</span>; /* <span class="type">Unknown</span> <span class="type">Socket</span> <span class="type">Type</span> */
    info_of_host.ai_flags = <span class="type">AI_PASSIVE</span>; /* <span class="type">Let</span> the <span class="type">Program</span> to help us fill the <span class="type">Message</span> we need */
    info_of_host.ai_socktype = <span class="type">SOCK_STREAM</span>; /* <span class="type">TCP</span> */

    <span class="type">int</span> error_code;
    <span class="keyword">if</span>(<span class="number">0</span> != (error_code = getaddrinfo(host_addr, port, &amp;info_of_host, &amp;<span class="literal">result</span>))){
        fputs(gai_strerror(error_code), <span class="literal">stderr</span>);
        <span class="keyword">return</span> <span class="type">ERR_GETADDRINFO</span>; /* -<span class="number">2</span> */
    }

    <span class="keyword">for</span>(p = <span class="literal">result</span>; p != <span class="type">NULL</span>; p = p-&gt;ai_next) {
        listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);

        <span class="keyword">if</span>(-<span class="number">1</span> == listenfd)
            <span class="keyword">continue</span>; /* <span class="type">Try</span> the <span class="type">Next</span> <span class="type">Possibility</span> */
        <span class="keyword">if</span>(-<span class="number">1</span> == <span class="keyword">bind</span>(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen)){
            close(listenfd);
            <span class="keyword">continue</span>; /* <span class="type">Same</span> <span class="type">Reason</span> */
        }
        <span class="keyword">break</span>; /* <span class="type">If</span> we get here, it means that we have succeed to <span class="keyword">do</span> all the <span class="type">Work</span> */
    }
    freeaddrinfo(<span class="literal">result</span>);
    <span class="keyword">if</span> (<span class="type">NULL</span> == p) {
    /* <span class="type">TODO</span> <span class="type">ERROR</span> <span class="type">HANDLE</span> */
        fprintf(<span class="literal">stderr</span>, <span class="string">"In %s, Line: %d\nError Occur while Open/Binding the listen fd\n"</span>,__FILE__, __LINE__);
        <span class="keyword">return</span> <span class="type">ERR_BINDIND</span>;
    }

    fprintf(<span class="literal">stderr</span>, <span class="string">"DEBUG MESG: Now We(%d) are in : %s , listen the %s port Success\n"</span>, listenfd, 
            inet_ntoa(((struct sockaddr_in *)p-&gt;ai_addr)-&gt;sin_addr), port);
    *sock_type = p-&gt;ai_family;
    set_nonblock(listenfd);
    optimizes(listenfd);
    <span class="keyword">return</span> listenfd;
}
</code></pre><p>这段代码就是对打开监听套接字的<code>socket-&gt;bind</code>的一个功能封装，使用的是 <code>getaddrinfo</code> 而不是传统的手工转换，降低了出错的概率而且更加可靠。</p>
<p>有一个问题就是，注释太多，没有必要，这个只是在编写过程中让我快速回溯自己的想法，所以写了许多注释。</p>
<p><code>set_nonblock</code> 和 <code>optimizes</code> 都是自己包装的函数，功能和名字一样。在用程序内信息Debug的时候，记得不要使用<code>stdout</code>，而使用<code>stderr</code>，并且在正式使用时，程序应该<strong>尽可能减少输出到终端</strong>，或者换句话说，到时候的服务器程序就应该把这三个描述符关闭(标准输出，标准输入，标准错误)</p>
</li>
</ol>
</li>
</ol>
<h3 id="未完待续，上课略累">未完待续，上课略累</h3><ul>
<li>具体项目源码 : <a href="https://github.com/wrestle/httpd3" target="_blank" rel="external">httpd3</a>·</li>
</ul>
<p>转载注明:<a href="http://www.wushxin.top/2016/03/23/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF%28%E4%B8%8A%29.html" target="_blank" rel="external">http://www.wushxin.top/2016/03/23/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF%28%E4%B8%8A%29.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.wushxin.top/2016/03/26/%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84C%E4%B9%8B%E8%B7%AF-%E4%B8%8B.html">一个HTTP服务器的C之路(下)</a></p>
<h3 id="记录近来写的HTTP服务器的_经历，坑，收获">记录近来写的HTTP服务器的 经历，坑，收获</h3><h2 id="万事皆有起因">万事皆有起因</h2><ul>
<li>大三了，又在反思自己和科班的差距，课少了，空闲时间突然多了起来，在这个大学里，这么一路走过来，自己摸索的不容易</li>
<li>天天看着浏览器的<strong>F12</strong>界面和 <strong>Wireshark</strong> 的抓取交互界面，突然想要自己做一个HTTP服务器，首先冷静了三天，发现这个念头依旧强烈，墙裂。</li>
<li>在翻看<strong>TCP/IP卷一协议</strong>无果后，于是我开始蹲点图书馆，借<strong>HTTP权威指南</strong> 和 <strong>图解HTTP</strong>，然而事与愿违，这个号称<strong>“黑龙江最大图书馆”</strong>称呼的学校图书馆竟无法找到这本书。行吧，那我不借了总行吧</li>
<li>回想起自己大二节选看的<strong>深入理解计算机操作系统(CSAPP)</strong>这本著名的书，似乎后面有一个Web服务器实现，虽然知道这大概是一个十分简陋的单处理的程序，但是对于理清自己思路很有帮助，特别是协议的交互</li>
<li>翻看一开，还真的有，说来惭愧前面的进程部分至今还是崭新的。首先看到了<strong>CGI</strong>，后来发现了后方的<strong>GET</strong>方法实现，大概了解了交互的过程，这之间在<strong>w3cschool</strong>查找了(恶补了一下HTTP状态码)一些HTTP的状态，以及<strong>维基百科</strong>里查看了HTTP报文的组成，当然最详细的还是使用WireShark抓取的交互包，而最简单明了的方法则是用 <strong>F12</strong>查看交互信息。</li>
<li><p>这之中有两个网站对我助力很大</p>
<ul>
<li><a href="http://www.softlab.ntua.gr/facilities/documentation/unix/unix-socket-faq/unix-socket-faq-2.html">Questions regarding both Clients and Servers</a></li>
<li><a href="http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t/14388707#14388707">Socket options SO_REUSEADDR and SO_REUSEPORT, how do they differ?</a></li>
</ul>
</li>
<li><p>Linux 的 <strong>man page</strong> 是另一个最有用的工具。</p>
</li>
</ul>
<h2 id="用C编写一个HTTP服务器？！">用C编写一个HTTP服务器？！</h2><ul>
<li>我说了这个想法给我的一个同学，他以为我疯了。</li>
<li>并没有，我在网上查了近来的许多模型，最后选择参考 <strong>事件驱动的epoll + 多线程</strong>进行实现，一方面直接避免了逻辑上的惊群现象，一方面也能充分利用多核。</li>
<li><p>我怎么想的，在最开始我对照着<strong>CSAPP</strong>对最开始的版本代码进行编写，不得不说里面有一个对系统调用(<code>read</code>, <code>write</code>)的调用在后面给我一个大坑，也给我很多思路上的启发。</p>
<ul>
<li>启发就在于，将系统调用进行自己的包装，可以提供很干净的C代码，并且可以进行良好功能的编写，这里特指对<strong>数据的缓存</strong>和<strong>错误处理</strong>，而这两个都是网络编程里的重头戏</li>
<li>大坑在于，我到后期发现，一个新的客户端在连接上本服务器之后，其信息应该尽可能集中，而不是分散在各处不同的结构体中，不容易维护，而且出了错还不容易发现。特别在于<strong>CSAPP</strong>中的 <code>rio</code>形式的读写封装，无法进行长久性的数据缓存，在这里长久性的数据缓存指的是，假设对端(<strong>peer</strong>)正忙，或者自己的TCP发送缓冲区已满，那这个数据要怎么办？</li>
</ul>
</li>
<li><p>不过读了<strong>CSAPP</strong>之后，最基本的服务器工作原理还是可以知道的，至少我看到了某些让我目瞪口呆的HTTP协议之间的交互方式。</p>
<ul>
<li>比如报文还真的是如我想象那般，完全自己构造的。</li>
<li>对于一个几乎没有高级字符串处理功能的C语言来说，这的确是一个苦活，但是正因为如此，才能接触到相对真实的<strong>HTTP服务器</strong>。]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
      <category term="分布式" scheme="http://www.wushxin.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="网络编程" scheme="http://www.wushxin.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用gdb]]></title>
    <link href="http://www.wushxin.top/2016/03/19/%E4%BD%BF%E7%94%A8gdb.html"/>
    <id>http://www.wushxin.top/2016/03/19/使用gdb.html</id>
    <published>2016-03-19T06:47:18.000Z</published>
    <updated>2016-08-03T06:25:28.973Z</updated>
    <content type="html"><![CDATA[<h2 id="开始">开始</h2><ul>
<li>近来在写网络服务器程序，涉及到了多线程，且由于网络的环境复杂的原因，常有未知情况发生，导致在程序中自行添加调试语句显得有些吃力</li>
<li>将 <code>gdb</code> 请出山来是一个最为正确的选择</li>
</ul>
<h2 id="使用">使用</h2><ul>
<li><code>gdb</code>看起来是全命令行的东西，而且一启动就是一大片英文，实在让没用过的望而却步，其实真正常用的就只有那几个功能。</li>
<li>接下来我可能不会对这些命令进行明确的定义功能，因为有时候某些功能放在不同的地方意义就不同了，所以我只用最简单的语言来记录它们。</li>
</ul>
<ol>
<li><p>首先是安装，在(<strong>Debian</strong>)系的发行版 <strong>Linux</strong> 上，使用</p>
<pre><code>apt-<span class="keyword">get</span> install gdb
</code></pre><p> 回车等一会就行，可能有的发行版已经装好了，但有的却没有。</p>
</li>
<li><p>首先不要打开这个<code>gdb</code>，因为这里面的东西的确看起来挺复杂的</p>
</li>
<li>我们要先有一个程序的源文件，假设是 <strong>C语言</strong> 的 <code>main.c</code></li>
<li><p>在里面写好正确的语句后，对它进行编译，链接，也就是调用 <code>GCC</code>，这里使用<code>GCC</code>的命令是</p>
<pre><code>gcc -o <span class="keyword">main</span> -g <span class="keyword">main</span>.c
</code></pre><p> 这个 <code>-g</code> 标志非常必要，意味着生成一些<strong>符号信息</strong>，用人话说就是 <code>gdb</code> 所需要的东西，没有这个东西是无法使用 <code>gdb</code>进行调试的。</p>
</li>
<li><p>紧接着，在当前目录下就有一个名为 <code>main</code> 的可执行文件，看好当前用户是否有权限执行它之后，使用如下命令开启调试旅程：<a id="more"></a></p>
<pre><code><span class="title">gdb</span> ./main
</code></pre><p> 紧接着，出现一大堆英文，不要慌，静静的等待它们装逼，最后会出现一个</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> 
</code></pre><p> 光标在闪烁的时候，就证明 <code>gdb</code> 加载这个程序的符号信息完毕，你可以准备执行了</p>
</li>
<li><p>这时候，你只要输入一个字母 <code>r</code>， 就能让这个<code>main</code>程序执行起来</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> r
</code></pre></li>
<li><p>如果这个程序没有问题的话，几乎就和在外面正常运行时一样，<code>gdb</code>没有起到任何作用，但是一旦有任何问题的话，<code>gdb</code>就会暂停在那个出错的地方，而不是继续执行。</p>
<ol>
<li>这里说的出错，不一定代表着就是程序出错或者崩溃退出，有可能是程序接收到了某个信号，信号在<code>Linux</code>中并不少见，这对于某些特殊用途的程序而言，看到接收到的信号十分重要，例如网络程序。</li>
</ol>
</li>
<li><p>对于 <code>r</code> 这个命令除了这么孤零零的使用以外，还可以对它进行传递参数，例如你的<code>main</code>程序需要两个参数，你可以这样</p>
<pre><code><span class="comment">(gdb)</span> r <span class="number">192.168.</span><span class="number">141.149</span> <span class="number">8889</span>
</code></pre><p> 这就和在外面使用:</p>
<pre><code>./<span class="keyword">main</span> <span class="number">192.168</span>.<span class="number">141.149</span> <span class="number">8889</span> 
</code></pre><p> 的效果一样</p>
</li>
<li><p>第二个命令自然是，最常用的设置断点，这也是十分简单， 命令就一个字母 <code>b</code></p>
<ol>
<li><p>最简单的用法就是直接接着一个数字，代表着要设置断点的地点(<strong>行</strong>)，例如</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> b <span class="number">10</span>
</code></pre><p> 表示在当前的执行文件中的第十行设置一个断点，设置完了会有成功信息：</p>
<pre><code>Breakpoint <span class="number">1</span> <span class="keyword">at</span> <span class="number">0x400556</span>: <span class="built_in">file</span> main.c, <span class="built_in">line</span> <span class="number">10.</span> 
</code></pre><p> 意思就是，设置了第一个断点，在内存位置<code>0x400556</code>地方，人类能懂得地方在 <strong>main.c 文件的第十行</strong></p>
</li>
<li><p>另一种情况就是，当你的程序是多个文件编译而成的时候，你如果不指定文件名，那么<strong>默认就是在当前执行的这个地方所属的文件里设定</strong></p>
<pre><code>(gdb) <span class="tag">b</span> main<span class="class">.c</span>:<span class="number">10</span>
</code></pre><p> 这就是完整的语法，十分简单，这就是设置断点最常用的方式</p>
</li>
<li><p>当然，你也可以直接以函数的名字作为断点，来进行设置</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> b main
</code></pre></li>
<li>但是在执行的时候，我怎么能记得住我要在哪里设置断点？难道要背下来？这里有几个方法可以参考一下。<ol>
<li>首先当然就是你事先已经有一个完整的调试计划，记下在哪里设置断点自然是万事大吉</li>
<li>但通常由于程序员的自信小宇宙，我们坚信自己的程序是完美的，所以会先执行程序，在这个过程中假设我们碰到一个<strong>错误</strong>，<code>gdb</code>帮我们及时停了下来，我们可以借助三个常用命令(后面写到)来帮助我们知道，自己现在身处何处，再设置断点</li>
</ol>
</li>
</ol>
</li>
<li>上面说到的<strong>三个常用命令</strong>之</li>
<li><p>一，二 <code>where</code>，<code>bt</code></p>
<ol>
<li>之所以放在一起，因为这两个命令的意义差不多，至少在用的时候是这样，都是显示出当前执行位置的<strong>函数栈</strong>，这对调试十分重要，所谓函数栈就是我们当前进入到哪个函数了，如果程序的函数嵌套挺深的时候，就能够用它来理清思路</li>
<li><p>并且这里说的函数栈并不只限于 <strong>程序员编写的函数</strong>，还包括所调用的系统函数。</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> where
</code></pre><p> 直接在光标处写就行，写完回车就能够看见函数栈，但是如果你的函数嵌套过深这也不是一个好办法，但聊胜于无</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> bt
</code></pre><p> 与上方一致。输出信息大概是这样（用我调试网络程序时收到一个SIGPIPE的情况为例）</p>
<pre><code><span class="id">#0</span>  <span class="tag">0x00007ffff727cbc0</span> <span class="tag">in</span> <span class="tag">__write_nocancel</span> ()
<span class="tag">at</span> ../<span class="tag">sysdeps</span>/<span class="tag">unix</span>/<span class="tag">syscall-template</span><span class="class">.S</span><span class="pseudo">:81</span>
<span class="id">#1</span>  <span class="tag">0x0000000000401ea6</span> <span class="tag">in</span> <span class="tag">write_n</span> (handle=<span class="number">5</span>, 
out_buf=<span class="number">0</span>x7fffffff1a10 "Http/<span class="number">1.0</span> <span class="number">200</span> OK\r\<span class="attribute">nServer</span>: Wu
shxin HTTP Server\r\<span class="attribute">nContent-length</span>: <span class="number">276</span>\r\<span class="attribute">nContent-type</span>:
text/html\r\n\r\n", buf_len=<span class="number">94</span>)
<span class="tag">at</span> /<span class="tag">root</span>/<span class="tag">ClionProjects</span>/<span class="tag">httpd2</span>/<span class="tag">iofunc</span><span class="class">.cpp</span><span class="pseudo">:68</span>
<span class="id">#2</span>  <span class="tag">0x0000000000402657</span> <span class="tag">in</span> <span class="tag">serve_static</span> (client_fd=<span class="number">5</span>, 
filename=<span class="number">0</span>x7fffffff9a80 <span class="string">"./home.html"</span>, file_size=<span class="number">276</span>)
<span class="tag">at</span> /<span class="tag">root</span>/<span class="tag">ClionProjects</span>/<span class="tag">httpd2</span>/<span class="tag">deal_client</span>/<span class="tag">server_static</span><span class="class">.cpp</span><span class="pseudo">:37</span>
<span class="id">#3</span>  <span class="tag">0x00000000004021b4</span> <span class="tag">in</span> <span class="tag">deal_client</span> (client_fd=<span class="number">5</span>)
<span class="tag">at</span> /<span class="tag">root</span>/<span class="tag">ClionProjects</span>/<span class="tag">httpd2</span>/<span class="tag">deal_client</span>/<span class="tag">dealclient</span><span class="class">.cpp</span><span class="pseudo">:77</span>
<span class="id">#4</span>  <span class="tag">0x0000000000401cac</span> <span class="tag">in</span> <span class="tag">deal_server</span> (listen_fd=<span class="number">3</span>, listen_fd_type=<span class="number">2</span>)
<span class="tag">at</span> /<span class="tag">root</span>/<span class="tag">ClionProjects</span>/<span class="tag">httpd2</span>/<span class="tag">server</span><span class="class">.cpp</span><span class="pseudo">:154</span>
<span class="id">#5</span>  <span class="tag">0x00000000004017c4</span> <span class="tag">in</span> <span class="tag">main</span> (argc=<span class="number">3</span>, argv=<span class="number">0</span>x7fffffffe1b8)
<span class="tag">at</span> /<span class="tag">root</span>/<span class="tag">ClionProjects</span>/<span class="tag">httpd2</span>/<span class="tag">main</span><span class="class">.cpp</span><span class="pseudo">:31</span>
</code></pre><p> 稍微有点长，但是还是很清楚的，每个 <code>#</code> 后面是一个栈， 括号中是参数名和参数真实值。</p>
</li>
<li>稍微分析一下就能大概确定断点应该设置在什么地方，如果觉得栈太深，可以在某些栈的入口处设断点，好好分析，但总归函数嵌套太深就是模块化做的不好。（<strong>比如我这个程序就是。所以推倒重构了。</strong>，都是泪，写程序前一定要先画好构造图，不然会越写越复杂，写的时候不要想着做更多的事，而要做好一件事。）</li>
</ol>
</li>
<li><p>三个常用的最后一个就是 <code>list</code></p>
<ol>
<li><p>在你运行到某处，被 <code>gdb</code>停下来的时候，除了使用 <code>where</code>或者<code>bt</code>，总体浏览一下函数栈，还能具体的查看一下现在执行到哪行代码了</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> list
</code></pre><p> 当然这个可能对系统函数没什么作用，因为它可能会显示：</p>
<pre><code><span class="number">76</span>      <span class="keyword">in</span> ../sysdeps/unix/syscall-<span class="keyword">template</span>.S
</code></pre><p> 这个时候你就需要去它的上一层中查看错误了，但正常情况下，<code>list</code>会将你所执行位置语句的上下几行一起显示出来。</p>
</li>
</ol>
</li>
<li><p>回到最开始的<code>r</code>命令，现在可以知道它是让程序开始执行的命令，那么和他有相似效果，但是用处不同的另外两个命令分别是 <code>c</code> 和 <code>n</code></p>
</li>
<li><code>c</code>代表着 <code>continue</code>，也就是忽略这个断点或者错误继续执行的意思(比如收到某个信号)</li>
<li><p><code>n</code>代表着 <code>next</code>， 也就是执行到下一条语句，然后暂停。</p>
</li>
<li><p>最后就是怎么退出 <code>gdb</code></p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> q
</code></pre><p>就行了。</p>
</li>
</ol>
<h4 id="小结">小结</h4><ul>
<li><code>r &lt;para1&gt; ...</code>是运行程序 </li>
<li><code>c</code> 是继续运行程序</li>
<li><code>n</code> 是执行下一条语句</li>
<li><code>where</code> 和 <code>bt</code> 是显示函数栈</li>
<li><code>list</code> 是显示当前运行语句的上下文(<strong>此上下文非操作系统概念中的上下文</strong>)</li>
<li><code>q</code> 是退出 <code>gdb</code>调试</li>
<li>这些就是最常用的几个单线程的调试方式，没错单线程。<blockquote>
<p>以上是逻辑清晰的 单线程/单进程 程序的调试，其实多进程/多线程的调试也是差不多的类型</p>
</blockquote>
</li>
</ul>
<h3 id="多进程/多线程的调试">多进程/多线程的调试</h3><ul>
<li>两个除了操作上有些命令不同，实质上的调试思想是差不多的，都是“变量控制”的方法。</li>
<li><p>有个命令首先要说： <code>attach</code></p>
<ul>
<li>这是用来调试多进程的命令，想要调试多进程的程序，会稍微麻烦一些，首先要启动程序(不需要加载到<code>gdb</code>中)，启动后，在<code>shell</code>中用<code>ps</code>命令查看该进程延伸出的子进程，并且记下<strong>子进程的进程号</strong></li>
<li><p>启动 <code>gdb</code>，并且使用<code>attach</code>，假设要调试的进程号是 <code>4488</code></p>
<pre><code>$ gdb
<span class="keyword">...</span>
(gdb) <span class="keyword">attach</span> <span class="number">4488</span>
<span class="comment"># ... 加载符号信息</span>
<span class="comment"># 加载完毕后，会停在有光标的状态，这时候你可以设置断点，或者选择继续</span>
(gdb) <span class="keyword">...</span>
</code></pre></li>
</ul>
</li>
<li><p>当然，如果一开始只有一个进程，但是在你调试的某个过程中会有 <code>fork</code> 操作，这时候可以使用另一个命令来明确说明要继续跟踪父进程还是调试子进程</p>
<pre><code>(gdb) <span class="keyword">set</span> follow-fork-<span class="built_in">mode</span> child
</code></pre><p>  这个命令有点长，不太好记，可以抄写在某个地方，用到的时候再看(我就是如此)</p>
<p>  与之对应的自然就是 <code>set follow-fork-mode parent</code></p>
</li>
<li><p>多线程，也很类似</p>
<ul>
<li>两个重要的命令先说 <code>info threads</code> 和 <code>thread &lt;ID&gt;</code></li>
<li><code>info threads</code> 是显示当前程序的所有线程信息，并且会给每个线程配上一个相应的<code>ID</code>，也就是第一列显示的<code>ID</code>，而不是后面显示的。</li>
<li>使用这个<code>ID</code>可以在调试线程之间进行切换</li>
<li><p>切换的命令则是<code>thread</code></p>
<pre><code>(gdb) info threads
Id   Target Id         Frame                   
* <span class="number">1</span>    <span class="built_in">process</span> <span class="number">19515</span> <span class="string">"main"</span> main (argc=<span class="number">1</span>,   
argv=<span class="number">0x7fffffffe1f8</span>) <span class="keyword">at</span> main.c:<span class="number">12</span> 
...
</code></pre></li>
<li><p>当前线程前方会有一个 <code>*</code> 显示。</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> thread <span class="number">2</span>
</code></pre><p>  表示切换到 2 号线程调试</p>
</li>
</ul>
</li>
<li><p>最后，关于多线程调试有一个高级一点的命令，就是如果我们在调试的时候，不希望其它线程运行而干扰到本线程的调试，可以使用 </p>
<pre><code>(gdb) <span class="keyword">set</span> scheduler-locking <span class="function_start"><span class="keyword">on</span></span>
</code></pre><p>  这样一来就只有所调试的线程才会执行，对于这个命令的其他两个参数 <code>off</code> 和 <code>step</code><br>  分别是<strong>关闭这个功能</strong> 和 <strong>单步执行(<code>n</code>)情况下才不允许其他线程运行</strong> 的效果。</p>
</li>
</ul>
<h2 id="总结">总结</h2><ul>
<li>以上便是全部<code>gdb</code>常用的操作，记住了他们也就能满足绝大部分的调试工作了，比带图形界面的调试器更有效率。</li>
</ul>
<h2 id="实用">实用</h2><ul>
<li>当调试一个程序的时候，往往不是只看表象就能解决的，有时候需要深入到某个栈的某个变量的值，查看是否违背了原先的意义。</li>
<li><p>这时候需要的就是<code>gdb</code>的 <code>info</code>功能，以及有时候需要在前序栈中进行查看，就需要<code>frame</code>功能的配合。</p>
</li>
<li><p>假设有一个程序：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">func_2</span><span class="params">(<span class="keyword">int</span> arg_2)</span> </span>{
    <span class="keyword">int</span> in_func_2_1 = <span class="number">22</span>;
    <span class="keyword">int</span> in_func_2_2 = arg_2;
    <span class="keyword">return</span> in_func_2_1 + in_func_2_2;
}
<span class="function"><span class="keyword">int</span> <span class="title">func_1</span><span class="params">(<span class="keyword">int</span> arg_1)</span> </span>{
    <span class="keyword">int</span> in_func_1_1 = <span class="number">11</span>;
    <span class="keyword">int</span> in_func_1_2 = arg_1;
    <span class="keyword">return</span> func_2(in_func_1_1 + in_func_1_2);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>{
<span class="built_in">printf</span>(<span class="string">"The result is %d\n"</span>, func_1(<span class="number">0</span>));
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>  将这个程序编译，记得带上 <code>-g</code>，并用<code>gdb</code>打开</p>
<p>  设置断点 <code>b func_1</code>, <code>b func_2</code></p>
</li>
<li><p>设置完成之后，<code>r</code>运行，程序停在了第一个断点，也就是<code>func_1</code>的入口处，这时候使用<code>bt</code>查看一下栈的情况</p>
<pre><code>Breakpoint <span class="number">1</span>, func_1 (<span class="variable">arg_1=</span><span class="number">0</span>) at main.c:<span class="number">10</span>
<span class="number">10</span>        int <span class="variable">in_func_1_1 =</span> <span class="number">11</span>;
(gdb) info locals
<span class="variable">in_func_1_1 =</span> <span class="number">0</span>
<span class="variable">in_func_1_2 =</span> <span class="number">0</span>
</code></pre><p>  这时候使用了<code>info locals</code>，可以显示出这个函数中创建的本地变量的值，看到两个值都是零，这只是偶然而已，很有可能是其他的垃圾值。继续使用命令<code>n</code></p>
<pre><code>(gdb) n
<span class="number">11</span>        int <span class="keyword">in</span>_func_1_2 = arg_1;
(gdb) info <span class="built_in">local</span>
<span class="keyword">in</span>_func_1_1 = <span class="number">11</span>
<span class="keyword">in</span>_func_1_2 = <span class="number">0</span>
</code></pre><p>  发现执行到第11行，<code>in_func_1_1</code>被赋值，为<code>11</code>,这就是常用的调试手法，那接着使用<code>c</code>命令，继续运行。</p>
<pre><code>(gdb) c
Continuing.

Breakpoint <span class="number">2</span>, func_2 (arg_2=<span class="number">11</span>) <span class="preprocessor">at</span> main.c:<span class="number">5</span>
<span class="number">5</span>        <span class="keyword">int</span> in_func_2_1 = <span class="number">22</span><span class="comment">;</span>
(gdb) info local
in_func_2_1 = <span class="number">32767</span>
in_func_2_2 = -<span class="number">134253376</span>
(gdb) n
<span class="number">6</span>        <span class="keyword">int</span> in_func_2_2 = arg_2<span class="comment">;</span>
(gdb) info locals
in_func_2_1 = <span class="number">22</span>
in_func_2_2 = -<span class="number">134253376</span>
(gdb) <span class="keyword">bt</span>
#<span class="number">0</span>  func_2 (arg_2=<span class="number">11</span>) <span class="preprocessor">at</span> main.c:<span class="number">6</span>
#<span class="number">1</span>  <span class="number">0x000000000040052b</span> <span class="keyword">in</span> func_1 (arg_1=<span class="number">0</span>) <span class="preprocessor">at</span> main.c:<span class="number">12</span>
#<span class="number">2</span>  <span class="number">0x0000000000400546</span> <span class="keyword">in</span> main (argc=<span class="number">1</span>, argv=<span class="number">0x7fffffffe228</span>) <span class="preprocessor">at</span> main.c:<span class="number">16</span>
</code></pre><p>  此处的<code>info local</code> 和 <code>info locals</code> 的效果一样，看来<code>gdb</code>也懂得程序员不容易，允许我们脑子放松一些。还有在<code>gdb</code>中是可以使用<code>Tab</code>键的补全功能的。</p>
<p>  此处和上方的效果一致，就不再叙述，重点是，现在我使用<code>bt</code>命令发现，身处三重函数栈的第<code>0</code>层（最顶层）之中，也就是当先的函数<code>func_2</code>之中，但是我现在却想要看到<code>func_1</code>里面的信息怎么办？</p>
<p>  很简单，就是使用<code>frame</code></p>
<pre><code>(gdb) frame <span class="number">1</span>
<span class="comment">#1  0x000000000040052b in func_1 (arg_1=0) at main.c:12</span>
<span class="number">12</span>        <span class="built_in">return</span> func_2(<span class="keyword">in</span>_func_1_1 + <span class="keyword">in</span>_func_1_2);
(gdb) info locals
<span class="keyword">in</span>_func_1_1 = <span class="number">11</span>
<span class="keyword">in</span>_func_1_2 = <span class="number">0</span>
</code></pre><p>  这样我们就回到了编号为 <code>1</code> 的栈中，且当前状态就是调用<code>func_2</code>的时候，此时再使用<code>info locals</code>就可以看见这个栈中的各种参数了</p>
</li>
<li><p>这里少了实参的查看，其实很简单： <code>info args</code></p>
<pre><code>(gdb) info ar
arg_1 = <span class="number">0</span>
(gdb) <span class="tag">p</span> arg_1
$<span class="number">1</span> = <span class="number">0</span>
</code></pre><p>  当然也可以用<code>p</code>直接打印了。其实<code>info</code>还有很多其他功能，是很多。可以在<code>gdb</code>中使用<code>info</code>直接查询，像这样</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> info
</code></pre><p>  回车之后</p>
<pre><code>List <span class="keyword">of</span> info subcommands:

info address -- Describe <span class="keyword">where</span> symbol SYM <span class="keyword">is</span> stored
info all-registers -- List <span class="keyword">of</span> all registers <span class="keyword">and</span> their contents
info args -- Argument variables <span class="keyword">of</span> current stack frame
info <span class="keyword">auto</span>-load -- Print current status <span class="keyword">of</span> <span class="keyword">auto</span>-loaded files
info <span class="keyword">auto</span>-load-scripts -- Print the list <span class="keyword">of</span> automatically loaded Python scripts
info auxv -- Display the inferior<span class="comment">'s auxiliary vector</span>
info bookmarks -- Status <span class="keyword">of</span> user-settable bookmarks
info breakpoints -- Status <span class="keyword">of</span> specified breakpoints (all user-settable 
......
---Type &lt;<span class="keyword">return</span>&gt; <span class="keyword">to</span> <span class="keyword">continue</span>, <span class="keyword">or</span> q &lt;<span class="keyword">return</span>&gt; <span class="keyword">to</span> quit---
</code></pre><p>  还有很多没贴上来，可以自行查看。</p>
</li>
</ul>
<p>转载注明: <a href="http://www.wushxin.top/2016/03/19/%E4%BD%BF%E7%94%A8gdb.html" target="_blank" rel="external">http://www.wushxin.top/2016/03/19/%E4%BD%BF%E7%94%A8gdb.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="开始">开始</h2><ul>
<li>近来在写网络服务器程序，涉及到了多线程，且由于网络的环境复杂的原因，常有未知情况发生，导致在程序中自行添加调试语句显得有些吃力</li>
<li>将 <code>gdb</code> 请出山来是一个最为正确的选择</li>
</ul>
<h2 id="使用">使用</h2><ul>
<li><code>gdb</code>看起来是全命令行的东西，而且一启动就是一大片英文，实在让没用过的望而却步，其实真正常用的就只有那几个功能。</li>
<li>接下来我可能不会对这些命令进行明确的定义功能，因为有时候某些功能放在不同的地方意义就不同了，所以我只用最简单的语言来记录它们。</li>
</ul>
<ol>
<li><p>首先是安装，在(<strong>Debian</strong>)系的发行版 <strong>Linux</strong> 上，使用</p>
<pre><code>apt-<span class="keyword">get</span> install gdb
</code></pre><p> 回车等一会就行，可能有的发行版已经装好了，但有的却没有。</p>
</li>
<li><p>首先不要打开这个<code>gdb</code>，因为这里面的东西的确看起来挺复杂的</p>
</li>
<li>我们要先有一个程序的源文件，假设是 <strong>C语言</strong> 的 <code>main.c</code></li>
<li><p>在里面写好正确的语句后，对它进行编译，链接，也就是调用 <code>GCC</code>，这里使用<code>GCC</code>的命令是</p>
<pre><code>gcc -o <span class="keyword">main</span> -g <span class="keyword">main</span>.c
</code></pre><p> 这个 <code>-g</code> 标志非常必要，意味着生成一些<strong>符号信息</strong>，用人话说就是 <code>gdb</code> 所需要的东西，没有这个东西是无法使用 <code>gdb</code>进行调试的。</p>
</li>
<li><p>紧接着，在当前目录下就有一个名为 <code>main</code> 的可执行文件，看好当前用户是否有权限执行它之后，使用如下命令开启调试旅程：]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
      <category term="GDB" scheme="http://www.wushxin.top/tags/GDB/"/>
    
      <category term="Linux" scheme="http://www.wushxin.top/tags/Linux/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective Modern Cpp 概述（二）]]></title>
    <link href="http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-概述（二）.html</id>
    <published>2016-02-22T01:29:50.000Z</published>
    <updated>2016-03-25T00:01:49.732Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>(Item 15)</p>
</blockquote>
<h3 id="Item_12_-_Declare_overriding_functions_override-">Item 12 - Declare overriding functions override.</h3><ul>
<li><p>介绍了一个鲜为人知的 <strong>C++11</strong> 新特性，针对一个类成员函数的</p>
<pre><code><span class="keyword">class</span> <span class="title">Widget</span> {
<span class="keyword">public</span>:
  ...
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;   <span class="comment">// 只有当 *this 是 lvalue 时才调用</span>
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;  <span class="comment">// 只有当 *this 是 rvalue 时才调用</span>
};
...
<span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// 制造一个临时的 Widget</span>
<span class="comment">// 调用</span>
Widget w; <span class="comment">// 默认构造函数创建</span>
w.doWork(); <span class="comment">// 调用第一个版本(lvalue)</span>
makeWidget().doWork(); <span class="comment">// 调用第二个版本</span>
</code></pre></li>
<li><p>对于 <strong>重写</strong> 和 <strong>重载</strong>，这两个极易混淆，或者说不是混淆而是十分容易不小心就写错了，的功能，在 <strong>C++98</strong> 之前我们只能选择相信程序员写下的代码是准确无误的。有几个判断 <strong>重写</strong> 的条件</p>
<ol>
<li>基类里的该函数必须是 <code>virtual</code></li>
<li>基类里的该函数和派生类里的该函数的 <strong>函数名</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>参数类型</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>返回值类型</strong> 必须相同或者可以<strong>兼容(即继承关系)</strong></li>
<li>基类里的该函数和派生类里的该函数的 <code>const</code> 属性必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>引用限定词</strong> 必须相同(<strong>C++11新增</strong>)<a id="more"></a></li>
</ol>
</li>
<li><p>上述关系缺一不可。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;  <span class="comment">// C++11 </span>
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;
};
<span class="comment">// C++98</span>
<span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">public</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(unsigned <span class="keyword">int</span> x)</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;
};        
<span class="comment">// C++11</span>
<span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">public</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(unsigned <span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;
  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;
};
</code></pre><p>  其中 <code>Derived</code> 类中的 <strong>重写</strong> 函数前面的 <code>virtual</code> 不是强制性要求。相比于<strong>C++98</strong> 而言对了一个关键字<code>override</code>，其作用就是帮助我们在编译期检查到是否在重写的时候出了差错</p>
<p>  <strong>C++98</strong> 版本的<code>mf2</code>函数可以通过编译，但是 <strong>C++11</strong> 版本的<code>mf2</code>函数便无法通过编译，因为<code>override</code>告诉编译器这是一个<strong>重写</strong>函数，但是实际上我们的 <code>mf2</code> 并不符合要求。</p>
</li>
<li><code>override</code>的作用便在于让编译器替我们检查错误，并且在实现一个工程时，往往需要改变某个函数来修改原有的内容业务，这时候可以借助编译器的<strong>错误提示</strong>看看修改这个函数，会对整个工程造成多大的影响，以及是否值得如此做。</li>
<li><p>对于新的 <strong>引用限定词</strong> 的用法，大体上会用在判断 <strong>lvalue</strong> 和 <strong>rvalue</strong> 上，其目的是为了避免某些不必要的开销，而不是依赖 <strong>编译器优化</strong> 这种虚无飘渺的说法。</p>
<pre><code><span class="keyword">class</span> Widget {
<span class="keyword">public</span>:
  <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;
  ...
DataType&amp; data() &amp; { <span class="keyword">return</span> values; }
<span class="function">DataType  <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::move(values); }
...

<span class="keyword">private</span>:
  DataType values;
};
</code></pre><p> 可以很明显的看出，两个版本的<code>data</code>函数，是为了适应不同情况下对于 <code>values</code>的使用。</p>
</li>
</ul>
<h3 id="Item_13_-_Prefer_const_iterators_to_iterators">Item 13 - Prefer const_iterators to iterators</h3><ul>
<li>很简短，尽量去使用 <code>const_iterator</code>，原因就是安全。</li>
<li><p><strong>C++11</strong> 提供了十分简便(还不够完善)的获取上限</p>
<ol>
<li>容器中自带的 <code>begin(), end()</code> 和 <code>cbegin(), cend()</code> ……</li>
<li>非容器自带(非成员函数) <code>std::begin&lt;...&gt;(), std::end&lt;...&gt;()</code></li>
<li>在 <strong>C++14</strong> 中补全了对 <strong>1</strong> 的非容器实现</li>
</ol>
</li>
<li><p>更加建议使用 非容器的版本。</p>
</li>
</ul>
<h3 id="Item_14_-_Declare_functions_noexcept_if_they_won’t_emit_exceptions">Item 14 - Declare functions noexcept if they won’t emit exceptions</h3><ul>
<li><code>noexcept</code> 是 <strong>C++11</strong> 新的标准语法</li>
<li><code>noexcept</code> 的意义就是，告诉编译器这个函数绝对不会抛出异常。</li>
<li>让一个函数成为 <code>noexcept</code> 会让编译器对它做<strong>极大的优化</strong>，但是这并不是建议你尽量的使用<code>noexcept</code>，你必须谨慎再谨慎的使用它</li>
</ul>
<blockquote>
<p><code>noexcept</code> 对于 <strong>移动语义</strong>，<strong>swap函数</strong>，<strong>delete</strong>，和 <strong>析构函数</strong>十分有意义，后两者一般情况下就是 <code>noexcept</code>。</p>
</blockquote>
<ul>
<li>但事实上，大部分函数是 <strong>“中立的”</strong>，也就是不清楚是否会抛出异常<ul>
<li>因为有时候写一个函数时，会调用其他函数，这个被调用的函数是否会抛出异常，往往无从得知。</li>
</ul>
</li>
<li><p><code>noexcept</code>是作为函数接口的一部分 <code>int f(int x) noexcept;</code></p>
<ul>
<li>在<strong>C++98</strong>时代，有一种同样意义(效果不同)的写法 <code>int f(int x) throw();</code></li>
<li>但这种看似等价的写法并不能让编译器对其进行极大的优化。<blockquote>
<p>优化指的是<code>noexcept</code>可以让编译器不为这个函数维护一个 <strong>runtime stack</strong>，且不必确保按照创建对象相反的顺序销毁对象。 </p>
</blockquote>
</li>
</ul>
</li>
<li><p>首先，是对于<strong>移动语义</strong>和<code>swap</code>函数而言，<code>noexcept</code>意义非凡</p>
<ul>
<li>移动语义也就是<strong>C++11</strong>新的特性，右值引用的意义所在，众所周知它可能会带来极大的性能提升，例如在拷贝一组不小的数据时。</li>
<li>但问题就在于<strong>“拷贝”</strong>这组数据时(实际上应该说是移动它们)，假如在移动的过程中突然发生异常那该如何？因为是移动，而不是拷贝，<strong>所以之前移动的那部分数据就算是丢失了！</strong></li>
<li>相比较而言，拷贝的做法就较为妥当，因为不管会不会在拷贝过程中发生异常，原始数据始终是不会丢失的。</li>
<li>所以我们必须确保 <strong>移动操作</strong> 是 <code>noexcept</code>，这样它才能在必要时对<strong>拷贝构造函数</strong>进行替换，以此来达到提升性能的作用。</li>
<li>例如对一个容器(<code>std::vector</code>)进行<code>push_back</code>操作，编译器除非能确定操作对象的<strong>移动操作</strong>是<code>noexcept</code>的，否则是不会<strong>默默(隐式)</strong> 地将<strong>拷贝换成移动</strong>。</li>
</ul>
</li>
<li><p>其次 <code>swap</code> 函数也是如此</p>
<pre><code>// 只有当swap数组中的元素是noexcept，这个函数才是noexcept
<span class="keyword">template</span> &lt;class T, size_t N&gt;
<span class="type">void</span> swap(T (&amp;a)[N]),
          T (@b)[N])noexcept(noexcept(swap(*a, *b)));

//只有当对pair内部元素进行swap是noexcept时，对pair进行swap才是noexcept
<span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span>&gt;
struct pair {
    ...
    <span class="type">void</span> swap(pair&amp; p)noexcept(noexcept(swap(first, p.first)) &amp;&amp;
                                  noexcept(swap(second, p.second)));
};
</code></pre><p>  这段代码出自 <strong>标准库</strong>，这种语法的意思就是，只有当<code>noexcept</code>括号内的是<code>noexcept</code>时，才是<code>noexcept</code>，绕口却好理解。</p>
<p>  总结起来就是，对高级封装的数据结构进行操作的<code>swap</code>函数是否是<code>noexcept</code>，取决于这个高级封装的数据结构内部的成员是否对于<code>swap</code>操作是<code>noexcept</code>(并且是对于每一成员都必须成立)</p>
</li>
<li><p>如果硬是把一个不确定的函数，设定为<code>except</code>，那是在是有些本末倒置，但对于<strong>移动语义</strong>和<code>swap</code>函数而言，却是一个很有意义的做法。</p>
</li>
<li>总之本节最主要的目的就是，当我们十分确定某个函数一定不会抛出异常，那就让它成为<code>noexcept</code>。</li>
</ul>
<h3 id="Item_15_-_Use_constexpr_whenever_possible">Item 15 - Use constexpr whenever possible</h3><ul>
<li><p>当<code>constexpr</code>用在一个变量名上时，它的作用效果是 <code>const</code> 的<strong>超集</strong></p>
<pre><code><span class="comment">// 对于 constexpr</span>
<span class="keyword">int</span> sz;
<span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz; <span class="comment">// 编译错误，sz在编译期值未知</span>
<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1; <span class="comment">//这样也错，模板常量的值同样需要在编译期知道</span>

constexor <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>; <span class="comment">//这样可以</span>
<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2; <span class="comment">// 编译通过</span>
</code></pre><p>  从代码中可以看出，constexpr保证在编译期(其实还有链接期)这个被修饰的变量的值必须被初始化。</p>
<pre><code><span class="comment">// 对于 const</span>
<span class="keyword">int</span> sz;
<span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz; <span class="comment">// 这样可以</span>
<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data; <span class="comment">//编译出错，还是上面的老原因</span>
<span class="comment">// 补充</span>
<span class="keyword">const</span> <span class="keyword">int</span> arraySize2 = <span class="number">10</span>;
<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2; <span class="comment">// 这样编译就通过了</span>
</code></pre><p>  也就是说，const并不能保证其被修饰的变量在编译期就一定被初始化完成。</p>
<p>  对于一个变量名而言，其余方面 <code>constexpr</code> 和 <code>const</code> 的作用是一样的 </p>
<blockquote>
<p>实际上， <code>constexpr</code> 的意义就在于尽量牺牲编译时间来换取软件的运行时间。</p>
</blockquote>
</li>
<li><p><code>constexpr</code> 可以作为函数接口的一部分。<code>constexpr int f(int x);</code>    </p>
</li>
<li>如果<code>constexpr</code>函数的返回值被用在了需要编译期时使用的地方，例如<strong>数组维度</strong>， <strong>模板常量</strong> 等地方，那么传给其的参数也必须是在编译期就能够确定下来的，如果传给这个<code>constexpr</code>函数的参数并不能在编译期得到其值，那么编译就将出错。（<strong>试想声明一个数组，如果你用这个函数返回值做其维度，却发现返回值没办法在编译期计算出来，那还怎么给这个数组在栈上分配内存</strong>）    </li>
<li>当然，如果是纯粹调用这个<code>constexpr</code>函数，就没有如此多限制，相反还具有灵活性，如果调用的参数，其中一个或多个或全部，都无法在编译期获取其值，那么这个函数就会像普通函数一样等到运行时才能得到其返回值。否则就会在编译期就计算出其返回值。</li>
<li><p>但此处有一些小遗憾，因为<strong>C++11</strong>的<code>constexpr</code>有一定的局限性，但这些局限性在<strong>C++14</strong>版本中被修缮了。</p>
<ul>
<li><p><strong>C++11</strong>版本的<code>constexpr</code>函数里只能写有一个<code>return</code>语句：</p>
<pre><code><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>{
    <span class="keyword">return</span> (<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span>-<span class="number">1</span>));
}
</code></pre></li>
<li><p><strong>C++14</strong>版本则可以自由的书写：</p>
<pre><code>constexpr <span class="type">int</span> pow(<span class="type">int</span> base, <span class="type">int</span> exp) {
    <span class="type">auto</span> <span class="literal">result</span> = <span class="number">1</span>;
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i) 
        <span class="literal">result</span> *= exp;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre></li>
</ul>
</li>
<li><p>任何类型，无论是内建(built-in)，还是用户自己定义的类型，都可以被<code>constexpr</code>修饰，这就带来了一个好处，那就是如果构造函数被声明为<code>constexpr</code>，那么一旦其所传入的构造参数是可以在编译期内获得值的，那么，这次构造函数所创建对象将被保存在<strong>只读区域</strong>！</p>
<ul>
<li>这种途径用的越多，你的程序也就<strong>可能</strong>跑得越快(当然更费编译时间)</li>
<li><p>但是<strong>C++11</strong>的<code>constexpr</code>在此处又体现出一些瑕疵，那就是它所修饰的类成员函数，是<code>const</code>的，也就是说无法通过这个函数修改其内的值，换句话说就是没办法将<strong>setter</strong>类的成员函数声明为<code>constexpr</code>;</p>
<pre><code>class <span class="type">Point</span>{
public:
    constexpr <span class="type">void</span> setX（double newX） {
        x = newX; //C++<span class="number">14</span> 可行
    }
...
};
constexpr <span class="type">Point</span> reflection(<span class="keyword">const</span> <span class="type">Point</span> &amp; p) {
    <span class="type">Point</span> <span class="literal">result</span>;
    <span class="literal">result</span>.setX(-p.xValue());
    <span class="literal">result</span>.setY(-p.yValue());
    <span class="keyword">return</span> <span class="literal">result</span>;
}
// 使用
constexpr <span class="type">Point</span> p1(<span class="number">9</span>.<span class="number">4</span>, <span class="number">27</span>.<span class="number">7</span>);
constexpr <span class="type">auto</span> reflected = reflection(p1); // 这个对象也是被创建在只读区。
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="Item_16_-_Make_const_member_functions_thread_safe">Item 16 - Make const member functions thread safe</h3><ul>
<li>不太清楚这一小节的用意，只是粗略介绍一下如何实现线程安全的其中两种方法，而且是说让<code>const</code>成员函数在多线程环境下<strong>安全</strong>。</li>
<li><p>方法1：</p>
<ul>
<li><p>使用<code>std::mutex</code>进行真个代码块的阻塞保护。</p>
<pre><code><span class="keyword">class</span> Polynomial {
<span class="keyword">public</span>:
    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;
    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span> </span>{
        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; g(m); <span class="comment">//也可以直接使用 m.lock()，而不用这个 lock_guard</span>
        <span class="keyword">if</span>(!rootsAreValid) {
            ...
            rootsAreValid = <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> rootVals;
    }
<span class="keyword">private</span>:
    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;
    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid{ <span class="keyword">false</span> };
    <span class="keyword">mutable</span> RootsType rootVals{};
};
</code></pre><p>  这样就实现了线程安全，其中<code>mutable</code>关键字是为了在 <code>const</code>成员函数中也能修改成员变量的。</p>
<p>  lock_guard 则是实现了自动加锁，解锁的功能。 </p>
</li>
</ul>
</li>
<li><p>方法2：</p>
<ul>
<li><p>对于轻量级的场景，使用<code>std:：atomic</code>来达到原子操作的目的，以此实现一定程度上的线程安全</p>
<pre><code><span class="keyword">class</span> Point {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> 
    </span>{
        ++callCount;
        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>((x * x) + (y * y));
    }
<span class="keyword">private</span>:
    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; callCount{ <span class="number">0</span> };
    <span class="keyword">double</span> x, y;
};
</code></pre><p>  <code>callCount</code> 在此处实现了成了 具有原子操作的对象。且原子操作比锁操作所耗费的资源更少。</p>
</li>
</ul>
</li>
<li><p>综上。</p>
</li>
</ul>
<h3 id="Item_17_-_Understand_special_member_function_generation">Item 17 - Understand special member function generation</h3><ul>
<li>在一个类里面，有一种特殊的函数，是由编译器自动生成的(视情况而定)<ul>
<li>在<strong>C++98</strong>时代，它们分别是，<strong>默认构造函数</strong>， <strong>拷贝构造函数</strong>， <strong>拷贝赋值构造函数</strong>， <strong>析构函数</strong></li>
<li>在<strong>C++11</strong>时代，除了上述四种以外还多了两种<strong>移动操作</strong>， <strong>移动构造函数</strong>， <strong>移动赋值构造函数</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>以下情况，均是在未有显式声明定义的前提，要是显式定义了，那么本节的大部分内容是无意义的，关键就在于是否由编译器来生成这些函数</p>
</blockquote>
<ul>
<li>在<strong>C++98</strong>时，有提到过一个 <strong>Rule of Three</strong> 原则，那就是 ： <strong>如果你需要声明定义了 拷贝构造函数，拷贝赋值构造函数，析构函数中的任意一个，那么你就应该把他们全部都声明定义出来</strong>。</li>
<li><p>在<strong>C++11</strong>的时代，这些依然适用，但是有区别的是，它们对于<strong>移动操作</strong>的影响。</p>
<ul>
<li>对于<strong>移动操作</strong>而言，只要声明其中任意一个都会阻止另一个的自动生成。</li>
<li>而且，只要声明<strong>拷贝构造函数，拷贝赋值构造函数，析构函数中的任意一个</strong>，都会阻止<strong>移动操作</strong>的相关函数的生成。</li>
<li>而<strong>其他三个函数</strong>则不会，即使显式声明了 <strong>拷贝构造函数</strong>，也不会影响编译器默认生成<strong>拷贝赋值构造函数</strong>。</li>
</ul>
</li>
<li><p>那我们需要编译器为我们自动生成<strong>移动操作</strong>该怎么办呢？满足三个条件：</p>
<ol>
<li>没有<strong>拷贝操作</strong>函数在类中声明</li>
<li>没有<strong>移动操作</strong>函数在类中声明</li>
<li>没有<strong>析构函数</strong>在类中声明</li>
</ol>
</li>
<li><p>停下来想一想，是否太过，在<strong>C++98</strong>时代，这种特殊函数的生成规则尚且比较单一，能用<strong>Rule of Three</strong>来概述，但是<strong>C++11</strong>时代，由于引入了<strong>移动操作</strong>，这个规则变得复杂起来(远不止上面说的哪些情况)。</p>
</li>
</ul>
<blockquote>
<p>有没有更简洁的方法？</p>
</blockquote>
<ul>
<li>当然有，这就是<strong>C++11</strong>中引入 <code>= default</code> 的原因。</li>
<li><p>使用它我们就可以屏蔽一切所谓的规则，这个新语法的意义就是<strong>我想使用这个函数的编译器生成版本</strong></p>
<pre><code><span class="keyword">class</span> <span class="title">Widget</span> {
<span class="keyword">public</span>:
    ...
    ~Widget();
    Widget(<span class="keyword">const</span> Widget &amp;) = <span class="keyword">default</span>;
    Widget &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;) = <span class="keyword">default</span>;
};
</code></pre><p>  对于这个类而言，即使不显式写上 <strong>拷贝操作</strong>的两个函数，在我们用这个类的对象进行操作时，使用了<strong>拷贝操作</strong>，编译器也会自动为我们生成。</p>
<p>  但是如果我们并不懂这些规则，或者说我们不想花费时间去记，那就每次都将想要的写上并在其后跟上 <code>= default</code></p>
</li>
<li><p>书中提到了另一个完整的例子</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>; <span class="comment">//对于析构函数，如果作为基类最好为virtual</span>
    Base(Base &amp;&amp;) = <span class="keyword">default</span>;
    Base&amp; <span class="keyword">operator</span>=(Base &amp;&amp;) = <span class="keyword">default</span>;     <span class="comment">// 移动操作</span>

    Base(<span class="keyword">const</span> Base &amp;) = <span class="keyword">default</span>;
    Base&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Base &amp;) = <span class="keyword">default</span>; <span class="comment">// 拷贝操作</span>
};
</code></pre></li>
<li><p>最后，如果这些特殊函数在类中被写成了模板的形式，那并不会影响编译器自动生成的规则，即当他们不存在一样。</p>
<pre><code>class <span class="type">Widget</span> {
...
    <span class="keyword">template</span> &lt;typename T&gt;
    <span class="type">Widget</span>(<span class="keyword">const</span> T&amp; rhs);

    <span class="keyword">template</span> &lt;typename T&gt;
    <span class="type">Widget</span>&amp; operator=(<span class="keyword">const</span> T&amp; rhs);
};
</code></pre></li>
</ul>
<h3 id="Chapter_4_:_Smart_Pointer">Chapter 4 : Smart Pointer</h3><h3 id="Use_std::unique_ptr_for_exclusive-ownership_resource_management">Use std::unique_ptr for exclusive-ownership resource management</h3><ul>
<li>内存泄漏一直是<strong>C/C++</strong> 程序员的痛处，自从 <strong>C++11</strong>的智能指针被引入，问题得到了挺大的改善。</li>
<li><code>unique_ptr</code> 用来表示某个资源被这个智能指针唯一的占有，不允许对其进行拷贝(当然你不能用裸指针刻意指向它，那就没意义了)，只能被 <strong>移动操作</strong></li>
<li><p>本节用一个继承类及工厂模式来讲解</p>
<pre><code>ckass <span class="type">Investment</span> <span class="decorator">{...}</span>
class <span class="type">Stock</span> : public <span class="type">Investment</span> { ... }
class <span class="type">Bond</span> : public <span class="type">Investment</span> { ... }
class <span class="type">RealEstate</span> : public <span class="type">Investment</span> { ... }
</code></pre><p>  对于这种模型下的工厂模式，我们可以</p>
<pre><code><span class="keyword">template</span> &lt;typenam... <span class="type">Ts</span>&gt;
std::unique_ptr&lt;<span class="type">Investment</span>&gt;
makeInvestment(<span class="type">Ts</span>&amp;&amp;... params);
</code></pre></li>
</ul>
<p>转载注明: <a href="http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html" target="_blank" rel="external">http://www.wushxin.top/2016/02/22/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>(Item 15)</p>
</blockquote>
<h3 id="Item_12_-_Declare_overriding_functions_override-">Item 12 - Declare overriding functions override.</h3><ul>
<li><p>介绍了一个鲜为人知的 <strong>C++11</strong> 新特性，针对一个类成员函数的</p>
<pre><code><span class="keyword">class</span> <span class="title">Widget</span> {
<span class="keyword">public</span>:
  ...
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;   <span class="comment">// 只有当 *this 是 lvalue 时才调用</span>
  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;  <span class="comment">// 只有当 *this 是 rvalue 时才调用</span>
};
...
<span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// 制造一个临时的 Widget</span>
<span class="comment">// 调用</span>
Widget w; <span class="comment">// 默认构造函数创建</span>
w.doWork(); <span class="comment">// 调用第一个版本(lvalue)</span>
makeWidget().doWork(); <span class="comment">// 调用第二个版本</span>
</code></pre></li>
<li><p>对于 <strong>重写</strong> 和 <strong>重载</strong>，这两个极易混淆，或者说不是混淆而是十分容易不小心就写错了，的功能，在 <strong>C++98</strong> 之前我们只能选择相信程序员写下的代码是准确无误的。有几个判断 <strong>重写</strong> 的条件</p>
<ol>
<li>基类里的该函数必须是 <code>virtual</code></li>
<li>基类里的该函数和派生类里的该函数的 <strong>函数名</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>参数类型</strong> 必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>返回值类型</strong> 必须相同或者可以<strong>兼容(即继承关系)</strong></li>
<li>基类里的该函数和派生类里的该函数的 <code>const</code> 属性必须相同</li>
<li>基类里的该函数和派生类里的该函数的 <strong>引用限定词</strong> 必须相同(<strong>C++11新增</strong>)]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective Modern C++概述（一）]]></title>
    <link href="http://www.wushxin.top/2015/12/15/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0.html"/>
    <id>http://www.wushxin.top/2015/12/15/Effective-Modern-Cpp-概述.html</id>
    <published>2015-12-15T08:40:14.000Z</published>
    <updated>2016-03-25T00:01:24.611Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>(本文有 11 个 Item)</p>
</blockquote>
<h1 id="《Effective_Modern_C++》概要">《Effective Modern C++》概要</h1><ul>
<li>因为 Scott 大大的这本新书迟迟没有中译本，百般无奈之下，选择了英文原版阅读。</li>
<li>记录自己阅读这本书的过程，以及一些细节，知道自己不可能读一遍就能将所有信息记下，故写成博文，方便自己及需要者查阅</li>
<li>本文是我自己的感受，如果有想要体会完整的思想请自行查阅原书，最好配一本完备的C++的语法工具书（例如<code>The C++ Programming Languag, 4th Edition--Bjarne Stroustrup</code>），以便随时查询，当然还需要一个可编程平台。</li>
</ul>
<blockquote>
<p>代码尽量和原书相同，除非是想更详细的解释才会自行修改</p>
</blockquote>
<h2 id="Chapter_1_-_Deducing_Types">Chapter 1 - Deducing Types</h2><h3 id="Item_1_-_Understand_template_type_dedution">Item 1 - Understand template type dedution</h3><ul>
<li>这节讲述了C++有两种类型推断(不许程序员介入)， <strong>自动类型推断(auto type dedution)</strong> 和 <strong>模板类型推断(template type dedution)</strong>， 两者的联系以及唯一的区别。</li>
<li>首先介绍的是模板类型推断，这是来自(C++98)的特性了，现在以及在沿用，是最成功的特性之一。</li>
<li><p>对于模板类型推断，一般形式可归纳为：</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(<span class="type">ParamType</span> param);
// 调用
f(<span class="type">expr</span>); // <span class="type">expr</span> 可能是一条语句
</code></pre><p>  <code>ParamType</code> 是一种缩写，用来表示 可能 类型<code>T</code>会有一些限定词来修饰，例如<code>const</code>, <code>&amp;</code> 之类的。</p>
<p>  例如 把<code>ParamType</code> 可以代表 <code>const T &amp;</code></p>
</li>
<li>而此时，编译器在进行 模板类型推断 的时候会做两件事(两个推断的结果)，它会判断 <code>T</code> 和 <code>ParamType</code>的类型分别是什么。当然，如果 <code>ParamType</code> 就是 <code>T</code> 那自然就相同了。</li>
<li>因为 <code>T</code> 究竟是什么，取决于 <code>ParamType</code>。</li>
<li>进行推断的过程中，有三条编译器遵循的判断情况：<ol>
<li><code>ParamType</code> 是一个指针或者引用，但不是一个 通用引用(Universal reference 不知道怎么翻译)。</li>
<li><code>ParamType</code> 是一个 Universal reference</li>
<li><code>ParamType</code>·不是一个指针也不是一个引用· </li>
<li>所以将模板类型推断分为三种情况。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>第一种情况比较简单</p>
<ul>
<li><p>如果此时 <code>expr</code>是一个引用，那就把引用去掉，剩下的就是 <code>T</code></p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(T &amp; param);
// 调用
<span class="type">int</span>         x  = <span class="number">0</span>;
<span class="keyword">const</span> <span class="type">int</span>     cx = x;
<span class="keyword">const</span> <span class="type">int</span> &amp; rx = x;
<span class="type">char</span> strings[] = <span class="string">"Hello World!"</span> // 原书没有
f(x);  // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span> &amp;
f(cx); // T: <span class="keyword">const</span> <span class="type">int</span>; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span> &amp;
f(rx); // T: <span class="keyword">const</span> <span class="type">int</span>; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span> &amp;
f(strings); // 原书没有 T: <span class="type">char</span> [<span class="number">13</span>] ; <span class="type">ParamType</span>: <span class="type">char</span>(&amp;)[<span class="number">13</span>]
</code></pre><p>  如果是 <code>void f(const T &amp; param)</code>呢，结果并没有什么太大的差别，只是 <code>const</code> 限定符略有不同而已。</p>
<pre><code>f<span class="comment">(x)</span>;  <span class="comment">// T: int ; ParamType: const int &amp;;</span>
f<span class="comment">(cx)</span>; <span class="comment">// 同上</span>
f<span class="comment">(rx)</span>; <span class="comment">// 同上</span>
</code></pre><p>  如果是指针 <code>void f(T * param)</code></p>
<pre><code>const <span class="built_in">int</span> * px = &amp;x;
f(&amp;x); // T: <span class="built_in">int</span> ; ParamType: <span class="built_in">int</span> *
f(px); // T: const <span class="built_in">int</span>; ParamType: const <span class="built_in">int</span> *
</code></pre><p>  以上为第一种情形</p>
</li>
</ul>
</li>
<li><p>第二种情况</p>
<ul>
<li>当参数类型设置为 <code>Universal reference</code>时比较奇怪，不可以常理推断。</li>
<li><p>具体是，当传入参数为 <code>lvalue</code> 时，两个类型都为 <code>lvalue reference</code>, 否则如果传入一个 <code>rvalue</code>， 则用常规方法(第一种情况)处理。</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(T &amp;&amp; param); // 这就是所谓的 <span class="type">Universal</span> reference
// 调用
<span class="type">int</span> x = <span class="number">0</span>;
<span class="keyword">const</span> <span class="type">int</span> cx = x;
<span class="keyword">const</span> <span class="type">int</span> &amp; rx = x;
f(x);  // T: <span class="type">int</span> &amp; ; <span class="type">ParamType</span>: <span class="type">int</span> &amp;
f(cx); // T: <span class="keyword">const</span> <span class="type">int</span> &amp;; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span> &amp;
f(rx); // T: <span class="keyword">const</span> <span class="type">int</span> &amp;; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span> &amp;
// 特别处, 此时传入一个 rvalue
f(<span class="number">0</span>); // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span> &amp;&amp;
      // 此时和第一种情况一致，由于传入的非引用，则 T 为 <span class="type">int</span>，<span class="type">ParamType</span>直接是 <span class="type">int</span> &amp;&amp;
</code></pre></li>
</ul>
</li>
<li><p>第三种情况</p>
<ul>
<li><p>当参数类型既不是指针也不是引用时，此时就是所谓的 <strong>按值传参</strong></p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(T param);
// 调用，参数和第一种情况一样
f(x);  // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span>
f(cx); // 同上
f(rx); // 同上
</code></pre><p>  似乎很奇怪，但是实际上可以这么理解：既然都按值传递了，自然是拷贝一个副本了，既然是副本，那怎么操作都不会影响原来的对象(函数栈外的对象)，所以直接用最简单的最普通的，不带任何限定符的方式就行。</p>
<p>  而对于引用而言只需要记住，任何作用在引用”身上”的操作，都会反射(用反射形容比较形象)到源对象上，所以相当于在传递 <code>x</code>。</p>
<p>  从此处以及前方所述，<strong>可以看出</strong> ，在进行类型推断的时候，所有的 <strong>限定符(const, volatile)</strong> 都会被忽略。</p>
<p>  还有一些情况，例如传入指针</p>
<pre><code>f<span class="comment">(&amp;x)</span>; <span class="comment">// 原书没有，原书使用的是字符串的首地址，并讲了一遍指针和数组的差异。</span>
       <span class="comment">// T: int * ; Param: int *</span>
</code></pre></li>
</ul>
</li>
<li><p>在篇末，作者提到，如果想要在 <strong>编译期</strong> 得到一个数组的长度，并且使这个得到的长度可以用在其他数组的声明上，可以如此：</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::size_t N&gt;
<span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="function">size_t <span class="title">arraySize</span><span class="params">(T (&amp;)</span>[N]) <span class="keyword">noexcept</span> <span class="comment">// noexcept 可以帮助编译器更少的顾虑，也就是把优化策略更好的用在这个函数上。</span>
</span>{
    <span class="keyword">return</span> N;
}
</code></pre><p>  其中 <code>constexpr</code> 是让返回值可以当成常量使用。所传的参数类型指的就是 某大小的数组引用，这个大小可以由 模板类型推断 来自动取得。</p>
</li>
<li>Item 1 结束</li>
</ul>
<h3 id="Item_2_-_Understand_auto_type_dedution">Item 2 - Understand auto type dedution</h3><ul>
<li>这是 C++ 的第二种类型推断，由 C++11 标准引入，也就是关键字 <code>auto</code></li>
<li><p>前方提到， <strong>模板类型推断</strong> 和 <strong>自动类型推断</strong> 出了一个地方不同，其他处处一致，具体体现在哪里？比如 <code>T</code> 和 <code>ParamType</code> 在 <strong>自动类型推断</strong> 中是怎么体现的？</p>
<pre><code><span class="keyword">auto</span> x = <span class="number">27</span>; <span class="comment">// 其中 auto 相当于 T</span>
              <span class="comment">// 而 x 前面的所有相当于 ParamType，可能还不太明显，换一个例子</span>
<span class="keyword">const</span> <span class="keyword">auto</span> cx = x;  <span class="comment">// T: auto ; ParamType: const auto</span>
<span class="keyword">const</span> <span class="keyword">auto</span> &amp; rx = x; <span class="comment">// T: auto ; ParamType: const auto &amp;</span>
</code></pre><p>  注： <code>T</code> 当然不是 <code>auto</code>，只是此处为了体现作用，而故意写成 <code>auto</code>，实际为 <code>int</code></p>
</li>
<li><p>有了这种对应关系之后，可以将 <strong>模板类型推断</strong> 的三种情况直接用在 <strong>自动类型推断上</strong></p>
</li>
<li><p>第一种情况(是一个指针或引用，但不是 <code>Universal reference</code>)</p>
<pre><code><span class="type">int</span> x = <span class="number">27</span>;
<span class="type">auto</span> &amp; rx = x; // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span> &amp;
<span class="keyword">const</span> <span class="type">auto</span> &amp; crx = x; // T: <span class="type">int</span> ; <span class="type">ParamType</span> : <span class="keyword">const</span> <span class="type">int</span> &amp; 
</code></pre><p>  可以看出这是第一种情况，但是并没有太大的意外</p>
<pre><code><span class="keyword">const</span> <span class="keyword">int</span> cx = <span class="number">27</span>;
<span class="keyword">auto</span> &amp; rx = x; <span class="comment">// T: const int ; ParamType: const int &amp;</span>
</code></pre><p>  结合上述例子看，能够更好理解。<strong>大体就是将等号右端看作是</strong>要传入的对象<strong>，左端则是参数列表</strong>。</p>
</li>
<li><p>第二种情况(是 <code>Universal reference</code>)</p>
<pre><code><span class="type">int</span> x = <span class="number">27</span>;
<span class="keyword">const</span> <span class="type">int</span> cx = x;
<span class="type">auto</span> &amp;&amp; uref1 = x; // T: <span class="type">int</span> &amp;; <span class="type">ParamType</span>: <span class="type">int</span> &amp;
<span class="type">auto</span> &amp;&amp; uref2 = cx; // T: <span class="keyword">const</span> <span class="type">int</span> &amp; ; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span> &amp;
<span class="type">auto</span> &amp;&amp; uref3 = <span class="number">27</span>; // T: <span class="type">int</span> &amp;&amp; ; <span class="type">ParamType</span>: <span class="type">int</span> &amp;&amp;
</code></pre><p>  解释和 Item-1 的一样，当<strong>传入</strong>的是 <code>lvalue</code> 时，就是该类型的引用，是<code>rvalue</code>时就是正常的第一种情况，是什么类型推断什么类型。</p>
</li>
<li><p>第三种情况(既不是指针也不是引用)</p>
<ul>
<li><p>这种情况还是老样子，看作按值传参</p>
<pre><code><span class="type">auto</span> x = <span class="number">27</span>;   // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span> 
<span class="keyword">const</span> <span class="type">auto</span> cx = x; // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="keyword">const</span> <span class="type">int</span>
<span class="type">auto</span> atd_x1 = x; // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span> 
<span class="type">auto</span> atd_x2 = cx; // T: <span class="type">int</span> ; <span class="type">ParamType</span>: <span class="type">int</span>
</code></pre><p>可以看出，忽略了所有的限定符。</p>
</li>
</ul>
</li>
<li><p>还有一种也是包含在上述三种情况中的情形，单独提出来，便是 <strong>数组和函数</strong> 的推断</p>
<pre><code>const <span class="built_in">char</span> * <span class="keyword">name</span>[] = <span class="string">"R. N. Briggs"</span>;
auto arr1 = <span class="keyword">name</span>;  // T: const <span class="built_in">char</span> * ;ParamType: const <span class="built_in">char</span> *
auto &amp; arr2 = <span class="keyword">name</span>; // T: const <span class="built_in">char</span>[<span class="number">13</span>] ;ParamType: const <span class="built_in">char</span> (&amp;)[<span class="number">13</span>]
</code></pre><p>  如果是函数</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;
<span class="keyword">auto</span> func1 = someFunc; <span class="comment">// func1的类型为 void(*)(int, double)</span>
<span class="keyword">auto</span> &amp; func2 = someFunc; <span class="comment">// func2的类型为 void(&amp;)(int, double)</span>
</code></pre></li>
<li><p><strong>不同点</strong></p>
<ul>
<li><p>两种类型推断唯一不同的地方一种新的 <strong>初始化方式</strong>，许多书本译作 <strong>列表初始化</strong>，即用一个花括号，包裹一系列同类型的值，赋给等号左边的对象</p>
<pre><code><span class="keyword">int</span> x1 = <span class="number">27</span>; <span class="comment">// C++98</span>
<span class="function"><span class="keyword">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>; <span class="comment">// C++98</span>
<span class="keyword">int</span> x3 = {<span class="number">27</span>}; <span class="comment">// C++11</span>
<span class="keyword">int</span> x4{<span class="number">27</span>}; <span class="comment">// C++11</span>
</code></pre><p>  这是我们熟悉的初始化语法，C++提供了这四种方式。如果改成 <code>auto</code> 呢？</p>
<pre><code>auto x1 = <span class="number">27</span>; <span class="regexp">//</span> <span class="constant">T:</span> int 
auto x2(<span class="number">27</span>);  <span class="regexp">//</span> <span class="constant">T:</span> int
auto x3 = {<span class="number">27</span>}; <span class="regexp">//</span> <span class="constant">T:</span> <span class="symbol">std:</span><span class="symbol">:initializer_list&lt;int&gt;</span>
auto x4{<span class="number">27</span>}; <span class="regexp">//</span> <span class="constant">T:</span> <span class="symbol">std:</span><span class="symbol">:initializer_list&lt;int&gt;</span>
</code></pre><p>  看起来似乎是一样的，实际上我们在使用的时候，前两者是最常见的，后两者要出现只出现咋需要同时传入多个类型相同的值时才使用。</p>
<p>  但是，自动类型推断能够<strong>直接接受</strong>这种语法，模板类型推断却不行！</p>
<pre><code><span class="type">auto</span> x = {<span class="number">11</span>,<span class="number">23</span>,<span class="number">9</span>}; // 可以

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(T param);
//调用
f({<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>}); // 这是错误的！无法通过编译
</code></pre><p>  这就是两者的区别，当一个类型推断使用的是 <strong>模板类型推断</strong> 时(例如<strong>函数返回值</strong>)，其无法直接推断出<code>std::initializer_list&lt;T&gt;</code>这种列表形式，当然事无绝对</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(std::initializer_list&lt;T&gt; param);
// 调用
f({<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>}); //这样是可以的。每次传入一个初始化列表即可
</code></pre><p>  就像上面所说，当返回值是一个列表时，<strong>模板类型推断</strong> 是无法工作的，除非显式说明，返回的是一个列表。</p>
<p>  这里提到了显式说明，自然可以用 类型推断来替代，但是因为此时使用的是 <strong>模板类型推断</strong>，所以除了使用 <code>auto</code>进行<strong>“占位”(占返回值类型的位)</strong>， 还需在后面添上一些东西</p>
<pre><code>// 原书没有
<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">auto</span> f(std::initializer_list&lt;T&gt; param)
-&gt; decltype(param)
{
    <span class="type">auto</span> tmp = param;
    // <span class="keyword">do</span> some work
    <span class="keyword">return</span> tmp;
}
</code></pre><p>  似乎很奇怪，但是这个语法的确反人类，不过还好在 C++14 中修正过来了。</p>
<p>  所谓修正就是不需要再参数后面添加这么一个吊车尾的 <code>-&gt; decltype(param)</code>样式，而是直接用 <code>auto</code> 作为返回值即可(因为在C++11中只有 <strong>部分lambda(单个返回语句情况下)</strong> 允许不加 <code>-&gt;</code> 而自动推断返回值类型)。</p>
</li>
</ul>
</li>
<li>Item 2 结束</li>
<li>总结<ul>
<li>自动类型推断 和 模板类型推断 总是相同的，除了前者假设一个 <strong>列表初始化</strong>语法的出现总是代表<code>std::initializer_list&lt;T&gt;</code>的类型，但是后者却不是</li>
<li>在作返回值类型推断的时候，总是使用 模板类型推断，而不是 自动类型推断。</li>
</ul>
</li>
</ul>
<h3 id="Item_3_-_Understand_decltype">Item 3 - Understand decltype</h3><ul>
<li>首先<code>decltype</code>的确是一个很奇怪的东西，但是从种种解释来看，他似乎是C++中一个很中规中矩的一个 <strong>关键字</strong>，因为它总是能够把 <strong>正确的类型不加修改</strong> 的返回给你。</li>
<li>但是在初试这个关键字的一段时间之后，总能出现让使用者抓狂的现象<blockquote>
<p>例如：“啊！怎么是引用！我明明返回的是一个对象！”</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>例如：“啊！怎么这回不是引用啦！”</p>
</blockquote>
<pre><code><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//decltype(i) 返回的类型是 const int</span>

<span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Widget &amp; w)</span> <span class="comment">// decltype(w) 返回 const Widget &amp;</span>
Widget w</span>; <span class="comment">// decltype(w) 返回 Widget</span>
f(w);     <span class="comment">// decltype(f(w)) 返回 bool</span>

<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; tmp.push_back(<span class="number">10</span>); <span class="comment">// 改造一下原文程序</span>
tmp[<span class="number">0</span>] = <span class="number">20</span>; <span class="comment">// decltype(tmp[0]) 返回 int &amp;</span>
</code></pre><p>综上而观，并没有什么出乎意料的地方，（最后一个返回 <code>int &amp;</code> 是因为 <code>vector&lt;T&gt;</code>这个容器重载了运算符 <code>[]</code>，其返回值是 <code>T &amp;</code>），所以总的来说还是没有出乎我们意料之外。</p>
<ul>
<li>在此处，原作者引出了一个问题，实际上也是 <strong>Item 2</strong> 里提到的，怎样让函数返回值也可以使用 类型推断？里要区分 C++11 和 C++14 标准的区别了，当然前者的方法在后者也可以使用，但是后者的方法却不一定能在前者内使用。</li>
<li><p>引用 <strong>Item 2</strong> 末尾的例子(自行添加的)，这是 C++11 标准的方法，如果将其改写成 C++14 的形式：</p>
<pre><code>// C++<span class="number">14</span> 
<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">auto</span> f(std::initializer_list&lt;T&gt; param)
{
    <span class="type">auto</span> tmp = param;
    // <span class="keyword">do</span> some work
    <span class="keyword">return</span> tmp;
}    
</code></pre><p>只需要简单的将 “吊车尾” 删掉，这段代码在支持 C++14 标准的编译器的编译下是通过的。</p>
</li>
<li><p>那作者提出这个问题是为什么？实际上看到这里，都忽略了一个细节，那就是在 返回值的类型推断中，使用的是模板类型推断，无论什么类型推断，都会有一个事实那就是，将 <strong>限定符</strong> 删除。</p>
</li>
<li><p><strong>这会导致什么呢，如果我们返回的是一个简单的对象，自然没有什么问题，如果我们返回的是引用呢？</strong>(实际上这只影响 C++14的写法，对C++11的写法 并没有这种问题，因为我们所讨厌的<strong>“吊车尾</strong>”帮我们避免了这种问题的发生):</p>
<pre><code>// C++<span class="number">11</span>
<span class="keyword">template</span>&lt;typename <span class="type">Container</span>, typename <span class="type">Index</span>&gt;
<span class="type">auto</span> authAndAccess(<span class="type">Container</span> &amp; c, <span class="type">Index</span> i)
 -&gt; decltype(c[i])
{
    authenticateUser(); //做一些事
    <span class="keyword">return</span> c[i];
}
// -----------------------------------------
// C++<span class="number">14</span>
<span class="keyword">template</span>&lt;typename <span class="type">Container</span>, typename <span class="type">Index</span>&gt;
<span class="type">auto</span> authAndAccess(<span class="type">Container</span> &amp; c, <span class="type">Index</span> i)
{
    authenticateUser(); //做一些事
    <span class="keyword">return</span> c[i];
}            
</code></pre><p>  诚然第二种写法比较简洁，打呢带来了一些隐患，就是返回值类型没有那么“明确”了，所以此处我们如果向参数 <code>c</code> 传入一个容器对象，例如 <code>vector</code>，那么最后返回的时候，<strong>C++11</strong> 版本返回的是一个引用， <strong>C++14</strong> 版本返回的则是一个 <code>rvalue</code>(类型推断把 <strong>限定符</strong> 给忽略了！)，也就是说我们的原意可能已经被编译器给理解错了！这回导致什么结果呢？</p>
<pre><code><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;
<span class="comment">//... 加入元素</span>
<span class="comment">// C++11</span>
authAndAccess(d, <span class="number">5</span>) = <span class="number">10</span>; <span class="comment">// 可行，因为是引用</span>
<span class="comment">// C++14</span>
authAndAccess(d, <span class="number">5</span>) = <span class="number">10</span>; <span class="comment">// 错误！连编译都无法通过</span>
</code></pre><p>  无法通过编译的理由，上面已经叙述过了，实际上就是 <strong>Item 1/2</strong>的情况。</p>
<p>  解决的办法，还是要靠 <code>decltype</code></p>
<pre><code>// C++<span class="number">14</span>
<span class="keyword">template</span>&lt;typename <span class="type">Container</span>, typename <span class="type">Index</span>&gt;
decltype(<span class="type">auto</span>) authAndAccess(<span class="type">Container</span> &amp; c, <span class="type">Index</span> i)
{
    authenticateUser(); //做一些事
    <span class="keyword">return</span> c[i];
}        
</code></pre><p>  因为 <code>decltype</code> 会如实的将类型返回给使用者，所以这时候，返回值就是 <code>int&amp;</code> 了。</p>
<p>  这样，C++14的版本就能愉快的工作了。之后原文还介绍了更深入的知识 <code>std::forward</code>，这个不记录，在 <strong>Item 25</strong>有专门讲解。</p>
<p>  什么时候 <code>decltype</code> 会出乎意料？</p>
<pre><code><span class="comment">// C++14</span>
<span class="comment">// 原书的例子不太好，但是用来解释却是最好的</span>
<span class="keyword">decltype</span>(<span class="keyword">auto</span>) f()
{
    <span class="keyword">int</span> x = <span class="number">0</span>;
    <span class="comment">//...</span>
    <span class="keyword">return</span> x;
}
</code></pre><p>  毫无疑问，返回值类型就是 <code>int</code></p>
<pre><code><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f()
{
    <span class="keyword">int</span> x = <span class="number">0</span>;
    <span class="comment">//...</span>
    <span class="keyword">return</span> (x);
}
</code></pre><p>  这回返回值类型就是 <code>int &amp;</code></p>
<p>  原因就是用 <code>()</code> 包裹起来在C++看来，这就不再是一个单纯的对象，所以返回了引用。</p>
</li>
<li><p>这里需要补充,一旦多加了一层括号</p>
<ul>
<li>当括号内是 <code>lvalue</code> 或最终结果是 <code>lvalue</code>时，返回的是<strong>该类型的引用</strong></li>
<li>当括号内是 <code>rvalue</code> 或最终结果是 <code>rvalue</code>时，返回的是<strong>该类型本身</strong></li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><code>decltype</code> 几乎总是没有任何修改的返回正确的类型</li>
<li>如果是一个 <code>lvalue expression</code> 的话，那就返回表达式结果类型的引用。</li>
<li>C++11写法 在函数返回值类型推断方面不必太在意<code>decltype</code>的这两个规则，因为“吊车尾”帮我们避免了问题，但是 C++14 的写法就必须要注意。</li>
</ul>
</li>
<li>Item 3 结束 </li>
</ul>
<h3 id="Item_4_-_Know_how_to_view_deduced_types">Item 4 - Know how to view deduced types</h3><ul>
<li>这一节讲述，如何才能知道推断出来的类型是否是我们想要的。</li>
<li>第一种方法 ： 某些 <strong>IDE</strong> 自带，这个不再记录</li>
<li><p>第二种方法 ： 通过语法错误产生的编译信息来确定。</p>
<ul>
<li><p>给出一个范例使用</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">TD</span>; // 故意不写完整
// 使用的时候
<span class="type">TD</span>&lt;decltype(x)&gt; xType; // x 即为想知道什么类型的对象
<span class="type">TD</span>&lt;decltype(y)&gt; yType;
</code></pre></li>
</ul>
</li>
<li><p>第三种方法 ： 使用库里的一个方法 <code>typeid</code></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;typeinfo&gt;</span>
...
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; endl;
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(y).name() &lt;&lt; endl;
</code></pre><p>  这会在终端输出类型信息，只不过这个信息略微有些晦涩，可以自行查询资料</p>
</li>
<li><p>但是，很遗憾第一种和第三种方法往往不能正确的打印出正确的类型，换句话说就是不太可靠。<code>Boost</code> 库中，有一个可靠的实现，<code>Boost.TypeIndex</code> 可以使用。原书例子不在记录。</p>
</li>
<li>所以本节就这么多例子信息，旨在告诉读者，要善用编译器。</li>
<li>Item 4 结束</li>
</ul>
<h2 id="Chapter_2_-_auto">Chapter 2 - auto</h2><h3 id="Item_5_-_Prefer_auto_to_explict_type_declarations">Item 5 - Prefer auto to explict type declarations</h3><ul>
<li>用几个例子，讲述 <code>auto</code> 相对于 显式类型声明的 优势</li>
<li>它能缓解由于错误声明带来的隐性错误。但是由前面可知，有时候 <code>auto</code> 的推断并不一定都如我们所愿，所以<code>auto</code>这个选择只是作为一种推荐，而不是硬性要求我们使用。</li>
<li><p>例子</p>
<ul>
<li><p>在 <strong>C/C++</strong> 中，常常出现声明变量后，忘记初始化的错误，但是用 <code>auto</code> 进行替换的话，可以有效避免这种情况的出现。</p>
<pre><code><span class="keyword">int</span> x1; <span class="comment">// 未初始化，但编译通过</span>
<span class="keyword">auto</span> x2; <span class="comment">// 未初始化，编译错误！</span>
<span class="keyword">auto</span> x3 = <span class="number">0</span>; <span class="comment">// 这样才行</span>
</code></pre></li>
<li><p>匿名函数和闭包的例子，在 C++ 中有一个模板，可以用来存储任意类型的 <strong>可调用对象</strong>， 叫做 <code>std::function&lt;T&gt;</code>，这不是唯一的方法，我们可以选择使用　<code>auto</code> 来代替</p>
<pre><code><span class="comment">// auto 来创建对象存储匿名函数</span>
<span class="comment">// C++11</span>
<span class="keyword">auto</span> derefUPLess = 
    [](<span class="keyword">const</span> <span class="built_in">std</span>::unique_ptr&lt;Widget&gt; &amp; p1,
      <span class="keyword">const</span> <span class="built_in">std</span>::unique_ptr&lt;Widget&gt; &amp; p2)
    { <span class="keyword">return</span> *p1 &lt; *p2; };
<span class="comment">// C++14</span>
<span class="keyword">auto</span> derefUPLess = 
    [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; p1, 
      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; p2)
    { <span class="keyword">return</span> *p1 &lt; *p2; };

<span class="comment">// 用 function&lt;&gt; 来声明存储</span>
function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> unique_ptr&lt;Widget&gt; &amp;, 
            <span class="keyword">const</span> unique_ptr&lt;Widget&gt; &amp;)&gt;
derefUPLess = 
    [](<span class="keyword">const</span> <span class="built_in">std</span>::unique_ptr&lt;Widget&gt; &amp; p1,
      <span class="keyword">const</span> <span class="built_in">std</span>::unique_ptr&lt;Widget&gt; &amp; p2)
    { <span class="keyword">return</span> *p1 &lt; *p2; };
</code></pre><p>  由 <code>auto</code> 和 <code>function</code> 创建的是完全不同的两个东西，一般而言前者要比后者省一些，后者作为一种通用的”模板”存在，最开始具有一定的大小，如果不足以容纳要接受的对象的话，会在堆上申请空间来存储</p>
<p>  所以相对而言， <code>auto</code> 的效率会高于 <code>function</code></p>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>有时候不经意的想当然也会导致一些小隐患</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Mat;
...
<span class="keyword">unsigned</span> size = Mat.size();
</code></pre><p>  这段小代码，看上去没有什么错误</p>
<p>  Mat.size()的返回值类型是 <code>vector&lt;int&gt;::size_type</code>，在 <strong>32位</strong> 操作系统下，其大小为 <strong>32位</strong>， 在 <strong>64位</strong> 操作系统下为 <strong>64位</strong>，而 <code>unsigned</code>则都是 <strong>32位</strong>。这会导致如果移植到 <strong>64位</strong>操作系统时，可能在某一时刻出现问题。</p>
<pre><code>auto <span class="keyword">size</span> = Mat.<span class="keyword">size</span>(); <span class="comment">// 这样做就行了</span>
</code></pre></li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>范围<code>for</code>循环 (<strong>range-for loop</strong>)</p>
<pre><code><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;
...
<span class="keyword">for</span>(<span class="keyword">const</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp; p : m)
{
    <span class="comment">// 做一些事</span>
}
</code></pre><p>  这个代码有什么问题？首先，<code>unordered_map</code>的 <strong>Key-Value</strong> 类型并不是<code>string, int</code> 而是 <code>const string, int</code>。这往往会被忽略</p>
<p>  那忽略了能怎样？首先编译器在此时会尽量满足程序员的要求(尽管此时的要求似乎并不是我们所想要的)，也就是拷贝一个<code>m</code>的副本，供这个新的 <code>pair</code> 使用。</p>
<p>  当然，此处编译器不会让我们犯下非常大的错误，这里产生的<strong>副作用</strong>就是在每次循环结束的时候，那个拷贝的副本都将被销毁，下一次循环开始后又被创建，如此往复。</p>
<p>  可以猜得到，如果将 <code>const pair&lt;string, int&gt;</code> 的 <code>const</code> 去掉，编译将不会被通过，因为如果没有了这个<code>const</code>，那么我们就能通过这个<code>pair</code>对象修改这个<code>unordered_map</code> 的 <strong>Key</strong>，这与设计理念相驳，所以除非你这么写</p>
<pre><code><span class="keyword">for</span>(pair&lt;<span class="keyword">const</span> <span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp; p : m)
</code></pre><p>  否则，编译是无法通过的。</p>
<p>  所以，此时可以选择 <code>auto</code> 来帮助完成这些暗藏陷阱的工作</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; p : m)
</code></pre><p>  记住要自己加上<strong>限定符</strong>。</p>
</li>
</ul>
</li>
<li>但是一定要切记，<code>auto</code> 使用时会发生的事情。</li>
<li>Item 5 结束</li>
</ul>
<h3 id="Item_6_-_Use_the_explictly_typed_initializer_idiom_when_auto_deduces_undesired_types">Item 6 - Use the explictly typed initializer idiom when auto deduces undesired types</h3><ul>
<li>本篇几乎为上述篇幅的一个小补充，叙述的是，当 <code>auto</code> 返回了一个出人意料的结果时，应该改用显式的类型声明。</li>
<li>何时会出现出人意料的结果？ 文中给出了一种叫做 代理(Proxy) 的模式下，会有出人意料的结果</li>
<li><p>简单来说就是，例如一个 <code>std::vector&lt;bool&gt;</code> 的使用，几乎大部分人都知道 <code>std::vector&lt;bool&gt;</code>是一个模板特例化的产物，且一般而言 <code>operetor[]</code>操作返回的是容器元素的引用，但是在 <strong>C++</strong> 中， <strong>bit</strong>是不允许被引用指向的，也就是说<code>bool&amp;</code>是不存在的。所以，使用了一种称为代理的机制，返回的真正类型是 <code>std::vector&lt;bool&gt;::reference</code>，这是一个内嵌类(vector中)</p>
<pre><code><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isTriangle;
...
<span class="keyword">bool</span> rights = isTriangle[<span class="number">1</span>]; <span class="comment">// 正确，有类型转换发生，但是合法的</span>
<span class="keyword">auto</span> wrongs = isTriangle[<span class="number">1</span>]; <span class="comment">// 也是能够编译通过，但是不太好</span>
</code></pre><p>  但是 <code>wrong</code> 的类型是 <code>std::vector&lt;bool&gt;::reference</code></p>
<p>  如果这个 <code>vector</code> 是个临时对象呢？</p>
<pre><code><span class="comment">// 假设有一个函数 std::vector&lt;bool&gt; retVec(int para);</span>
<span class="keyword">bool</span> rights = retVec(<span class="number">2</span>)[<span class="number">1</span>]; <span class="comment">// 可以</span>
<span class="keyword">auto</span> wrongs = retVec(<span class="number">2</span>)[<span class="number">1</span>]; <span class="comment">// 绝对不能这么做</span>
</code></pre><p>  这取决于，<code>std::vector&lt;&gt;::reference</code> 的实现了，有一种实现是返回一个指向区域的类似指针的东西，假设如此，那么当这个临时对象被销毁之后呢？所以 <code>wrongs</code> 是一种不确定行为。</p>
<p>  当然有一种做法就是给它加上类型转换</p>
<pre><code><span class="keyword">auto</span> change = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(retVec(<span class="number">2</span>)[<span class="number">1</span>]);
</code></pre></li>
<li><p>Item 6 结束</p>
</li>
</ul>
<h2 id="Chapter_3_-_Moving_to_Modern_C++">Chapter 3 - Moving to Modern C++</h2><h3 id="Item_7_Distinguish_between_()_and_{}_when_creating_objects">Item 7 Distinguish between () and {} when creating objects</h3><ul>
<li>前者代表 <code>()</code> 后者代表 <code>{}</code></li>
<li><p>首先，后者能让初始化一个容器，或者类似事物，在某种程度上更加简便</p>
<pre><code><span class="comment">// 只需</span>
<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index1{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
<span class="comment">// 不需</span>
<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index2;
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constance; i++)
{
    index2.push_back(i);
}
</code></pre></li>
</ul>
<ul>
<li><p>不可拷贝的对象的创建，有时候必须借用这种机制</p>
<pre><code><span class="symbol">std:</span><span class="symbol">:atomic&lt;int&gt;</span> al1{ <span class="number">0</span> }; <span class="regexp">//</span><span class="constant">Okay</span>
<span class="symbol">std:</span><span class="symbol">:atomic&lt;int&gt;</span> al2(<span class="number">0</span>); <span class="regexp">//</span><span class="constant">Okay</span>
<span class="symbol">std:</span><span class="symbol">:atomic&lt;int&gt;</span> al3 = <span class="number">0</span>; <span class="regexp">//</span>这就不行了 
</code></pre></li>
<li><p>对于可能在不经意间造成的 类型缩窄(<strong>narrowing convertions</strong>)，可以尝试使用后者来进行杜绝，也就是说，让编译器监督我们是否有类型被缩窄了。</p>
<pre><code><span class="keyword">double</span> x, y, z;
...
<span class="keyword">int</span> sum{ x + y + z }; <span class="comment">// 错误！花括号内表达式的结果是 double</span>
<span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>; <span class="comment">// 这样可以</span>
<span class="keyword">int</span> sum3 = x + y + z; <span class="comment">// 也可以</span>
</code></pre></li>
<li><p>再有一点，涉及到了 C++ 的缺陷，那就是有时候一个表达式可能会引起理解上的混淆(于程序员而言)</p>
<pre><code><span class="comment">// 函数声明 还是 函数调用？</span>
<span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>; <span class="comment">// 这是什么？</span>
<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 这是调用一个 以 10 为参数的Widget的构造函数</span>
</code></pre><p>  很多人看完第二个，会直觉的默认第一个就是调用 Widget的无参构造函数，其实不是，在编译器看来(至少目前是)这是一个函数声明</p>
<p>  那如果要调用无参数构造函数怎么办？</p>
<pre><code><span class="comment">// 新标准下，可以使用后者</span>
<span class="tag">Widget</span> <span class="tag">w2</span>{}; <span class="comment">// 这就调用了 无参的构造函数</span>
</code></pre><p>  当然，后者也有它不好的地方</p>
</li>
<li><p>当构造一个类的时候</p>
<pre><code><span class="keyword">class</span> <span class="title">Widget</span>{
<span class="keyword">public</span>:
    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);
    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> b);
};
<span class="comment">// 调用</span>
<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="keyword">true</span>)</span></span>; <span class="comment">// 调用第一个</span>
Widget w2{<span class="number">10</span>, <span class="keyword">true</span>}; <span class="comment">// 第一个</span>
<span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;  <span class="comment">// 第二个</span>
Widget w4{<span class="number">10</span>, <span class="number">5.0</span>};  <span class="comment">// 第二个</span>
</code></pre><p>  看起来似乎没什么问题，如果加一个构造函数</p>
<pre><code><span class="keyword">class</span> Widget{
<span class="comment">//.. 前方一致</span>
    Widget(<span class="built_in">std</span>::initializer_list&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; il); <span class="comment">//第三个构造函数</span>
};
<span class="comment">// 调用</span>
<span class="function">Widget <span class="title">w1</span><span class="params">(10, <span class="keyword">true</span>)</span></span>; <span class="comment">// 调用第一个</span>
Widget w2{<span class="number">10</span>, <span class="keyword">true</span>}; <span class="comment">// 第三个</span>
<span class="function">Widget <span class="title">w3</span><span class="params">(10, 5.0)</span></span>;  <span class="comment">// 第二个</span>
Widget w4{<span class="number">10</span>, <span class="number">5.0</span>};  <span class="comment">// 第三个    </span>
</code></pre><p>  如果此时再多加一个隐式的转换(重载)，那连拷贝构造函数都会出现意外</p>
<pre><code><span class="keyword">class</span> Widget{
<span class="comment">//.. 前方一致</span>
    <span class="function">operate <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 作用是将这种类型(Widget)转换成 float</span>
}；
<span class="comment">// 使用</span>
<span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>; <span class="comment">// 调用拷贝构造函数</span>
Widget w6{w4};    <span class="comment">// 调用第三个构造函数</span>
<span class="function">Widget <span class="title">w7</span><span class="params">(<span class="built_in">std</span>::move(w4)</span>)</span>; <span class="comment">// 调用移动拷贝构造函数</span>
Widget w8{<span class="built_in">std</span>::move(w4)}; <span class="comment">// 调用第三个构造函数</span>
</code></pre><p>  更让人吃惊的是，即使这么做会让编译无法通过，它(编译器)    依旧会选择匹配以<strong>初始化列表</strong>为类型的构造函数</p>
<pre><code><span class="comment">// 将第三个构造函数改成</span>
<span class="keyword">class</span> Widget{
<span class="comment">// 其他一致</span>
    Widget(<span class="built_in">std</span>::initializer_list&lt;<span class="keyword">bool</span>&gt; il); <span class="comment">// long double -&gt; bool</span>
};
Widget w{<span class="number">10</span>, <span class="number">5.0</span>}; <span class="comment">// 这回，编译出错了！明明有更好的选择，但是出错了。</span>
</code></pre><p>  只有当没有任何途径可以转换类型的情况下，编译器才会舍弃倔强，回到普通的构造函数选择中</p>
<pre><code><span class="comment">// 将第三个构造函数改成</span>
<span class="keyword">class</span> Widget{
<span class="comment">// 其他一致</span>
    Widget(<span class="built_in">std</span>::initializer_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il);
};
<span class="comment">// 调用</span>
<span class="function">Widget <span class="title">w1</span><span class="params">(10, <span class="keyword">true</span>)</span></span>; <span class="comment">// 调用第一个</span>
Widget w2{<span class="number">10</span>, <span class="keyword">true</span>}; <span class="comment">// 第一个</span>
<span class="function">Widget <span class="title">w3</span><span class="params">(10, 5.0)</span></span>;  <span class="comment">// 第二个</span>
Widget w4{<span class="number">10</span>, <span class="number">5.0</span>};  <span class="comment">// 第二个</span>
</code></pre><p>  回到最初，如果使用一个空的 <code>{}</code> 呢？会发生什么，是调用第三个构造函数，还是调用无参构造函数？</p>
<p>  答案是调用 <strong>无参的构造函数</strong></p>
</li>
<li><p>不记录一个和模板有关的信息,以及如何用 <code>{}</code> 传递空参数的记录</p>
</li>
<li>Item 7 结束</li>
</ul>
<h3 id="Item_8_-_prefer_nullptr_to_0_and_NULL">Item 8 - prefer nullptr to 0 and NULL</h3><ul>
<li>首先，对于 <code>0</code> 和 <code>NULL</code> 的使用，是历史遗留的问题，依靠类型转换来勉强维持正确性，但他们究竟是什么类型，特别是后者，根本无法确切得知</li>
<li><code>0</code> 毫无疑问是 <code>int</code>，而 <code>NULL</code> 可以是<code>int</code>，也可以是其他类型，具体看编译器实现。</li>
<li><p><code>nullptr</code> 则是一种新的类型，用来代替前两者，类型是<code>std::nullptr_t</code>，它能够自动转换成通用指针类型。所以它是真正意义上的空指针</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span>)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;
f(<span class="number">0</span>); <span class="comment">// 调用第一个</span>
f(NULL); <span class="comment">// 可能调用第一个，也可能都无法编译通过</span>
f(<span class="keyword">nullptr</span>); <span class="comment">// 调用第三个</span>
</code></pre></li>
<li><p>在模板使用中，就会严格很多</p>
<pre><code><span class="keyword">template</span> &lt;typename <span class="type">FuncType</span>,
            typename <span class="type">MuxType</span>,
            typename <span class="type">PtrType</span>&gt;
<span class="type">auto</span> lockAndCall(<span class="type">FuncType</span> func,
                    <span class="type">MuxType</span> mutex,
                    <span class="type">PtrType</span> <span class="keyword">ptr</span>) -&gt; decltype(func(<span class="keyword">ptr</span>))
{
    <span class="keyword">using</span> <span class="type">MuxGuard</span> = std::lock_guard&lt;std:mutex&gt;;
    <span class="type">MuxGuard</span> g(mutex);
    <span class="keyword">return</span> func(<span class="keyword">ptr</span>);
}
</code></pre><p>  在对这个函数使用的时候，如果我们再将 <code>0</code> 或者 <code>NULL</code> 当作空指针传递的话，就会发生错误，原因就在于，模板类型推断已经限制了进一步的转换。</p>
</li>
<li><p>最后一点就是，要尽量避免 整形 和 指针类型的 函数重载。</p>
</li>
<li>Item 8 结束</li>
</ul>
<h3 id="Item_9_-_Prefer_alias_declarations_to_typedefs">Item 9 - Prefer alias declarations to typedefs</h3><ul>
<li>C++11 后增加一个新的语法，作用和 <code>typedef</code> 十分相似，但是按照说法，它能做的更多更好。</li>
<li><p>首先是两者的共同点</p>
<pre><code><span class="keyword">typedef</span>
<span class="built_in">std</span>::unique_ptr&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;
UPtrMapSS; <span class="comment">// 注意此处有连续的 &gt;&gt; 如果在 C++98下会编译出错，加一个空格即可     </span>
<span class="keyword">using</span> UPtrMapSS = 
<span class="built_in">std</span>::unique_ptr&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;
</code></pre><p>  两种方法最后的效果是一样的，有时候 using 更加清晰</p>
<pre><code><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;
<span class="keyword">using</span> FP = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);
</code></pre><p>  明显那看出第二种写法更加清晰，当然也有人不这么认为，所以在这方面 using 和 typedef 对比并没有谁更优。</p>
</li>
<li><p>真正区分开两者的地方是在<strong>模板</strong>方面</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="keyword">using</span> <span class="type">MyAllocList</span> = std::list&lt;T, <span class="type">MyAlloc</span>&lt;T&gt;&gt;;
// 使用
<span class="type">MyAllocList</span>&lt;<span class="type">Widget</span>&gt; lw; 
</code></pre><p>  如果是在 C++98，只能</p>
<pre><code><span class="keyword">template</span>&lt;class T&gt;
struct <span class="type">MyAllocList</span>{
    typedef std::list&lt;T, <span class="type">MyAlloc</span>&lt;T&gt;&gt; <span class="keyword">type</span>;
};
// 使用
<span class="type">MyAllocList</span>&lt;<span class="type">Widget</span>&gt;::<span class="keyword">type</span> lw;
</code></pre><p>  既然使用了 <code>::</code>，那么自然会引申出在 模板类中的情况：</p>
<p>  例如，在一个模板类中使用上述这个模板的情况</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Widget</span>{
private: 
    typename <span class="type">MyAllocList</span>&lt;T&gt;::<span class="keyword">type</span> list; // 出现了typename
};
</code></pre><p>  此处 <code>typename</code> 的作用就是告诉编译器，接下来这个东西是一个依赖于T的类型，而不是其他东西，如果没有这个 <code>typename</code> 在前方修饰那么编译器就不明白这是个什么东西，因为可能这回事某个类中的 <strong>成员对象</strong>，考虑<strong>模板特例化</strong>的情形。</p>
<p>  那使用 using 的语法就可以直接使用，而不用加 <code>typename</code>了。</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Widget</span>{
private: 
    <span class="type">MyAllocList</span>&lt;T&gt; list;
};        
</code></pre><p>  这里需要注释一下，不要将 <code>using</code> 想象的太乐观，很多情况下即使用了 using，也还是要用 typename 的。例如</p>
<pre><code>// 补例
class outerClass{
public:
    <span class="keyword">using</span> size_type = std::size_t; // 作为一种约定俗成的类似接口的规范
private:
    std::size_t capacity;
};
<span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Widget</span>{
public:
    typename T::size_type call_me() <span class="decorator">{...}</span>
private:
};
</code></pre><p>  这个例子里，即使用了 <code>using</code> ，照样需要告诉编译器，这是一个类型，而编程中经常遇到这种情况。</p>
</li>
<li>接下来涉及了模板元编程，后续再记录。</li>
<li>Item 9 结束</li>
</ul>
<h3 id="Item_10_-_Prefer_scoped_enums_to_unscoped_enums">Item 10 - Prefer scoped enums to unscoped enums</h3><ul>
<li><p>本节讲述的是要尽量使用新标准下的 <strong>Scoped Enum</strong> 代替原来标准的 <strong>UnScoped Enum</strong></p>
<pre><code><span class="comment">// Unscoped enum</span>
<span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>{black, red, white};
auto white = <span class="literal">false</span>;    <span class="comment">// 编译错误</span>

<span class="comment">// Scoped enum</span>
<span class="class"><span class="keyword">enum</span> <span class="title">class</span> Color </span>{black, red, white};
auto white = <span class="literal">false</span>;    <span class="comment">// 编译通过</span>

<span class="comment">//所以</span>
<span class="class"><span class="keyword">enum</span> <span class="title">class</span> Color </span>{black, red, white};
<span class="constant">Color c1</span> = white; <span class="comment">// 错误</span>
<span class="constant">Color c2</span> = Color::white; <span class="comment">// 正确</span>
auto  c3 = Color::white; <span class="comment">// 正确</span>
</code></pre><p>  区别就是这样，当然还有使用上的差异，以及行为上的差异。</p>
<p>  首先，前者具有 <strong>强作用域意识</strong>，什么意思，就是没有命名污染。所以第一句编译错误，因为 <code>white</code> 已经使用过了！而对于第二句中的 <code>white</code> 在全局里并没有出现过，只出现在<code>Color::white</code></p>
</li>
<li><p>对于 <strong>Unscoped enum</strong> 来说，其限制几乎没有</p>
<pre><code><span class="keyword">enum</span> Color {black, white, red};
<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::size_t&gt; primeFactors(<span class="built_in">std</span>::size_t x);

Color c = red;
...
<span class="keyword">if</span>(c &lt; <span class="number">14.5</span>){ <span class="comment">// 发生了隐式类型转换</span>
    <span class="keyword">auto</span> factor = primeFactors(c);
} 
</code></pre><p>  这段代码编译通过，因为 <strong>Unscoped enum</strong> 可以隐式转换为数值类型，包括整形和浮点数。但是如果换成 <strong>Scoped enum</strong> 就不行，必须使用强制类型转换</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Color</span> </span>{black, white, red};
<span class="type">Color</span> <span class="built_in">c</span> = <span class="type">Color</span>::red;
...
<span class="keyword">if</span>(<span class="built_in">c</span> &lt; <span class="number">14.5</span>) { <span class="comment">// 编译失败，因为 c 没办法转换成 double类型</span>
...
</code></pre><p>  解决办法就是：</p>
<pre><code><span class="keyword">if</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c) &lt; <span class="number">14.5</span>) {
...
</code></pre></li>
<li><p>其次，<strong>Unscoped enum</strong> 其不可以只声明不定义，因为编译器无法得知它的大小，至少在 <strong>C++98</strong>标准及以前无法办到</p>
<pre><code><span class="keyword">enum</span> unreach; <span class="comment">// 这是不行的</span>
<span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">reach</span>; <span class="comment">// 可以，因为编译器知道它默认为 sizeof(int)</span>
</code></pre><p>  当然，在 C++11 标准下， 前者同样可以只声明不定义，只需要小小改动：</p>
<pre><code><span class="keyword">enum</span> unreach: <span class="built_in">std</span>::<span class="keyword">int8_t</span>; <span class="comment">// 显式提供大小即可</span>
</code></pre><p>  这个语法对 <strong>Scoped enum</strong> 同样有效，意思就是显式规定了枚举成员的大小类型。</p>
</li>
<li><p>Item 10 结束</p>
</li>
</ul>
<h3 id="Item_11_-_Prefer_delete_function_to_private_undefined_ones">Item 11 - Prefer delete function to private undefined ones</h3><ul>
<li>一共是三个理由</li>
<li>第一个理由，是最熟悉的，如何禁止一个类的拷贝，即拷贝构造函数，例如<code>istream</code>，这是最常用的位置，在<strong>C++98</strong>时代，如果想要禁止一个类的拷贝，那就只能使用一些技巧，将拷贝构造函数声明为 <code>private</code> 级别来达到禁止一定程度上的访问，别无他法。</li>
<li><p>一个类会为我们自动生成一些函数(使用的时候生成)，其中就包括和拷贝相关的，<strong>拷贝构造函数</strong>，<strong>拷贝赋值构造函数</strong>(即重载 <code>=</code> 运算符)，在<strong>C++11</strong>中我们就不需要投机取巧，而是有一个明确的机制来实现这个功能，那就是 <code>=delete</code></p>
<pre><code><span class="comment">// C++98</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> charT, <span class="keyword">class</span> traits = char_trait&lt;charT&gt; &gt;
<span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base {
<span class="keyword">public</span>:
..
<span class="keyword">private</span>:
  basic_ios(<span class="keyword">const</span> basic_ios &amp;);
  basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios &amp;);
};
</code></pre><p>  唯一的办法就是将函数声明为 <code>private</code> 级别，并且不定义它，着能在一定程度上禁止访问该函数，但是如果是 <strong>成员函数</strong> 或者 <strong>友元函数/类</strong> 就无能为力了。所以说这是一种不完善的技巧。</p>
</li>
<li><p>而在<strong>C++11</strong>里，我们可以：</p>
<pre><code><span class="comment">// C++11</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> charT, <span class="keyword">class</span> traits = char_trait&lt;charT&gt; &gt;
<span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base {
<span class="keyword">public</span>:
  basic_ios(<span class="keyword">const</span> basic_ios &amp;) = <span class="keyword">delete</span>;
  basic_ios &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;
 ..
};
</code></pre><p>  这样就完美解决了上述问题，无论怎么样都无法访问这个函数，并且一旦有某个地方试图使用它们，就会生成<strong>编译错误</strong>，帮助我们及早发现问题。</p>
</li>
<li><p>第二个理由</p>
</li>
<li><p>用在一般的函数上，<strong>C++</strong>这中有重载和类型转换这一个概念，而这有时候会带来麻烦：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;
</code></pre><p>  这是一个很普通的函数，如果我们这么调用</p>
<pre><code>isLucky<span class="list">(<span class="quoted">'a</span>')</span><span class="comment">;</span>
isLucky<span class="list">(<span class="keyword">true</span>)</span><span class="comment">;</span>
isLucky<span class="list">(<span class="number">3.5</span>)</span><span class="comment">;</span>
</code></pre><p>  这样能够编译通过并且运行，因为参数都被转换成 <code>int</code> 了，但是有时候我们不需要其他类型该如何做？</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>;
<span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>;
<span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>;
</code></pre><p>  这样就行了，再编译上面的调用，就无法通过了，也就是禁止了这些<strong>隐式转换</strong>的可能。</p>
</li>
<li><p>这个对于模板函数同样通用，例如想要禁止某一种类型的<strong>特例化</strong>，直接 <code>=delete</code>就行。</p>
</li>
<li><p>最后一种情况，实际上是出现在类内的问题，和模板特例化有关。</p>
</li>
<li>在一个类中，如果有一个模板函数，我们不希望出现某种类型的特例化，并且想禁止它，一般会想到可不可以将<strong>模板特例化的声明</strong>写在 <code>private</code> 下，以此来达到禁止的目的，但是实际上是不行的。</li>
<li><p>原因是，模板函数和它的模板特例化必须是在同一个命名空间中，而不能在不同的 <strong>访问级别（public,pretected,private）</strong> 中，所以此法行不通。</p>
<pre><code>class <span class="type">Widget</span> {
public:
  ...
  <span class="keyword">template</span> &lt;typename T&gt;
  <span class="type">void</span> processPointer(T* <span class="keyword">ptr</span>) { ... }

private:
  <span class="keyword">template</span> &lt;&gt;
  <span class="type">void</span> processPointer&lt;&gt;(<span class="type">void</span> *)
</code></pre><p>  这样是不行的，编译都无法通过</p>
</li>
<li><p><strong>C++11</strong>中，我们可以：</p>
<pre><code>class <span class="type">Widget</span> {
public:
  ...
  <span class="keyword">template</span> &lt;typename T&gt;
  <span class="type">void</span> processPointer(T* <span class="keyword">ptr</span>) { ... }
...
};

<span class="keyword">template</span>&lt;&gt;
<span class="type">void</span> <span class="type">Widget</span>::processPointer&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = delete;
</code></pre><p>  这样就关闭了这个函数的 <void> 类型特例化</void></p>
</li>
<li><p>在这里有一个需要特别注意，就是在 <code>delete</code> 一个模板函数的时候，删除函数的某一个特例话只意味着和它完全一致的参数的那种特例化会被禁止，如果加了限定词那就无效了。</p>
<pre><code><span class="keyword">template</span>&lt;&gt;
<span class="type">void</span> <span class="type">Widget</span>::processPointer&lt;<span class="keyword">const</span> volatile double&gt;(<span class="keyword">const</span> volatile double*) = delete; // 第一个
<span class="keyword">template</span>&lt;&gt;
<span class="type">void</span> <span class="type">Widget</span>::processPointer&lt;<span class="keyword">const</span> double&gt;(<span class="keyword">const</span> double*) = delete; // 第二个
<span class="keyword">template</span>&lt;&gt;
<span class="type">void</span> <span class="type">Widget</span>::processPointer&lt;double&gt;(double*) = delete;  // 第三个
</code></pre><p>  从上至下，一一对应范围：</p>
<pre><code>Widget ObjTest;
<span class="keyword">double</span> testDouble = <span class="number">1.0</span>;
<span class="keyword">double</span> * pDouble1 = &amp;testDouble;
<span class="keyword">const</span> <span class="keyword">double</span> * pDouble2 = &amp;testDouble;
<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">double</span> * pDouble3  = &amp;testDouble;
ObjeTest.processPointer(pDouble1); <span class="comment">// 第三个会编译错误</span>
ObjeTest.processPointer(pDouble2); <span class="comment">// 第二个会编译错误</span>
ObjeTest.processPointer(pDouble3); <span class="comment">// 第一个会编译错误</span>
</code></pre><p>  所以如果想禁止某一类型的所有情况，就需要写三个 <code>=delete</code></p>
</li>
<li><p><strong>任何函数都可能会被</strong> <code>=delete</code></p>
</li>
<li>Item 11 结束</li>
</ul>
<p>转载注明: <a href="http://www.wushxin.top/2015/12/15/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0.html" target="_blank" rel="external">http://www.wushxin.top/2015/12/15/Effective-Modern-Cpp-%E6%A6%82%E8%BF%B0.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>(本文有 11 个 Item)</p>
</blockquote>
<h1 id="《Effective_Modern_C++》概要">《Effective Modern C++》概要</h1><ul>
<li>因为 Scott 大大的这本新书迟迟没有中译本，百般无奈之下，选择了英文原版阅读。</li>
<li>记录自己阅读这本书的过程，以及一些细节，知道自己不可能读一遍就能将所有信息记下，故写成博文，方便自己及需要者查阅</li>
<li>本文是我自己的感受，如果有想要体会完整的思想请自行查阅原书，最好配一本完备的C++的语法工具书（例如<code>The C++ Programming Languag, 4th Edition--Bjarne Stroustrup</code>），以便随时查询，当然还需要一个可编程平台。</li>
</ul>
<blockquote>
<p>代码尽量和原书相同，除非是想更详细的解释才会自行修改</p>
</blockquote>
<h2 id="Chapter_1_-_Deducing_Types">Chapter 1 - Deducing Types</h2><h3 id="Item_1_-_Understand_template_type_dedution">Item 1 - Understand template type dedution</h3><ul>
<li>这节讲述了C++有两种类型推断(不许程序员介入)， <strong>自动类型推断(auto type dedution)</strong> 和 <strong>模板类型推断(template type dedution)</strong>， 两者的联系以及唯一的区别。</li>
<li>首先介绍的是模板类型推断，这是来自(C++98)的特性了，现在以及在沿用，是最成功的特性之一。</li>
<li><p>对于模板类型推断，一般形式可归纳为：</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> f(<span class="type">ParamType</span> param);
// 调用
f(<span class="type">expr</span>); // <span class="type">expr</span> 可能是一条语句
</code></pre><p>  <code>ParamType</code> 是一种缩写，用来表示 可能 类型<code>T</code>会有一些限定词来修饰，例如<code>const</code>, <code>&amp;</code> 之类的。</p>
<p>  例如 把<code>ParamType</code> 可以代表 <code>const T &amp;</code></p>
</li>
<li>而此时，编译器在进行 模板类型推断 的时候会做两件事(两个推断的结果)，它会判断 <code>T</code> 和 <code>ParamType</code>的类型分别是什么。当然，如果 <code>ParamType</code> 就是 <code>T</code> 那自然就相同了。</li>
<li>因为 <code>T</code> 究竟是什么，取决于 <code>ParamType</code>。</li>
<li>进行推断的过程中，有三条编译器遵循的判断情况：<ol>
<li><code>ParamType</code> 是一个指针或者引用，但不是一个 通用引用(Universal reference 不知道怎么翻译)。</li>
<li><code>ParamType</code> 是一个 Universal reference</li>
<li><code>ParamType</code>·不是一个指针也不是一个引用· </li>
<li>所以将模板类型推断分为三种情况。</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代TCP/IP网络编程-UDP]]></title>
    <link href="http://www.wushxin.top/2015/12/04/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP.html"/>
    <id>http://www.wushxin.top/2015/12/04/现代TCP-IP网络编程-UDP.html</id>
    <published>2015-12-04T10:23:45.000Z</published>
    <updated>2016-03-25T00:04:56.644Z</updated>
    <content type="html"><![CDATA[<h4 id="UDP_的_connect()">UDP 的 connect()</h4><ul>
<li>前方提到，如果使用的是 UDP 套接字进行通信的话，可以采取 <code>connect</code> 来进行优化，但是却不知原因。</li>
<li>首先 <strong>UDP</strong> 的别称叫做 <strong>不可靠连接</strong>， 也就是说它可以不需要对发送出去的数据负责任，在默认情况下这是对的，因为“效率”。</li>
<li>但是如果一个 <strong>UDP</strong> 套接字端 需要与另一个端进行多于一次的通信的时候，就会出现性能问题：<ul>
<li>具体是： <code>连接两端通信 -&gt; 发送数据 -&gt; 断开连接 -&gt; 连接两端通信 -&gt; 发送数据 -&gt; 断开连接 ......</code></li>
<li>可以看出，需要重复的进行 连接和断开， 且这两个操作都是涉及 <strong>内核</strong> 操作，耗费的资源不可忽略</li>
<li>所以在必要时对 <strong>UDP</strong> 套接字调用 <code>connect</code>，是有必要的(并不硬性要求两端同时都要调用 <code>connect</code>)</li>
<li>需要注意的是 <strong>TCP</strong>套接字 同样需要调用(必须调用) <code>connect</code>，虽然调用的函数接口一样，但是意义却是不相同的，前者是为了三次握手建立连接，而 <strong>UDP</strong>却只是为了能够省去 不必要的断开连接 以及接收到 <strong>ICMP错误报文</strong>。</li>
</ul>
</li>
<li><strong>ICMP</strong>错误报文，指的是如果对端没办法接收到本端发送的信息的话，会返回一个错误，这个错误使用的就是<strong>ICMP</strong>(ICMPv4和ICMPv6两种)<ul>
<li>如果 <strong>UDP</strong> 套接字通信时采用的是 未连接(unconnected) 的形式，那么在调用 <code>sendto</code> 接口之后，不管对端有没有收到信息，都会立即返回成功的信息，而即使对端没办法收到信息，且向本端发送了 <strong>ICMP</strong> 报文，我们也是无法检测到的。</li>
<li>但是如果 <strong>UDP</strong> 套接字通信时采用的是 连接(connected) 的形式，那么就会接收到一个 <code>EHOSTUNREACH</code> 的错误，我们就能够捕捉到(这点与TCP的处理方式一样)。</li>
</ul>
</li>
<li>假设我们想要断开连接 或者 重新选择一个对端进行通信，也是可以的<ul>
<li>所需要做的也仅仅是在此调用一下 <code>connect</code> 接口函数<pre><code><span class="keyword">struct</span> sockaddr_storage unconnect;
<span class="built_in">memset</span>(&amp;unconnect, <span class="number">0</span>, <span class="keyword">sizeof</span> unconnect);
unconnect.ss_family = AF_UNSPEC; <span class="comment">/* 将 xxx_family 位置为 AF_UNSPEC 就表明要断开连接 */</span>
connect(udp_sock, (<span class="keyword">struct</span> sockaddr *)&amp;unconnect, <span class="keyword">sizeof</span> unconnect); <span class="comment">/* 断开连接 */</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>注： 断开连接或者重新对套接字建连接是 UDP 才可以使用的，千万不要用在 TCP套接字上面！</p>
<p>不要疑惑，每次发送的时候只指定了对端的 IP 和 端口，那我们自己的 IP 和端口呢？这个是由内核为我们完成，自动化就是这么方便</p>
</blockquote>
<ul>
<li>和 <strong>TCP</strong> 这种面向连接的方式不同， <strong>UDP</strong> 不管是否是连接的(connected)，它依旧是一种不可靠的传输方式，所以当它调用 <code>connect</code> 时，即使对端没有运行，这个函数也不会有任何错误，知道发送第一条信息时才能知道对端到底可不可达。<a id="more"></a>
<h4 id="那些通用的操作">那些通用的操作</h4></li>
<li><p>在上述记录的代码中，最主要的过程莫过于，<strong>创建套接字</strong>， <strong>绑定</strong>， <strong>连接</strong>， <strong>发送/接收</strong>， <strong>关闭</strong>， 这过程中使用的都是由操作系统提供给程序员的接口，但前方并未详细记录。此处给出</p>
</li>
<li><p><code>socket()</code></p>
<pre><code>/<span class="keyword">*</span> 此处，该接口调用成功则返回 描述符(<span class="keyword">*</span>nix 下的概念), 否则错误的话返回 -1 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> <span class="comment">@param family   用来指定IP的协议族 也就是IP地址的类型</span>
<span class="keyword">*</span> <span class="comment">@param type     调用该接口想要创建什么类型的套接字，例如是 TCP 的还是 UDP 的，等等？</span>
<span class="keyword">*</span> <span class="comment">@param protocol 一般传入0作为参数，代表任意都接受的意思，实际上有三个选择。</span>
<span class="keyword">*</span>/
int socket(int family, int type, int protocol);
</code></pre></li>
</ul>
<table>
<thead>
<tr>
<th>family</th>
<th>选择</th>
<th>type</th>
<th>选择</th>
<th>protocol</th>
<th>选择</th>
</tr>
</thead>
<tbody>
<tr>
<td>  AF_INET</td>
<td>IPv4地址族</td>
<td>SOCK_STRAAM</td>
<td>代表TCP</td>
<td>IPPROTO_TCP</td>
<td>TCP的协议</td>
</tr>
<tr>
<td>  AF_INET6</td>
<td>IPv6地址族</td>
<td>SOCK_DGRAM</td>
<td>代表UDP</td>
<td>IPPROTO_UDP</td>
<td>UDP的协议</td>
</tr>
<tr>
<td>  …</td>
<td>剩下的暂时不记录</td>
<td>SOCK_RAW</td>
<td>用于更底层的实现</td>
<td>…</td>
<td></td>
</tr>
<tr>
<td>  …</td>
<td></td>
<td>..</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>  注</td>
<td>…代表还有可用选项，但不予记录</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>这里引出了 <strong>Windows</strong> 和 <strong>*nix</strong> 的一点小差异，那就是 <code>socket</code>的返回值问题</li>
<li><p>如果正确且成功的调用了这个函数，其会返回一个 句柄(Windows) 或者 文件描述符(*nix)</p>
<ul>
<li>我们知道，在 <strong> *nix </strong> 操作系统中，任何的一切都被视为文件，包括套接字，所以由 <code>socket()</code>调用后返回的<strong>文件描述符的值</strong>也遵循着这个规则： <code>从 0 开始依次递增的一个整形值</code> ，所以当我们使用 <code>select(后续会提到的一个重要概念)</code>，可以很方便的将最后得到的文件描述符的值，当成搜索范围。</li>
<li><strong>Windows</strong>下，句柄实质是也是一种整形，但是其值就不是程序员想象中的<strong>从零有序的向前递增</strong>了，而是由操作系统来自行决定，程序员无法预测，所以在 调用 <code>select</code> 的时候，会稍微有一些差异。</li>
</ul>
</li>
<li><p><code>connect</code></p>
<ul>
<li>在此处不详细记录，因为在 TCP 中，其作用更加重要<pre><code><span class="comment">/* UDP 中该函数的作用十分单一，就是将IP和端口注册进套接字，且可对同一个套接字重复调用 */</span>
<span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,  
          <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * servaddr,
                        socklen_t addrlen)</span></span>;
</code></pre></li>
</ul>
</li>
<li><p><code>bind</code></p>
<ul>
<li>这个接口一般用于 接收端 或者 称为服务端 的地方，具体作用在一般情况下是为制定一个<strong>具体的监听端口</strong>， 当然也可以指定具体的 IP地址，但是一般不这么做(并非绝对)，因为我们大部分时候是想要接收来自四面八方的各地IP主机的访问。<pre><code>/<span class="keyword">*</span> 通过在 myaddr指向的结构体中 填入 端口号 和 IP地址来达到 绑定的目的 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> <span class="comment">@param sockfd 用于绑定的套接字</span>
<span class="keyword">*</span> <span class="comment">@param myaddr 在前方准备好的信息地址结构体</span>
<span class="keyword">*</span> <span class="comment">@param len    这个结构体的长度</span>
<span class="keyword">*</span> 实际上，信息地址结构体在 getaddrinfo 这个接口没有出现之前是需要自己填写的，但是现在却省去很多工作
<span class="keyword">*</span>/
int bind(int sockfd, const struct sockaddr <span class="keyword">*</span> myaddr, socklen_t len);
/<span class="keyword">*</span>
<span class="keyword">*</span> 提到的省去的工作就是对 信息结构体的填入工作
<span class="keyword">*</span> 在最原始操作中有一个操作是 让该监听套接字 接收来自任意 IP 的访问
<span class="keyword">*</span>/
...
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IPv4 类型的 IP <span class="keyword">*</span>/
recv_host.sin6_addr = in6addr_any; /<span class="keyword">*</span> 接收任意的IPv6 类型的 IP <span class="keyword">*</span>/
...
/<span class="keyword">*</span> 上述操作需要自行填写，十分不便，但是在调用getaddrinfo接口，且设置了相应的 flags以后，其会自动帮你设置这个选项，也就不需要程序员操心 <span class="keyword">*</span>/
/<span class="keyword">*</span> 直接使用 bind(sockfd, result-&gt;ai_addr, result-&gt;ai_addrlen); <span class="keyword">*</span>/
</code></pre></li>
</ul>
</li>
<li><p><code>sendto</code></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> * buff, size_t nbytes,  <span class="comment">/* 用于"监听"的套接字，将要发送的信息存储首地址，信息的长度 */</span>
              <span class="keyword">int</span> flags, <span class="comment">/* 暂时忽略 */</span>
              <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * to, socklen_t addrlen)</span></span>; <span class="comment">/* 目的段的地址信息， 这个结构体的长度 */</span>
</code></pre><ul>
<li><p>一般而言，对于服务端(接收端)的UDP而言，会显式的调用 bind 函数，进行绑定一个地址(通配地址或者指定一个地址，这对于一台由多个网卡组成的主机有意义)以及端口号<br>对于普通的服务器而言，直接设定 统配地址( <code>INADDR_ANY</code>或<code>in6addr_any</code> ) 即可，系统会自动帮你选择有效的 地址端口绑定到 套接字上。</p>
</li>
<li><p>但，对于没有显式调用 <code>bind</code> 函数的UDP 客户端(发送端)而言，在创建了套接字(调用<code>socket()</code>)之后，得到的套接字是没有地址和端口信息的，其真正获得这些信息的时候就是在 <code>sendto</code>函数调用的时候，它会隐式的为 <code>sockfd</code> 绑定上 <strong>通配地址</strong>，并选择一个临时端口。</p>
</li>
<li><p><code>flags</code></p>
<ul>
<li><code>MSG_DONTWAIT</code>, <code>MSG_OOB</code>, <code>MSG_PEEK</code>, ‘MSG_ERRQUEUE’, <code>MSG_TRUNC</code>, <code>MSG_WAITALL</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>recvfrom</code></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> * buff, size_t nbytes,
            <span class="keyword">int</span> flags
            <span class="keyword">struct</span> sockaddr * <span class="keyword">from</span>, socklen_t * len)</span></span>; <span class="comment">/* 另一端的地址信息，以及长度 */</span>
</code></pre><ul>
<li>用于接收信息，如果最后两个参数为 <code>NULL</code>，就代表不想要知道对端的信息。也就没有办法回复信息给对方。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注： sendto / recvfrom 并不是 UDP 专用，而是协议无关的函数接口，也就是说同样可以将这两个接口用于 TCP 套接字，只需要将最后两个参数设置为 NULL即可</p>
<p>至于有没有必要，就仁者见仁智者见智了。</p>
</blockquote>
<p>转载注明: <a href="http://www.wushxin.top/2015/12/04/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP.html" target="_blank" rel="external">http://www.wushxin.top/2015/12/04/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="UDP_的_connect()">UDP 的 connect()</h4><ul>
<li>前方提到，如果使用的是 UDP 套接字进行通信的话，可以采取 <code>connect</code> 来进行优化，但是却不知原因。</li>
<li>首先 <strong>UDP</strong> 的别称叫做 <strong>不可靠连接</strong>， 也就是说它可以不需要对发送出去的数据负责任，在默认情况下这是对的，因为“效率”。</li>
<li>但是如果一个 <strong>UDP</strong> 套接字端 需要与另一个端进行多于一次的通信的时候，就会出现性能问题：<ul>
<li>具体是： <code>连接两端通信 -&gt; 发送数据 -&gt; 断开连接 -&gt; 连接两端通信 -&gt; 发送数据 -&gt; 断开连接 ......</code></li>
<li>可以看出，需要重复的进行 连接和断开， 且这两个操作都是涉及 <strong>内核</strong> 操作，耗费的资源不可忽略</li>
<li>所以在必要时对 <strong>UDP</strong> 套接字调用 <code>connect</code>，是有必要的(并不硬性要求两端同时都要调用 <code>connect</code>)</li>
<li>需要注意的是 <strong>TCP</strong>套接字 同样需要调用(必须调用) <code>connect</code>，虽然调用的函数接口一样，但是意义却是不相同的，前者是为了三次握手建立连接，而 <strong>UDP</strong>却只是为了能够省去 不必要的断开连接 以及接收到 <strong>ICMP错误报文</strong>。</li>
</ul>
</li>
<li><strong>ICMP</strong>错误报文，指的是如果对端没办法接收到本端发送的信息的话，会返回一个错误，这个错误使用的就是<strong>ICMP</strong>(ICMPv4和ICMPv6两种)<ul>
<li>如果 <strong>UDP</strong> 套接字通信时采用的是 未连接(unconnected) 的形式，那么在调用 <code>sendto</code> 接口之后，不管对端有没有收到信息，都会立即返回成功的信息，而即使对端没办法收到信息，且向本端发送了 <strong>ICMP</strong> 报文，我们也是无法检测到的。</li>
<li>但是如果 <strong>UDP</strong> 套接字通信时采用的是 连接(connected) 的形式，那么就会接收到一个 <code>EHOSTUNREACH</code> 的错误，我们就能够捕捉到(这点与TCP的处理方式一样)。</li>
</ul>
</li>
<li>假设我们想要断开连接 或者 重新选择一个对端进行通信，也是可以的<ul>
<li>所需要做的也仅仅是在此调用一下 <code>connect</code> 接口函数<pre><code><span class="keyword">struct</span> sockaddr_storage unconnect;
<span class="built_in">memset</span>(&amp;unconnect, <span class="number">0</span>, <span class="keyword">sizeof</span> unconnect);
unconnect.ss_family = AF_UNSPEC; <span class="comment">/* 将 xxx_family 位置为 AF_UNSPEC 就表明要断开连接 */</span>
connect(udp_sock, (<span class="keyword">struct</span> sockaddr *)&amp;unconnect, <span class="keyword">sizeof</span> unconnect); <span class="comment">/* 断开连接 */</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>注： 断开连接或者重新对套接字建连接是 UDP 才可以使用的，千万不要用在 TCP套接字上面！</p>
<p>不要疑惑，每次发送的时候只指定了对端的 IP 和 端口，那我们自己的 IP 和端口呢？这个是由内核为我们完成，自动化就是这么方便</p>
</blockquote>
<ul>
<li>和 <strong>TCP</strong> 这种面向连接的方式不同， <strong>UDP</strong> 不管是否是连接的(connected)，它依旧是一种不可靠的传输方式，所以当它调用 <code>connect</code> 时，即使对端没有运行，这个函数也不会有任何错误，知道发送第一条信息时才能知道对端到底可不可达。]]>
    
    </summary>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
      <category term="网络编程" scheme="http://www.wushxin.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代TCP/IP网络编程-启航]]></title>
    <link href="http://www.wushxin.top/2015/10/30/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%90%AF%E8%88%AA.html"/>
    <id>http://www.wushxin.top/2015/10/30/现代TCP-IP网络编程-启航.html</id>
    <published>2015-10-30T10:16:53.000Z</published>
    <updated>2016-03-25T00:04:39.873Z</updated>
    <content type="html"><![CDATA[<h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的，实际上还有一个但这里不记录。</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code><a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>概念模糊的 <strong>DNS</strong><ul>
<li>其实很简单，它的作用就是用来找到域名所对应的 <strong>IP地址</strong></li>
<li>为什么？因为 <strong>IP地址</strong> 太难记了！如果你觉得 <strong>IPv4</strong> 地址还难不倒你，那请你试试 <strong>IPv6</strong></li>
<li>怎么查看域名对应的 <strong>IP地址</strong>，当然先不考虑 <strong>CDN</strong><ul>
<li><code>*nix</code> 和 <code>Windows</code> 都可以通过 <code>ping &lt;domain name&gt;</code> 命令进行查询</li>
</ul>
</li>
</ul>
</li>
<li><strong>MAC地址</strong> 和 <strong>端口号</strong><ul>
<li>对于前者，实际上应该是最熟悉不过的，对于网络上的主机而言，每一台主机就有一个专属的 <strong>MAC地址</strong></li>
<li>后者则是相当于一个房子的门，这个比喻在各大教材中广泛引用，但也的确贴切，假设 <strong>IP地址</strong> 是房子的地址，那么到了别人家要知道门在哪才行。</li>
</ul>
</li>
</ul>
<p>一个完整的应用程序传输数据时候 <strong>封装</strong> 的过程(<strong>从右二向左依次封装</strong>)：</p>
<table>
<thead>
<tr>
<th>以太网首部</th>
<th>IP</th>
<th>TCP/UDP</th>
<th>真实数据</th>
<th>尾部</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC地址</td>
<td>IP地址</td>
<td>TCP或者UDP协议</td>
<td>应用程序数据</td>
<td>效验码</td>
</tr>
<tr>
<td>源和目的MAC地址以及</td>
<td>及前层协议类型</td>
<td>源和目的端口号及前层应用程序首部信息</td>
<td>应用软件信息和真正的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中端口号实际上就是 <strong>应用程序的信息</strong></p>
<p>接收数据时的 <strong>拆解</strong> 顺序与 <strong>封装</strong> 正好相反。</p>
<ul>
<li><p>其中在传输过程中，作为接收方最开始使用的是 <strong>网络接口层/数据链路层</strong> 的驱动程序(即操作系统自带或另行安装，总之不用使用的程序员写就对了)，来判断这个包是否属于我，判断的依据就是 <strong>MAC地址</strong>，如果是再判断什么协议</p>
<ul>
<li>在此处的协议可不止 <strong>IP协议</strong>， 也可能是 <strong>ARP协议</strong> 等。之后就是就事论事交给相应的处理软件去处理(拆解)就行</li>
<li>科普： MAC地址是 <code>48bit</code> 的， 前<code>24bit</code>由 <strong>IEEE</strong> 分配， 后<code>24bit</code> 由厂商分配。原则上是唯一的。</li>
</ul>
</li>
<li><p><strong>MAC地址</strong> 和 <strong>IP地址</strong></p>
<ul>
<li>既然前方说到 <strong>MAC地址</strong> 和 <strong>IP地址</strong> 都能够作为识别另一个主机的唯一标识，但是为什么需要有两个相同功能的东西？</li>
<li>是，在一开始，网络很小的情况下，例如我们在同一个局域网中，我们之间需要<strong>通信</strong>的时候，只需要使用ARP协议，进行<strong>广播</strong>，向在一个网络中的所有主机发送消息就行，剩下的就让其他主机去判断(通过<strong>MAC地址</strong>)这个数据是不是发给我的。<ul>
<li><strong>ARP协议</strong> 的作用就是在同一个网络中，通过 <strong>广播</strong> 找出符合自己要求的主机的 <strong>MAC地址</strong> ，如果不在同一个网络中，又想知道对方的 <strong>MAC地址</strong>， 那只能借助把每个网络链接在一起的 <strong>网关</strong> 来帮助你发送 。 总之进行网络通信时必须知道对方的 <strong>IP地址 和 MAC地址</strong></li>
</ul>
</li>
<li>但是如果是现在整个互联网呢？不算 <strong>IPv6</strong> ，就算 <strong>IPv4</strong> 也是几十亿的存在，如果我从中国向国外发送信息，广播整个互联网的所有主机，那就炸了！</li>
<li>所以我们需要对世界网络进行分区，让大区域包含小区域，就像<strong>国家-省-市区…</strong> ， 很遗憾的是 <strong>MAC地址</strong> 是跟计算机相关而不是和位置相关的。所以我们有了 <strong>IP协议</strong></li>
<li><strong>IP协议</strong> 所附带的产品 <strong>IP地址</strong> 的作用就在帮助计算机识别自己是否在同一个网络中( <strong>这里省略了子网掩码的作用</strong> )。</li>
</ul>
</li>
<li><p>实际上，在进行网络编程的时候，以上细节几乎都被隐藏起来，留给我们的只是可供使用的接口。</p>
</li>
</ul>
<blockquote>
<p>也许，许多大学计算机基础课程，会讲到 IP地址 有种类，分为 A,B,C…类，老师还介绍了各种类型的地址范围。</p>
<p>但是在现代，这种分类早已经失效，或者说正在逐渐消失，因为当下的 IP 地址的 子网掩码 可以是任意位，并以反斜杠跟在 IP地址后方。</p>
<p>现代的 IP地址 形式一般如此 1.185.223.1/24 代表着子网掩码是由 24个 从左至右连续的的二进制1 组合而成，其余位为0。</p>
</blockquote>
<h2 id="夹在中间">夹在中间</h2><blockquote>
<p>事实上有一些实用且挺炫酷的函数，可以先提一下</p>
</blockquote>
<ul>
<li>域名 和 IP地址 的互查<ul>
<li><code>gethostbyname</code> 用于域名查找 IP信息及各类信息<ul>
<li><code>struct hostent * gethostbyname(const char * hostname)</code></li>
<li><code>struct hostent</code> 是存储查找到的各类型信息，后方会有介绍</li>
<li><code>hostname</code> 即要查询的域名</li>
</ul>
</li>
<li><code>gethostbyaddr</code> 用于IP地址查找 域名及各类信息<ul>
<li><code>struct hostent * gethostbyaddr(const char * addr, socklen_t len, int family)</code><ul>
<li><code>addr</code> 是要查询的 IP地址，之所以是 <code>const char *</code> 是因为C语言历史遗留的原因，实际上其类型应为 <code>struct in_addr *</code>(IPv4)</li>
<li><code>len</code> 地址的长度，即 <strong>IPv4</strong> 为4， <strong>IPv6</strong> 为16</li>
<li><code>family</code> 即协议的种类， <strong>IPv4</strong> 为 <code>AF_INET</code>, <strong>IPv6</strong> 为 <code>AF_INET6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>struct hostent 的成员</th>
<th>.</th>
<th>类型</th>
<th>.</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>h_name</td>
<td></td>
<td>char *</td>
<td></td>
<td>官方名称</td>
</tr>
<tr>
<td>h_aliases</td>
<td></td>
<td>char **</td>
<td></td>
<td>域名集合，以NULL结尾</td>
</tr>
<tr>
<td>h_addrtype</td>
<td></td>
<td>int</td>
<td></td>
<td>地址族的类型 AF_INET 或 AF_INET6</td>
</tr>
<tr>
<td>h_length</td>
<td></td>
<td>int</td>
<td></td>
<td>地址的长度 4 或 16</td>
</tr>
<tr>
<td>h_addr_list</td>
<td></td>
<td>char **</td>
<td></td>
<td>IP的集合，以NULL结尾, 实际上每个元素的类型为 struct in_addr*</td>
</tr>
</tbody>
</table>
<ul>
<li>其中第二和最后一个是关注的重点所在，可以在调用函数之后，输出信息<blockquote>
<p>实际上，这并不是一个好的方法，在后方将记录 现代人的我们 该如何做到这些事情，以上只是以前的TCP/IP 编程</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>只适用于 IPv4</p>
</blockquote>
<h2 id="套接字网络编程初始">套接字网络编程初始</h2><blockquote>
<p>选择使用 C 语言进行编程</p>
</blockquote>
<ul>
<li>在网络编程中，最常实用的两种连接方式 <code>TCP</code> 和 <code>UDP</code></li>
<li>最常编程的平台 <code>POSIX 标准-&gt;*nix平台标准</code> 和 <code>Windows 平台标准</code><ul>
<li>实际上，后者也是参考前者进行一些细微的改变(<strong>指的是接口</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比两种不同连接方式的不同地位的创建，使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP服务器</th>
<th>TCP客户端</th>
<th>UDP服务器</th>
<th>UDP客户端</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>创建套接字</td>
</tr>
<tr>
<td>bind()</td>
<td></td>
<td>bind()</td>
<td>bind()</td>
<td>绑定所分配IP地址和端口号</td>
</tr>
<tr>
<td>listen()</td>
<td>connect()</td>
<td></td>
<td></td>
<td>客户端则绑定IP地址和端口号，并等待连接；服务器则是等待连接</td>
</tr>
<tr>
<td>accept()</td>
<td></td>
<td></td>
<td></td>
<td>服务器接受连接</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>sendto/recvfrom()</td>
<td>sendto/recvfrom()</td>
<td>对于UDP即是连接也是操作</td>
</tr>
<tr>
<td>close()</td>
<td>close()</td>
<td>close()</td>
<td>close</td>
<td>双向直接关闭连接</td>
</tr>
<tr>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>可选择方向的关闭连接,即更加灵活</td>
</tr>
</tbody>
</table>
<p>如此对比虽然有一些小瑕疵，但是能够大体上反映出真个网络编程上不同方式的区别</p>
<blockquote>
<p>注1： 对于  sendto recvfrom 这两个接口函数，并不一定是只能用在 UDP类型的 套接字上，同样 TCP类型的 套接字也能使用，但是这么做并没有什么意义。</p>
<p>注2： 实际上 UDP 没有所谓的 服务器和和护短，因为本来就是单纯的互相发来发去。<strong>客户端端口</strong> 一般是随机的</p>
<p>以上是 *nix平台下的标准， Windows下的操作方式和 API有细微不同，但大部分是一致的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Windows</th>
<th>*nix</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
</tr>
<tr>
<td>bind()</td>
<td>bind()</td>
</tr>
<tr>
<td>connect()</td>
<td>connect()</td>
</tr>
<tr>
<td>listen()</td>
<td>listen()</td>
</tr>
<tr>
<td>accept()</td>
<td>accept()</td>
</tr>
<tr>
<td>closesocket()</td>
<td>close()</td>
</tr>
<tr>
<td>send()</td>
<td>send()</td>
</tr>
<tr>
<td>read()</td>
<td>read()</td>
</tr>
<tr>
<td>sendto()</td>
<td>sendto()</td>
</tr>
<tr>
<td>recvfrom()</td>
<td>recvfrom()</td>
</tr>
</tbody>
</table>
<p>不仅仅是接口名字相同，参数个数以及功能也是一致，即使有一个例外，其参数以及使用方法也相同。</p>
<blockquote>
<p>那岂不是可以直接移植了？</p>
<p>并不！</p>
</blockquote>
<p>在 <strong> Windows 套接字编程时</strong> ， 由于 <code>Windows</code> 将其实现为动态库，所以在使用时需要将其加载进程序。</p>
<p>故而多加了加载操作。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(
  WORD      wVersionRequested,
  LPWSADATA lpWSAData  <span class="comment">/* 这是一个结构体， 传入类型为WSADATA*  */</span>
)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>每当在 <strong>Windows</strong> 上进行套接字编程时，总要指定某个版本的套接字库：</p>
<pre><code>WSADATA wsaData;
int err_code;
/<span class="keyword">*</span>
<span class="keyword">*</span> MAKEWORD()的作用在于将版本号转为指定格式传入
<span class="keyword">*</span> 当下(2015-10)套接字库的版本号最高是 2.2
<span class="keyword">*</span>/
err_code = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
/<span class="keyword">*</span> TODO Something <span class="keyword">*</span>/
WSACleanup();
</code></pre><p>这是最基本的在 <strong>Windows</strong> 上使用 <strong>套接字</strong> 编程的流程，但是如果本平台的套接字库最高版本并不符合当前要求呢？</p>
<p>那么首先会将套接字版本库尽可能设置到平台的 <strong>最高版本</strong> ，可以通过结构体 <code>WSADATA</code> 进行查询</p>
<pre><code><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)
{
  <span class="built_in">printf</span>(<span class="string">"Could not find a usable version of Winsock.dll\n"</span>);
  WSACleanup();
  <span class="built_in">return</span> <span class="number">1</span>;
}
</code></pre><blockquote>
<p>总体而言， <code>Windows平台</code> 和 <code>*uix平台</code> 的区别在于，前者使用时需要 加载和清除 套接字库<br>其余逻辑流程一致，毕竟只有统一才能越利于编程世界的发展。</p>
</blockquote>
<h2 id="套接字编程">套接字编程</h2><ul>
<li>两种协议 <code>TCP</code> 和 <code>UDP</code><ul>
<li>前者可以理解为有保证的连接，后者是追求快速的连接</li>
<li>当然最后一点有些 <strong>太过绝对</strong> ，但是现在不需熬考虑太多，因为初入套接字编程，一切从简</li>
<li>稍微试想便能够大致理解， <code>TCP</code> 追求的是可靠的传输数据， <code>UDP</code> 追求的则是快速的传输数据</li>
<li>前者有繁琐的连接过程，后者则是根本不建立可靠连接(不是绝对)，只是将数据发送而不考虑是否到达。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下例子以 <code>*nix</code> 平台的便准为例，因为 <code>Windows</code>平台需要考虑额外的加载问题，稍作添加就能在 Windows 平台上运行</p>
</blockquote>
<h3 id="UDP">UDP</h3><ul>
<li><p><code>UDP</code></p>
<ul>
<li>这是一个十分简洁的连接方式，假设有两台主机进行通信，一台只发送，一台只接收。</li>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in recv_host, send_host;

/<span class="keyword">*</span> 创建套接字 <span class="keyword">*</span>/
sock = socket(PF_INET, SOCK_DGRAM, 0);

/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
memset(&amp;recv_host, 0, sizeof(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);

/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><p>上述代码省略了许多必要的 <strong>错误检查</strong> ，在实际编写时要添加</p>
</li>
<li>代码解释：<ol>
<li><strong>PF_INET</strong> 代表协议的类型，此处代表 <strong>IPv4</strong> 网络协议族， 同样 <strong>PF_INET6</strong> 代表 <strong>IPv6</strong> 网络协议族，这个范围在后方单独记录，不与IPv4混在一起(并不意味着更复杂，实际上更简便)。</li>
<li><strong>AF_INET</strong> 代表地址的类型，此处代表 <strong>IPv4</strong> 网络协议使用的地址族， 同样有 <strong>AF_INET6</strong> (在操作系统实现中 PF_INET 和 AF_INET 的值一样，<strong>但是还是要写宏更好，而不应该直接用数字或者，混淆使用</strong>)</li>
<li><code>htonl</code> 和 <code>htons</code> 两个函数的使用涉及到 <strong>大端小端问题</strong>， 这里不叙述，需要记住的是在网络编程时一定要使用这种函数将必要信息转为 <strong>大端表示法</strong> 。</li>
<li><code>(struct sockaddr *)</code> 这个强制转换是为了参数的必须，但不会出错，因为 <code>sizeof(struct sockaddr_in) == sizeof(struct sockaddr)</code> 具体可以查询相关信息，之所以这么做是为了方便编写套接字程序的程序员。</li>
</ol>
</li>
<li>发送端：<pre><code><span class="keyword">int</span> sock;
<span class="keyword">const</span> <span class="keyword">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="keyword">char</span> get_mess[GET_MAX]; <span class="comment">/* 后续版本使用 */</span>
<span class="keyword">struct</span> sockaddr_in recv_host;
socklen_t addr_len;
<span class="comment">/* 创建套接字 */</span>
sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);
<span class="comment">/* 绑定 */</span>
<span class="built_in">memset</span>(&amp;recv_host, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
<span class="comment">/* 发送信息 */</span>
<span class="comment">/* 在此处，发送端的IP地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */</span>
sendto(sock, mess, <span class="built_in">strlen</span>(mess), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 完成，关闭 */</span>
close(sock);
</code></pre>上述代码是发送端。</li>
<li>代码解释：<ol>
<li><code>inet_addr</code> 函数是用于将字符串格式的 <strong>IP地址</strong> 转换为 大端表示法的 地址类型，即 <code>s_addr</code> 的类型 <code>in_addr_t</code></li>
<li>与之相反，同样也有功能相反的函数 <code>inet_ntoa</code> 用于将 <code>in_addr_t</code> 类型转为字符串，但是使用时一定要记住及时拷贝返回值<pre><code><span class="type">char</span> <span class="keyword">addr</span>[<span class="number">16</span>];
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
strcpy(<span class="keyword">addr</span>, inet_ntoa(recv_host.sin_addr.s_addr));
</code></pre></li>
</ol>
</li>
<li>从上述代码看出， <code>UDP</code> 协议的使用十分简洁，几乎就是 <strong>创建套接字-&gt;准备数据-&gt;装备套接字-&gt;发送/接收-&gt;结束</strong></li>
<li>其中，都没有连接的操作，但是实际上这是为了方便 <code>UDP</code> 随时和 <strong>不同的主机</strong> 进行通信所默认的设置，如果需要和相同主机一直通信呢？</li>
<li>此中的原由<strong>暂时不需要</strong>知道，记录方法，即长时间使用 <code>UDP</code> 和同一主机通信时，可以使用 <code>connect</code> 函数来进行优化自身。此时 <strong>假设两台主机的实际功能一致，既接收也发送</strong></li>
<li>发送端：<pre><code><span class="comment">/* 前方高度一致，将 bind函数替换为 */</span>
connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host); <span class="comment">// 将对方的 IP地址和 端口号信息 注册进UDP的套接字中)</span>
<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 循环的发送和接收信息 */</span>
{
  size_t read_len = <span class="number">0</span>;
  <span class="comment">/* 原先使用的 sendto 函数，先择改为使用 write 函数， Windows平台为 send 函数 */</span>
  write(sock, mess, <span class="built_in">strlen</span>(mess));            <span class="comment">/* send(sock, mess, strlen(mess), 0) FOR Windows Platform */</span>
  read_len = read(sock, get_mess, GET_MAX-<span class="number">1</span>); <span class="comment">/* recv(sock, mess, strlen(mess)-1, 0) FOR Windows Platform */</span>
  get_mess[read_len-<span class="number">1</span>] = <span class="string">'\0'</span>;
  <span class="built_in">printf</span>(<span class="string">"In Client like Host Recvive From Other Host : %s\n"</span>, get_mess);
}
<span class="comment">/* 后方高度一致 */</span>
</code></pre></li>
<li>接收端：<pre><code>/<span class="keyword">*</span> 前方一致， 添加额外的 struct sockaddr_in send_host; 并添加循环，构造收发的现象<span class="keyword">*</span>/
while(1)
{
  size_t read_len = 0;
  char sent_mess[15] = <span class="string">"Hello Sender!"</span>; /<span class="keyword">*</span> 用于发送的信息 <span class="keyword">*</span>/
  sendto(sock, mess, strlen(sent_mess), 0, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
  read_len = recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len)
  mess[read_len-1] = '\0';
  printf(<span class="string">"In Sever like Host Recvive From other Host : %s\n"</span>, mess);
}
/<span class="keyword">*</span> 后方高度一致 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> 之所以只在接收端使用 connect 的原因，便在于我们模拟的是 客户端-服务器 的模型，而服务器的各项信息是不会随意变更的
<span class="keyword">*</span> 但是 客户端就不同了，可能由于 ISP(Internet Server Provider) 的原因，你的IP地址不可能总是固定的，所以只能
<span class="keyword">*</span> 保证 在客户端 部分注册了 服务器 的各类信息，而不能在 服务器端 注册 客户端 的信息。
<span class="keyword">*</span> 当然也有例外，例如你就想这个软件作为私密软件，仅供两个人使用， 且你有固定的 IP地址，那么你可以两边都connect，但是
<span class="keyword">*</span> 一定要注意，只要有一点信息变动，这个软件就可能无法正常的收发信息了。
<span class="keyword">*</span>/
</code></pre></li>
<li>代码解释<ul>
<li>故而实际上，虽然前方的表格显示，<code>UDP</code> 似乎并没有 <code>connect</code> 的使用必要，但是实际上还是有用到的地方。</li>
<li>就 <code>*nix</code> 的 <strong>API</strong> 来说，<code>sendto</code> 和  <code>write</code> 的区别十分明显，便是一个需要在参数中提供目标主机的各类信息，而后者则不需要提供。同样的道理<code>recvfrom</code>和<code>read</code>也是如此。</li>
<li>这个代码只是做演示而已，所以将代码置于无限循环当中，现实中可以自行定义出口条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上是 UDP 的一些简单说明，入门足矣，并未详细叙述某些 函数 的具体用法，而是用实际例子来体现。<br>在 记录 TCP 之前，还是需要讲一个函数 shutdown</p>
</blockquote>
<ul>
<li><code>shutdown</code> 与 <code>close(closesocket)</code><ul>
<li>首先要知道，网络通信一般而言是双方的共同进行的，换而言之就是双向的，一个方向只用来发送消息，一个方向只用来读取消息。</li>
<li>这就导致了，在结束套接字通信的时候，需要关闭两个方向的通道(暂时叫它们通道)，那同时关闭不行吗？可以啊<ul>
<li><code>close(sock); // closesocket(sock); FOR Windows PlatForm</code> 就是这么干的，同时断开两个方向的连接。</li>
<li>简单的通信程序或者单向通信程序这么做的确无甚大碍，但是万一在结束通信的时候需要接收最后一个信息那该怎么办？<ul>
<li>假设通信结束，客户端向服务器发送 “Thank you”</li>
<li>服务器需要接收这个信息，之后才能关闭通信</li>
<li>问题就在这之间，服务器并不知道客户端会在通信结束后的什么时刻传来信息</li>
<li>所以我们选择在通信完成后先关闭 服务器的 发送通道(写流)，等待客户端发来消息后，关闭剩下的 接收通道(读流)</li>
</ul>
</li>
</ul>
</li>
<li>发送端：<pre><code><span class="comment">/* 假设有一个 TCP 的连接，此为客户端 */</span>
write<span class="comment">(sock, "Thank you", 10)</span>;
close<span class="comment">(sock)</span>; <span class="comment">// 写完直接关闭通信</span>
</code></pre></li>
<li>接收端：<pre><code><span class="comment">/* 此为服务器 */</span>
<span class="comment">/* 首先关闭写流 */</span>
shutdown(sock_c, SHUT_WR);
<span class="keyword">read</span>(sock_c, get_mess, GET_MAX);
printf(<span class="string">"Message : %s\n"</span>, get_mess);
<span class="keyword">close</span>(sock_c);
<span class="keyword">close</span>(sock_s); <span class="comment">// 关闭两个套接字是因为 TCP 服务器端的需要，后续会记录</span>
</code></pre></li>
<li>代码解释<ul>
<li><code>shutdown</code> 函数的作用就是 可选择的关闭那个方向的输出<ul>
<li><code>int shutdown(int sock, int howto);</code></li>
<li><code>sock</code> 代表要操作的套接字</li>
<li><code>howto</code>有几个选择  <ul>
<li><strong> *nix </strong> : <code>SHUT_RD</code> <code>SHUT_WR</code> <code>SHUT_RDWR</code></li>
<li><strong> Windows </strong> : <code>SD_RECEIVE</code> <code>SD_SEND</code> <code>SD_BOTH</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="停下来">停下来</h3><ol>
<li>程序员应该越来越来，做的事情应该越来越少，但是能达到的成就应该越来越多</li>
<li>在 IPv6 出现的今天，网络编程已经开始向简洁和强大靠近，即便是身为底层语言的 C语言</li>
<li>实际上由于 C语言 并没有自己的<strong>网络库</strong>， 故为了能进行网络编程，不得不依赖于系统函数，这就是所谓的<strong>系统编程</strong>， 你已经是一个系统程序员了。</li>
<li>而 系统函数 随着时代的变化，正在不断完善，增加(几乎没有废除的先例，所以不用担心之前的程序无法运行)。</li>
<li>相应的，由于以前的网络编程只适合于 IPv4 的地址，自从出现了 IPv6, 我们需要一套全新的方式，正好他来了。</li>
</ol>
<h3 id="新时代的_套接字网络编程">新时代的 套接字网络编程</h3><ol>
<li>首先有几个结构体，以及一个接口十分重要及常用：<ul>
<li><code>struct sockaddr_in6</code> ： 代表的是 IPv6 的地址信息</li>
<li><code>struct addrinfo</code> : 这是一个通用的结构体，里面可以存储 IPv4 或 IPv6 类型地址的信息</li>
<li><code>getaddrinfo</code> ： 这是一个十分方便的接口，在上述 UDP 程序中许多<strong>手动填写</strong>的部分，都能够省去，有该函数替我们完成</li>
</ul>
</li>
<li><p>改写一下上方的例子：</p>
<ul>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in host_v4; /<span class="keyword">*</span> IPv4 地址 <span class="keyword">*</span>/
struct sockaddr_in6 host_v6; /<span class="keyword">*</span> IPv6 地址 <span class="keyword">*</span>/
struct addrinfo easy_to_use; /<span class="keyword">*</span> 用于设定要获取的信息以及如何获取信息 <span class="keyword">*</span>/
struct addrinfo <span class="keyword">*</span>result;    /<span class="keyword">*</span> 用于存储得到的信息(需要注意内存泄露) <span class="keyword">*</span>/
struct addrinfo <span class="keyword">*</span> p;

/<span class="keyword">*</span> 准备信息 <span class="keyword">*</span>/
memset(&amp;easy_to_use, 0, sizeof easy_to_use);
easy_to_use.ai_family = AF_UNSPEC; /<span class="keyword">*</span> 告诉接口，我现在还不知道地址类型 <span class="keyword">*</span>/
easy_to_use.ai_flags = AI_PASSIVE; /<span class="keyword">*</span> 告诉接口，稍后“你”帮我填写我没明确指定的信息 <span class="keyword">*</span>/
easy_to_use.ai_socktype = SOCK_DGRAM; /<span class="keyword">*</span> UDP 的套接字 <span class="keyword">*</span>/
/<span class="keyword">*</span> 其余位都为 0 <span class="keyword">*</span>/

/<span class="keyword">*</span> 使用 getaddrinfo 接口 <span class="keyword">*</span>/
getaddrinfo(NULL, argv[1], &amp;easy_to_use, &amp;result); /<span class="keyword">*</span> argv[1] 中存放字符串形式的 端口号 <span class="keyword">*</span>/

/<span class="keyword">*</span> 创建套接字，此处会产生两种写法，但更保险，可靠的写法是如此 <span class="keyword">*</span>/
/<span class="keyword">*</span> 旧式方法
<span class="keyword">*</span>  sock = socket(PF_INET, SOCK_DGRAM, 0);
<span class="keyword">*</span>/
/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
/<span class="keyword">*</span> 旧式方法
<span class="keyword">*</span>  memset(&amp;recv_host, 0, sizeof(recv_host));
<span class="keyword">*</span>  recv_host.sin_family = AF_INET;
<span class="keyword">*</span>  recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
<span class="keyword">*</span>  recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
<span class="keyword">*</span>  bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
<span class="keyword">*</span>/

for(p = result; p != NULL; p = p-&gt;ai_next) /<span class="keyword">*</span> 该语法需要开启 -std=gnu99 标准<span class="keyword">*</span>/
{
  sock = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
  if(sock == -1)
    continue;
  if(bind(sock, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1)
  {
    close(sock);
    continue;
  }
  break; /<span class="keyword">*</span> 如果能执行到此，证明建立套接字成功，套接字绑定成功，故不必再尝试。 <span class="keyword">*</span>/
}

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
//recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);
switch(p-&gt;ai_socktype)
{
  case AF_INET :
    addr_len = sizeof host_v4;
    recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_v4, &amp;addr_len);
    break;
  case AF_INET6:
    addr_len = sizeof host_v6
    recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_v6, &amp;addr_len);
    break;
  default:
    break;
}
freeaddrinfo(result); /<span class="keyword">*</span> 释放这个空间，由getaddrinfo分配的 <span class="keyword">*</span>/
/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><ul>
<li><p>代码解释：</p>
<ul>
<li><p>首先解释几个新的结构体</p>
<ol>
<li><p><code>struct addrinfo</code> 这个结构体的内部顺序对于 <code>*nix</code> 和 <code>Windows</code> 稍有不同，以 <code>*nix</code> 为例</p>
<pre><code><span class="keyword">struct</span> addrinfo{
  <span class="keyword">int</span> ai_flags;
  <span class="keyword">int</span> ai_family;
  <span class="keyword">int</span> ai_socktype;
  <span class="keyword">int</span> ai_protocol;
  socklen_t ai_addrlen;
  <span class="keyword">struct</span> sockaddr * ai_addr; <span class="comment">/* 存放结果地址的地方 */</span>
  <span class="keyword">char</span> * ai_canonname; <span class="comment">/* 忽略它吧，很长一段时间你无须关注它 */</span>
  <span class="keyword">struct</span> addrinfo * ai_next; <span class="comment">/* 一个域名/IP地址可能解析出多个不同的 IP */</span>
};
</code></pre></li>
<li><code>ai_family</code> 如果设定为 <code>AF_UNSPEC</code> 那么在调用 <code>getaddrinfo</code> 时，会自动帮你确定，传入的地址是什么类型的</li>
<li><code>ai_flags</code>  如果设定为 <code>AI_PASSIVE</code> 那么调用 <code>getaddrinfo</code> 且向其第一个参数传入 <code>NULL</code> 时会自动绑定自身 IP，相当于设定 <code>INADDR_ANY</code></li>
<li><code>ai_socktype</code> 就是要创建的套接字类型，这个必须明确声明，系统没法预判(日后人工智能说不定呢?)</li>
<li><code>ai_protocol</code> 一般情况下我们设置为 <code>0</code>，含义可以自行查找，例如 <code>MSDN</code> 或者 <code>UNP</code></li>
<li><code>ai_addr</code>    这里保存着结果，可以通过 调用<code>getaddrinfo</code><strong>之后</strong> 的<strong>第四个参数</strong>获得。</li>
<li><code>ai_addrlen</code> 同上</li>
<li><code>ai_next</code>    同上</li>
<li><p><code>getaddrinfo</code> 强大的接口函数</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * node, <span class="keyword">const</span> <span class="keyword">char</span> * service,
                  <span class="keyword">const</span> <span class="keyword">struct</span> addrinfo * hints, <span class="keyword">struct</span> addrinfo ** res)</span></span>;
</code></pre></li>
<li>通俗的说这几个参数的作用</li>
<li><code>node</code> 便是待获取或者待绑定的 <strong>域名</strong> 或是 <strong>IP</strong>，也就是说，这里可以直接填写域名，由操作系统来转换成 <strong>IP</strong> 信息，或者直接填写<strong>IP</strong>亦可，是以字符串的形式</li>
<li><code>service</code> 便是端口号的意思，也是字符串形式</li>
<li><code>hints</code> 通俗的来说就是告诉接口，我需要你反馈哪些信息给我(第四个参数)，并将这些信息填写到第四个参数里。</li>
<li><code>res</code> 便是保存结果的地方，需要注意的是，这个结果在API内部是动态分配内存了，所以使用完之后需要调用另一个接口(<code>freeaddrinfo</code>)将其释放</li>
<li><p>实际上对于现代的　套接字编程 而言，多了几个新的存储 IP 信息的结构体，例如 <code>struct sockaddr_in6</code> 和 <code>struct sockaddr_storage</code> 等。</p>
<ul>
<li><p>其中，前者是后者的大小上的子集，即一个 <code>struct storage</code> 一定能够装下一个 <code>struct sockaddr_in6</code>,具体(实际上根本看不到有意义的实现)</p>
<pre><code><span class="keyword">struct</span> sockaddr_in6{
  u_int16_t sin6_family;
  u_int16_t sin6_port;
  u_int32_t sin6_flowinfo; <span class="comment">/* 暂时忽略它 */</span>
  <span class="keyword">struct</span> in6_addr sin6_addr; <span class="comment">/* IPv6 的地址存放在此结构体中 */</span>
  u_int32_t sin_scope_id;  <span class="comment">/* 暂时忽略它 */</span>
};
<span class="keyword">struct</span> in6_addr{
  <span class="keyword">unsigned</span> <span class="keyword">char</span> s6_addr[<span class="number">16</span>];
}
------------------------------------------------------------
<span class="keyword">struct</span> sockaddr_storage{
  sa_family_t ss_family; <span class="comment">/* 地址的种类 */</span>
  <span class="keyword">char</span> __ss_pad1[_SS_PAD1SIZE]; <span class="comment">/* 从此处开始，不是实现者几乎是没办法理解 */</span>
  <span class="keyword">int64_t</span> __ss_align;           <span class="comment">/* 从名字上可以看出大概是为了兼容两个不同 IP 类型而做出的妥协 */</span>
  <span class="keyword">char</span> __ss_pad2[_SS_PAD2SIZE]; <span class="comment">/* 隐藏了实际内容，除了 IP 的种类以外，无法直接获取其他的任何信息。 */</span>
  <span class="comment">/* 在各个*nix 的具体实现中， 可能有不同的实现，例如 `__ss_pad1` ， `__ss_pad2` , 可能合并成一个 `pad` 。 */</span>
};
</code></pre><p>在实际中，我们往往不需要为不同的IP类型声明不同的存储类型，直接使用 <code>struct sockaddr_storage</code> 就可以，使用时直接<strong>强制转换类型</strong>即可</p>
</li>
</ul>
</li>
<li><p>改写上方  <strong>接收端</strong> 例子中，进入接收信息的状态部分</p>
<pre><code>/<span class="keyword">*</span> 首先将多于的变量化简 <span class="keyword">*</span>/
// - struct sockaddr_in host_v4; /<span class="keyword">*</span> IPv4 地址 <span class="keyword">*</span>/
// - struct sockaddr_in6 host_v6; /<span class="keyword">*</span> IPv6 地址
struct sockaddr_storage host_ver_any; /<span class="keyword">*</span> + 任意类型的 IP 地址 <span class="keyword">*</span>/
...
/<span class="keyword">*</span> 进入接收信息的状态部分 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_ver_any, &amp;addr_len); /<span class="keyword">*</span> 像是又回到了只有 IPv4 的年代<span class="keyword">*</span>/
</code></pre></li>
<li><p>补充完整上方对应的 <strong>发送端</strong> 代码</p>
<pre><code><span class="type">int</span> sock;
<span class="keyword">const</span> <span class="type">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="type">char</span> get_mess[<span class="type">GET_MAX</span>]; /* 后续版本使用 */
struct sockaddr_storage recv_host; /* - struct sockaddr_in recv_host; */
struct addrinfo tmp, *<span class="literal">result</span>;
struct addrinfo *p;
socklen_t addr_len;

/* 获取对端的信息 */
memset(&amp;tmp, <span class="number">0</span>, sizeof tmp);
tmp.ai_family = <span class="type">AF_UNSPEC</span>;
tmp.ai_flags = <span class="type">AI_PASSIVE</span>;
tmp.ai_socktype = <span class="type">SOCK_DGRAM</span>;
getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;tmp, &amp;<span class="literal">result</span>); /* argv[<span class="number">1</span>] 代表对端的 <span class="type">IP</span>地址， argv[<span class="number">2</span>] 代表对端的 端口号 */

/* 创建套接字 */
<span class="keyword">for</span>(p = <span class="literal">result</span>; p != <span class="type">NULL</span>; p = p-&gt;ai_next)
{
  sock = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);  /* - sock = socket(<span class="type">PF_INET</span>, <span class="type">SOCK_DGRAM</span>, <span class="number">0</span>); */
  <span class="keyword">if</span>(sock == -<span class="number">1</span>)
    <span class="keyword">continue</span>;
  /* 此处少了绑定 <span class="keyword">bind</span> 函数，因为作为发送端不需要讲对端的信息 绑定 到创建的套接字上。 */  
  <span class="keyword">break</span>; /* 找到就可以退出了，当然也有可能没找到，那么此时 p 的值一定是 <span class="type">NULL</span> */
}
<span class="keyword">if</span>(p == <span class="type">NULL</span>)
{
  /* 错误处理 */
}
/* -// 设定对端信息
memset(&amp;recv_host, <span class="number">0</span>, sizeof(recv_host));
recv_host.sin_family = <span class="type">AF_INET</span>;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
*/

/* 发送信息 */
/* 在此处，发送端的<span class="type">IP</span>地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */
sendto(sock, mess, strlen(mess), <span class="number">0</span>, p-&gt;ai_addr, p-&gt;ai_addrlen);
/* 完成，关闭 */
freeaddrinfo(<span class="literal">result</span>); /* 实际上这个函数应该在使用完 <span class="literal">result</span> 的地方就予以调用 */
close(sock);                
</code></pre></li>
<li>到了此处，实际上是开了网络编程的一个初始，解除了现代的 UDP 最简单的用法(<strong>甚至还算不上完整的使用</strong>)，但是确实是进行了交互。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="#">#</h3><ul>
<li>首先介绍 UDP 并不是因为它简单，而是因为他简洁，也不是因为它不重要，相反他其实很强大。</li>
<li>永远不要小看一个简洁的东西，就像 <strong>C语言</strong></li>
<li>下一篇将详细记录 <strong>UDP</strong> 的相关记录</li>
</ul>
<h4 id="在这之前">　在这之前</h4><ul>
<li>首先还是科普记录一下协议的知识。</li>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">阮一峰的博客 ： 互联网协议入门(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="external">阮一峰的比克 :  互联网协议入门(二)</a></li>
<li>上述两篇文章十分浅显易懂，十分符合科普二字，下方将对上述两个文章进行适当的补充。</li>
</ul>
<h4 id="ARP_协议">ARP 协议</h4><ul>
<li>最简便的方法就是找一个有 WireShark 软件或者 <code>tcpdump</code> 的 <code>*nix</code> 平台，前者你可以选择随意监听一个机器，不多时就能看见 <strong>ARP</strong><br>协议的使用，因为它使用的太频繁了。</li>
<li>对于 ARP 协议而言，首先对于一台机器 A，想与 机器B 通信，(假设此时 机器A 的<strong>高速缓存区(操作系统一定时间更新一次)</strong>中 没有 机器B的缓存)，<ul>
<li>那么机器A就向广播地址发出 <strong>ARP请求</strong>，如果 机器B 收到了这个请求，就将自己的信息(IP地址，MAC地址)填入 <strong>ARP应答</strong> 中，再发送回去就行。</li>
<li>上述中， <strong>ARP请求</strong> 和 <strong>ARP应答</strong> 是一种报文形式的信息，是 ARP协议 所附带的实现产品，也是用于两台主机之间进行通信。</li>
<li>这是当 机器A 和 机器B 同处于一个网络的情况下，可以借由本网络段的广播地址 发送请求报文。</li>
</ul>
</li>
<li>对于不同网络段的 机器A 与 机器B 而言，想要通过 <strong>ARP协议</strong> 获取 <strong>MAC地址</strong> ，就需要借助路由器的帮助了，可以想象一下，路由器(可以不止一个)在中间，机器A 和 机器B 分别在这些路由器的两边(即在不同子网)<ul>
<li>由于 A 和 B 不在同一个子网内，所以没办法通过通过直接通过广播到达，但是有了路由器，就能进行 <strong>ARP代理</strong> 的操作，大概就是将路由器当成机器B， A向自己的本地路由器发送 <strong>ARP请求</strong></li>
<li>之后路由器判断出是发送给B的ARP请求，又正好 B 在自己的管辖范围之内，就把自己的硬件地址 写入 <strong>ARP应答</strong> 中发回去，之后再有A向B 的数据，就都是A先发送给路由器，再经由路由器发往B了</li>
<li>一篇比较好的资源是 <a href="www.cisco.com/c/en/us/support/docs/ip/dynamic-address-allocation-resolution/13718-5.html">Proxy ARP</a><h4 id="ICMP">ICMP</h4></li>
</ul>
</li>
<li>这个协议比较重要，后方的概念也会涉及。<ul>
<li><strong>请求应答报文</strong> 和 <strong>差错报文</strong> ，重点在于差错报文。</li>
<li>请求应答报文在 <code>ICMP</code> 的应用中可以拿来查询本机的子网掩码之类的信息，大致通过向本子网内的所有主机发送该请求报文(包括自己，实际上就是广播)，后接收应答，得到信息</li>
<li>差错报文在后续中会有提到，这里需要科普一二。</li>
<li>首先对于差错报文的一大部分是关于 <strong>xxx不可达</strong> 的类型，例如主机不可达，端口不可达等等，每次出现错误的时候，ICMP报文总是第一时间返回给对端，(它一次只会出现一份，否则会造成网络风暴)，但是对端是否能够接收到，就不是发送端的问题了。</li>
<li>这点上 套接字的类型 有着一定的联系，例如 UDP 在 <code>unconnected</code> 状态下是会忽略 ICMP报文的。而 TCP 因为总是 <code>connected</code> 的，所以对于 ICMP报文能很好的捕捉。</li>
<li>ICMP差错报文中总是带着 <strong>出错数据报中的一部分真实数据</strong>，用于配对。</li>
</ul>
</li>
</ul>
<p>转载注明: <a href="http://www.wushxin.top/2015/10/30/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%90%AF%E8%88%AA.html" target="_blank" rel="external">http://www.wushxin.top/2015/10/30/%E7%8E%B0%E4%BB%A3TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%90%AF%E8%88%AA.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的，实际上还有一个但这里不记录。</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code>]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
      <category term="网络编程" scheme="http://www.wushxin.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux记录]]></title>
    <link href="http://www.wushxin.top/2015/09/20/Linux%E8%AE%B0%E5%BD%95.html"/>
    <id>http://www.wushxin.top/2015/09/20/Linux记录.html</id>
    <published>2015-09-20T00:33:33.000Z</published>
    <updated>2016-03-25T00:00:24.996Z</updated>
    <content type="html"><![CDATA[<h2 id="源">源</h2><ul>
<li>因为国内的原因，没有办法直接使用官方的源，速度有时候会过慢，在高校内部的人可以回比外边更好一些</li>
<li>而经常出现是根据网上搜索(百度)，出来的结果，大都是直接换源，导致很多错误例如 <code>Some Index fail to ...</code> 之类的错误，这是由于每个版本的 Linux 的源都有细微的差别。以最有名的基于 <strong>Debian</strong> 的 <code>Ubuntu</code> 为例子</li>
<li><p>例如<strong>Ubuntu 14.04</strong> 的163源应该是：</p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
</code></pre></li>
<li><p><strong>Ubuntu 15.04</strong> 的163源应该是：<a id="more"></a></p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiverse</span>
eb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiverse</span>
</code></pre><p>区别就在于源中的 <strong>vivid 和 trusty</strong><br>相应的其他版本亦有自己的代号，详情<a href="http://wiki.ubuntu.org.cn/Qref/Source" target="_blank" rel="external">请见此处</a></p>
</li>
<li><p>根据中文 <a href="http://wiki.ubuntu.org.cn" target="_blank" rel="external">Ubuntu官网</a> 提供的信息，有些源已经无法被公众使用。(本文此处更新于2015/09/20)</p>
<ul>
<li><p>完全失效的服务器：      </p>
<ul>
<li>青岛大学更新服务器（教育网/山东青岛移动专线双线服务器），由 OSQDU维护，位于青岛大学。包含开源镜像和Opera、马克思主义文库等其他镜像。<ul>
<li>Geekbone.org更新服务器（上海电信服务器，由 SHLUG /上海Linux用户群维护）,现跳转至搜狐服务器。</li>
<li>由Love4Taylor维护的开源镜像站，位于香港新世界电讯有限公司CDN节点上，包含Deepin 镜像，可能包含其它开源镜像。 </li>
<li>上述服务器部分可能改为校内/地区访问。 </li>
</ul>
</li>
</ul>
<ul>
<li>部分失效的服务器</li>
<li>西南大学开源社区维护的西南大学镜像中已经取消了主要发行版镜像，但有一些学习资源。</li>
<li>由电子科技大学Linux 用户组维护的UESTC LUG软件源中包含其它发行版的镜像。</li>
<li>由电子科技大学学生之家维护的电子科大星辰工作室镜像中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。</li>
<li>由We·Cloud云技术小组维护的大连东软信息学院的We - 开源镜像站中已经取消了 Ubuntu 镜像，但有Ubuntu 光盘镜像和其它发行版。</li>
<li>由西南林业大学计信学院维护的西南林大镜像中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。</li>
<li>由LUPA开源社区维护的LupaWorld更新服务器（浙江杭州电信/联通双线服务器）中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。 <h2 id="update_&amp;&amp;_upgrade">update &amp;&amp; upgrade</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>这大概是最熟悉的两个参数之一，但是经常看见类似如此错误：<br><code>0 upgraded, 0 newly installed, 0 to remove and 3 not upgraded</code></p>
</li>
<li><p><code>not upgraded</code> 的解决办法是: ·<br><code>$ sudo apt-get -u dist-upgrade</code></p>
</li>
</ul>
<h2 id="Linux_of_Qt5">Linux of Qt5</h2><p>在Ubuntu编译Qt5工程时出现了 </p>
<p><code>can not find -lGL</code></p>
<p>这是为什么?在Qt4时代并没有这种情况</p>
<p>经过查找,发现<strong>Qt5在这个版本自动加入了openGL的支持</strong>,而有的平台并没有默认拥有</p>
<p><strong>(Windows默认有openGL,Linux却没有完全)</strong></p>
<p>可以通过安装 <code>libglut-dev</code> 来进行修复</p>
<p><code>sudo apt-get install libglut-dev</code></p>
<p>稍微解读一下也能知道<code>-lGL==&gt;-linkopenGL</code>的意思</p>
<p>转载注明: www.wushxin.top/2015/09/20/Linux记录.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="源">源</h2><ul>
<li>因为国内的原因，没有办法直接使用官方的源，速度有时候会过慢，在高校内部的人可以回比外边更好一些</li>
<li>而经常出现是根据网上搜索(百度)，出来的结果，大都是直接换源，导致很多错误例如 <code>Some Index fail to ...</code> 之类的错误，这是由于每个版本的 Linux 的源都有细微的差别。以最有名的基于 <strong>Debian</strong> 的 <code>Ubuntu</code> 为例子</li>
<li><p>例如<strong>Ubuntu 14.04</strong> 的163源应该是：</p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
</code></pre></li>
<li><p><strong>Ubuntu 15.04</strong> 的163源应该是：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.wushxin.top/tags/Linux/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《我为什么学C》]]></title>
    <link href="http://www.wushxin.top/2015/08/31/%E3%80%8A%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C%E3%80%8B.html"/>
    <id>http://www.wushxin.top/2015/08/31/《我为什么学C》.html</id>
    <published>2015-08-31T13:56:34.000Z</published>
    <updated>2015-10-07T02:07:15.018Z</updated>
    <content type="html"><![CDATA[<h4 id="集结成电子书_《Real_C》">集结成电子书 《<a href="http://wrestle.gitbooks.io/whyilearnc/" target="_blank" rel="external">Real C</a>》</h4><h4 id="目录">目录</h4><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/" target="_blank" rel="external">介绍</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/Seperate-0.html" target="_blank" rel="external">第一部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/00.html" target="_blank" rel="external">前序</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/01.html" target="_blank" rel="external">序</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/02.html" target="_blank" rel="external">C代码风格</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/04.html" target="_blank" rel="external">C代码规范</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/03.html" target="_blank" rel="external">变量</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/Seperate-1.html" target="_blank" rel="external">第二部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/10.html" target="_blank" rel="external">指针(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/11.html" target="_blank" rel="external">指针(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/12.html" target="_blank" rel="external">预处理器</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/13.html" target="_blank" rel="external">效率至上(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/14.html" target="_blank" rel="external">效率至上(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/15.html" target="_blank" rel="external">未曾领略的风景</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/16.html" target="_blank" rel="external">C线程和Glib的视角</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/Seperate-2.html" target="_blank" rel="external">第三部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/20.html" target="_blank" rel="external">错误处理</a> </li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/21.html" target="_blank" rel="external">开始行动</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/22.html" target="_blank" rel="external">单线程备份(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/23.html" target="_blank" rel="external">单线程备份(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/24.html" target="_blank" rel="external">多线程备份</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/25.html" target="_blank" rel="external">总结</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-3/Seperate-3.html" target="_blank" rel="external">第四部分</a> </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="集结成电子书_《Real_C》">集结成电子书 《<a href="http://wrestle.gitbooks.io/whyilearnc/" target="_blank" rel="external">Real C</a>》</h4><h4 id="目录"]]>
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Practical cpp]]></title>
    <link href="http://www.wushxin.top/2015/07/21/Practical-cpp.html"/>
    <id>http://www.wushxin.top/2015/07/21/Practical-cpp.html</id>
    <published>2015-07-21T03:08:13.000Z</published>
    <updated>2016-03-24T23:59:32.547Z</updated>
    <content type="html"><![CDATA[<h4 id="try-throw-catch_三段式">try-throw-catch 三段式</h4><p>这是异常抛出的方式，简单的用法便是在外部使用的try-catch形式：</p>
<pre><code><span class="comment">//Code-1</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> get_num;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; get_num;
    <span class="keyword">try</span>
    {
        <span class="keyword">if</span>(get_num &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> get_num
        <span class="comment">//Something happen</span>
    }
    <span class="keyword">catch</span>(<span class="keyword">int</span> e) <span class="comment">//此处括号内的参数的类型和抛出的类型需要一致</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number "</span> &lt;&lt; get_num &lt;&lt; <span class="string">" is negative"</span>
                  &lt;<span class="built_in">std</span>::endl;
    }
    <span class="comment">//...</span>
}
</code></pre><ul>
<li><p>这是最简单的使用，在三段式中，<code>try</code>充当的是正常代码块，而<code>catch</code>则是对于抛出异常的处理。<code>catch</code> 可以不止一个，但一定要合理，实际来说，三段式能少用尽量少用，我们一般是这么使用三段式的： <a id="more"></a></p>
<ul>
<li>在函数中使用三段式，例如函数调用里<code>throw</code>一个异常</li>
<li>在调用函数的地方的附近使用三段式获取一个异常</li>
<li><p>异常被抛出后一定要有接收的<code>catch</code>，否则会默认调用<code>unexcept()</code>，从而紧接着默认调用<code>terminate()</code>终止程序。</p>
<pre><code><span class="comment">//Code-2</span>
<span class="comment">//head.h</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;...&gt; <span class="comment">//各种必要的头文件 </span></span>
<span class="keyword">class</span> ExceptionText{
<span class="keyword">public</span>:
        ExceptionTest(){}
        ExceptionTest(<span class="built_in">std</span>::<span class="built_in">string</span> err_mes): message(err_mes)    {}
        <span class="comment">//调用接口</span>
        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">show_message</span><span class="params">()</span></span>{
            <span class="keyword">return</span> message;
        }
<span class="keyword">private</span>:
        <span class="built_in">std</span>::<span class="built_in">string</span> message;
};

<span class="keyword">class</span> ExceptionNumber{
};
</code></pre><p>这个类的作用在于抛出异常的时候，使用该类作为抛出对象的类型，<code>throw</code>可以抛出任意类型的异常。</p>
<pre><code><span class="comment">//Code-3</span>
<span class="comment">//run.cpp</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;...&gt;</span>
<span class="function"><span class="keyword">void</span> <span class="title">AddFunction</span><span class="params">()</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">TheMainFunction</span><span class="params">(<span class="keyword">double</span> args)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> SomeThingYouWant = <span class="number">0</span>;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; SomeThingYouWant; 
    <span class="keyword">try</span>
    {
        TheMainFunction(SomeThingYouWant);
    }
    <span class="keyword">catch</span>(ExceptionText t)
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.show_message();
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;
    }
    <span class="keyword">catch</span>(ExceptionNumber n) <span class="comment">// 抛出类型可以只定义类型，而不加任何具体实现</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number is not match the logic"</span>
              &lt;&lt; <span class="built_in">std</span>::endl;
    }
    <span class="keyword">catch</span>(...) <span class="comment">//这是默认的catch，...并不代表无限的参数，而是默认的意思，就像switch中的default.</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There has some thing bad happen to us"</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
</ul>
</li>
<li><p>在三段式中，可以有很多个<code>catch</code>，并且可以拥有一个默认的<code>catch</code>，在上述代码中，只要抛出类型不是<code>ExceptionText</code>和<code>ExceptionNumber</code>,抛出就会被默认<code>catch</code>所获取。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">4</span>
<span class="type">void</span> <span class="type">TheMainFunction</span>(double args)
{
    double <span class="literal">result</span>;
    <span class="keyword">if</span>(args &lt; <span class="number">0</span>)
        throw <span class="type">ExceptionText</span>(<span class="string">"The number is negative"</span>);
    <span class="keyword">else</span> <span class="keyword">if</span>(args == <span class="number">0</span>)
        throw <span class="type">ExceptionText</span>(<span class="string">"The number is Zero"</span>);
    <span class="literal">result</span> = (args-<span class="number">1</span>) / args;

    <span class="keyword">while</span>(<span class="literal">result</span> &gt; <span class="number">0</span>)
        <span class="literal">result</span> -= <span class="number">0</span>.<span class="number">01</span>;
    <span class="keyword">if</span>(<span class="literal">result</span> &lt; <span class="number">0</span>)
        throw <span class="type">ExceptionNumber</span>;
    <span class="keyword">else</span>
        throw <span class="number">0</span>; //只要是<span class="type">ExceptionText</span>和<span class="type">ExceptionNumber</span>之外的任意类型都可以。    
}
</code></pre><p>  在TheMainFunction的定义里，可以添加一些限制条件，来限制抛出的类型：</p>
<pre><code>void <span class="function"><span class="title">TheMainFunction</span><span class="params">(double)</span></span> <span class="function"><span class="title">throw</span><span class="params">(ExceptionText, ExceptionNumber)</span></span>
<span class="comment">//...</span>
</code></pre><p>这样抛出类型就只有<code>ExceptionText</code>和<code>ExceptionNumber</code>两种了。</p>
</li>
<li><p>函数的级别的 <code>try-catch</code></p>
<ul>
<li><p>所谓函数级别就是，使用在函数身上的 <code>try</code></p>
<pre><code><span class="comment">//Code-5</span>
<span class="keyword">class</span> BaseText{
    <span class="built_in">string</span> plantText;
<span class="keyword">public</span>:
    <span class="keyword">class</span> BaseException{}; <span class="comment">//定义一个空类，来定义抛出类型</span>
                           <span class="comment">//类似Java里的 nested 语法</span>
    BaseTest(<span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="keyword">nullptr</span>): plantText(msg){}
<span class="comment">//...</span>
<span class="keyword">class</span> ExceptionText : <span class="keyword">public</span> BaseText{
<span class="keyword">public</span>:
    ExceptionText(<span class="keyword">const</span> <span class="keyword">char</span>* msgError = <span class="keyword">nullptr</span>) 
    <span class="keyword">throw</span>(BaseException) <span class="comment">//限定抛出类型只能是BaseException</span>
    <span class="keyword">try</span> : BaseText(msgError)
    {
        <span class="comment">//这里是正常的构造函数的函数体</span>
    }<span class="keyword">catch</span>(BaseException&amp;)
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In the catch body!"</span> &lt;&lt; <span class="built_in">std</span>::endl;
    }
<span class="comment">//...</span>
</code></pre></li>
<li><p>语法上， <code>try</code> 关键字紧跟在函数参数列表之后，如果是构造函数，则在初始化列表之前， <code>try</code> 的 <strong>block</strong> 中就是正常的函数体。</p>
</li>
</ul>
</li>
<li><p>对于抛出类型的限定，尽量使用它。并且在获取异常的时候，使用引用接收它。这不仅考虑到效率，而且是因为考虑到了继承类的上切问题(例如一个继承了 logic_error 的异常类对象，使用 logic_error 进行按值传递，会导致信息丢失)。</p>
</li>
<li>可以在构造函数中抛出异常(<strong>移动构造函数</strong>不要)，并额外设置一个标志去检查它，但不要再析构函数中抛出异常！</li>
<li><p>但是在 <strong>C++11</strong>之后，一个函数如果要限定其没有抛出，则不再使用 <code>throw()</code>，而使用新关键字 <code>noexcept</code></p>
<pre><code><span class="comment">//Code-6</span>
<span class="comment">//void noException() throw() { //C++98以前</span>
<span class="function"><span class="keyword">void</span> <span class="title">noException</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">true</span>)</span></span>{ <span class="comment">//C++11以后</span>
                                   <span class="comment">//此时 noexcept作为一个操作符存在</span>
    <span class="keyword">for</span>(<span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)
        <span class="keyword">if</span>(i == <span class="number">2</span>)
            <span class="keyword">throw</span> <span class="string">"Thorw!But You will Never See those"</span>;
}
</code></pre><p>可以将该操作符用于模板，以此来决定一个函数是否为一个可抛出异常 的函数</p>
</li>
</ul>
<p>虽然三段式看起来十分实用，但是我们依然应该尽可能的减少他们的使用频率。</p>
<h4 id="标准_C++_异常">标准 C++ 异常</h4><ul>
<li>比起自己定义的异常处理，标准库自带的要更加快速</li>
<li>头文件 <code>&lt;exception&gt;</code> <code>&lt;stdexcept&gt;</code>,后者 <strong>include</strong> 前者</li>
<li>异常类 <code>exception</code> &lt;- <code>logic_error</code>，<code>runtime_error</code><ul>
<li>后两者继承自前者，通常用法是构造后两者的对象，设置错误信息，并调用其接口 <code>what()</code>，其中 <strong>what()</strong> 接口继承自类 <code>exception</code>， 但是由于 <code>exception</code> 的构造函数并没有提供接口让用户设置错误信息，故总是用其两个继承类</li>
<li>具体用法有两种：<ol>
<li>继承法，通过让自己的类继承类 <code>logic_error</code> 或者 <code>runtime_error</code>(或者其派生类) 来实现使用它们的目的</li>
<li>成员法，通过让自己的类拥有一个嵌套类，专门用来抛出错误信息，类中拥有 <code>logic_error</code> 或者 <code>runtime_error</code>(或者其派生类)的成员，并在必要时设置构造这个类对象</li>
</ol>
</li>
<li><a href="http://zh.cppreference.com/w/cpp/error" target="_blank" rel="external">异常处理参考网址，维基百科(无须翻墙)</a></li>
<li>补充上述 <code>logic_error</code> 的 派生类<ol>
<li><code>bad_cast</code> 是 <strong>dynamic_cast</strong> 失败之后，抛出的异常，与(RTTI机制有关) -&gt; <code>#include &lt;typeinfo&gt;</code></li>
<li><code>bad_typeid</code> 也与 RTTI 机制有关 -&gt; <code>#include &lt;typeinfo&gt;</code></li>
</ol>
</li>
<li>补充 <code>runtime_error</code> 的 派生类<ol>
<li><code>bad_alloc</code> 如果 <strong>new</strong> 分配内存失败，则会抛出这个异常 -&gt; <code>#include &lt;new&gt;</code></li>
</ol>
</li>
<li><a href="http://zh.cppreference.com/w/cpp/error/exception" target="_blank" rel="external">其余补充</a></li>
<li>补充的继承类不再 <code>&lt;stdexcept&gt;</code> 中声明定义而在各自的头文件中声明定义。</li>
<li><strong>C++11</strong> 之后的标准弃用了许多异常类，也重新有了许多的类。</li>
</ul>
</li>
</ul>
<h4 id="模板">模板</h4><ul>
<li><p>模板的三种用法：</p>
<ol>
<li>用于待定类型的占位：</li>
<li>用于定义维数</li>
<li><p>将模板类当成模板参数进行传递</p>
<pre><code><span class="comment">//Code-7</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> tpOfPara, <span class="comment">//通常的用法</span>
         <span class="keyword">typename</span>&lt;<span class="keyword">typename</span> secT, 
                  <span class="keyword">typename</span> = <span class="built_in">std</span>::allocator&lt;secT&gt;&gt; <span class="keyword">class</span> tpClName, <span class="comment">//传递模板类作为模板参数</span>
         <span class="built_in">std</span>::size_t consDim = <span class="number">100</span>&gt; <span class="comment">//使用无类型的模板参数，且使用了默认参数</span>
    <span class="keyword">class</span> ClDefByMe{
        tpClName&lt;tpOfPara&gt; priMem_1;
        tpOfPara            priMem_2;
        <span class="keyword">int</span>                testMem[consDim];
    pubic:
        <span class="function">explict <span class="title">ClDefByMe</span><span class="params">(<span class="keyword">const</span> tpClName&lt;tpOfPara&gt;&amp;, 
                          <span class="keyword">const</span> tpOfPara&amp;)</span></span>;
<span class="comment">//...</span>
ClDefByMe&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&gt; tmp1;
</code></pre></li>
</ol>
<ul>
<li>用于类的时候，模板可以使用默认参数，但是用在函数的时候却不行。</li>
<li>在第二句中，为了传递特定的模板容器 <strong>vector</strong>，其声明中包含了一个默认模板参数，在此处需要显式的写出，否则无法编译通过，<strong>allocator</strong> 在 <code>&lt;memory&gt;</code> 中声明定义</li>
</ul>
</li>
<li><p>关键字 <strong>typename</strong></p>
<ul>
<li>在 <strong>C++11</strong>之后， <strong>typename</strong> 也可以用在模板参数中，之前只能使用 <strong>class</strong> 关键字，这两个关键字的效果一致</li>
<li><p>在模板类的定义中，我们可以使用 <code>typename</code> 关键字来获取模板参数中的<strong>内嵌类型</strong></p>
<pre><code><span class="comment">//Code-8</span>
<span class="keyword">class</span> clFirst{
    <span class="keyword">int</span> mem1;
<span class="keyword">public</span>:
    <span class="keyword">class</span> nestcl{
        <span class="keyword">int</span> mem2;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">void</span> <span class="title">showMem</span><span class="params">()</span> </span>{<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mem2 = "</span> &lt;&lt; <span class="built_in">std</span>::endl;}
    };
}; <span class="comment">//用于传递的类</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">class</span> ClDefByMe{
        <span class="keyword">typename</span> T::nestcl tmpMem;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{ tmpMem.showMem(); }
    };
<span class="comment">//...</span>
ClDefByMe&lt;clFirst&gt; tmp;
tmp.show();
</code></pre><ul>
<li>此时如果引用过来的不是内嵌类型，而是别名(typedef)的话，亦是可以。</li>
<li>如果<code>T::nestcl</code>是类型 T的静态类型成员 就无需添加关键字 <code>typename</code></li>
<li>对于 模板函数 而言,这一性质同样起作用,常用来声明定义某种类型(STL容器)的 <strong>迭代器(Iterator)</strong>,方便使用.    </li>
</ul>
</li>
</ul>
</li>
<li><p><code>template</code> 关键字的另类用处    </p>
<ul>
<li><p>当在模板函数中调用一个模板类的成员函数，且该成员函数亦是模板的时候，需要使用<code>template</code> 关键字消除编译器的判定错误(将模板参数的左尖括号 &lt; 当成小于运算符)。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">9</span>
//引用<span class="type">Thinking</span> <span class="keyword">in</span> C++ 例子
//bitset例子
<span class="keyword">template</span>&lt;typename charT, size_t N&gt;
    basic_string&lt;charT&gt; bitsetToString(<span class="keyword">const</span> bitset&lt;N&gt;&amp; bs)
    {    
        <span class="keyword">return</span> bs. <span class="keyword">template</span> to_string&lt;charT, 
                                      char_traits&lt;charT&gt;,
                                      allocator&lt;charT&gt;&gt;();
    }
//此时<span class="keyword">template</span>关键字必不可少， -&gt; 操作符也是如此
//bitset
</code></pre></li>
<li><code>template</code> 关键字不可少的原因在于，当模板函数被解析(parsed)之后，编译器会认为 <code>to_string</code> 右边的尖括号 <code>&lt;</code> 是小于运算符，我们需要这个关键字来告诉编译器这是模板的语法。</li>
</ul>
</li>
<li><p>模板成员函数</p>
<ul>
<li><p>在模板类中声明定义模板成员函数，相当于嵌套。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">10</span>
<span class="keyword">template</span>&lt;typename typOne&gt;
    class <span class="type">ClDefByMe</span>{
    //...
    public:
        <span class="keyword">template</span>&lt;typename typTwo&gt; 
            <span class="type">ClDefByMe</span>(<span class="keyword">const</span> <span class="type">ClDefByMe</span>&lt;typTwo&gt; &amp;);
    ...
//如果类外定义
<span class="keyword">template</span> &lt;typename typOne&gt;
    <span class="keyword">template</span>&lt;typename typTwo&gt;
        <span class="type">ClDefByMe</span>&lt;typOne&gt;::<span class="type">ClDefByMe</span>(<span class="keyword">const</span> <span class="type">ClDefByMe</span>&lt;typTwo&gt; &amp;)
        {
            //...定义
        }
</code></pre></li>
<li>模板类中的模板成员函数的模板参数不必和类一样。</li>
<li><p>模板成员可以用在嵌套类上。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">11</span>
<span class="keyword">template</span>&lt;typename typOne&gt;
    class <span class="type">ClDefByMe</span>{
    //...
    public:
        <span class="keyword">template</span>&lt;typename typThr&gt;
            class inner{
            //...
            public:
                <span class="type">void</span> lookFunc();
            };
    ...
<span class="keyword">template</span>&lt;typename typOne&gt; //定义 lookFunc
    <span class="keyword">template</span>&lt;typename typThr&gt;
        <span class="type">ClDefByMe</span>&lt;typOne&gt;::inner&lt;typThr&gt;::lookFunc()
        {
            //...函数体
        }
...
<span class="type">int</span> main()
{
    clDefByMe&lt;<span class="type">int</span>&gt;::inner&lt;long&gt; tmpObj;
    tmpObj.lookFunc();
    <span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre></li>
</ul>
</li>
<li><p>但是，模板成员函数不可是 <strong>虚函数</strong> <strong>(virtual)</strong> ，不过能够重载，重载的时候，可以让常规函数和模板函数混搭(即不一定需要模板重载模板，普通重载普通)。</p>
<ul>
<li>在选择哪个版本的函数方面，优先选择非模板函数，可以显式地强制调用模板函数版本通过在调用函数名后面，括号的前面，添加空参数的模板尖括号。</li>
</ul>
</li>
<li><p>模板函数常常可以省略模板参数，而交由编译器来推断所使用的参数类型，也可以自己显式传递。 </p>
<ul>
<li>例如上方的 <strong>Code-9</strong> 中的模板函数 <code>bitsetToString</code> 的定义可以改成： <code>return bs.to_string();</code> 产生的效果与此前代码一致。</li>
<li>这种有编译器干的事情里，如果出现了需要类型转换的情况，则会失败。 </li>
<li>在操作数组的时候，不妨使用 <strong>数组的引用</strong> 来代替单一指针，因为这样可以让编译器帮我们推断数组的维数，而不自自己显式传递，例如( <code>arrType (&amp;arr)[9][10]</code> ) </li>
<li><p>如果需要传递一个模板函数的地址，也可以借助编译器自动推断来省略显式的模板参数传递：</p>
<pre><code>//<span class="type">Code</span>-<span class="number">12</span>
<span class="type">void</span> knowType(<span class="type">void</span> (*innerFunp)(<span class="type">int</span> *)) {}
<span class="keyword">template</span>&lt;typename T&gt;
    <span class="type">void</span> unkwType(T *) {} //一个返回值类型为 <span class="type">void</span>, 参数为 T* 的函数
//使用
knowType(&amp;unkwType&lt;<span class="type">int</span>&gt;); //显式
knowType(&amp;unkwType); //编译器推断
</code></pre><p>但是这种情况下在使用模板推断的时候,需要注意,如果该函数有重载版本的情况下,需要显式的指明需要哪个函数,否则会发生 <strong>推断错误</strong> ,因为编译器没办法知道需要选择哪个版本的函数,即使明显是需要选择某个版本.</p>
<p>  解决方法可以是,类型转换(<code>static_cast</code>),或者重新写一个函数将某个特定的重载版本包裹起来.</p>
</li>
</ul>
</li>
<li><p>对于一个模板而言，它能够为不同类型生成不同的代码，同样，也可以人为先预设一些样板，就像一个建设网页的框架，总有人做好了模板，你可以使用别人的模板，也可以选择使用自己做模板</p>
<ul>
<li>比如 <strong>STL容器 vector</strong> 有一个生成好的特殊的版本 <code>vector&lt;bool&gt;</code>，优化了其的空间利用率。</li>
<li><p>生成显式特殊化(<strong>Explicit Specialization</strong>)的方法是，在定义好基本模板之后</p>
<pre><code>//<span class="type">Code</span>-<span class="number">13</span>
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass{
        T memOne;
        U memTwo;
    public:
        T getFstMem() <span class="keyword">const</span> { <span class="keyword">return</span> memOne; }
    };
<span class="keyword">template</span>&lt;&gt; //完全特殊化的语法
    class tmplClass&lt;<span class="type">int</span>, long&gt;{ //显式的定义了一个 &lt;<span class="type">int</span>, long&gt; 的版本
        <span class="type">int</span> memOne;
        long memTwo;
    public:
        <span class="type">int</span> getFstMem() <span class="keyword">const</span> { <span class="keyword">return</span> memOne; }
    };
</code></pre><p>  同样也支持有局部特殊化</p>
<pre><code>//<span class="type">Code</span>-<span class="number">14</span>
<span class="keyword">template</span>&lt;typename U&gt; // 部分特殊化的语法
    class tmplClass&lt;<span class="type">float</span>, U&gt;{ //只给了第一个参数的类型
    ...                           //给的参数可以随意调整顺序。
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass&lt;T, U*&gt; { //这也是局部特殊化
</code></pre><p>  此时，如果是在类外定义接口函数，那么需要注意的是，完全特殊化情况下，如果已经完全特殊化一个模板类，则在实现其特殊化类的接口函数时，不需要重新再写一遍 <code>template&lt;&gt;</code> 但是情况就需要：</p>
<pre><code>//<span class="type">Code</span>-<span class="number">15</span>
//假设只有普通模板类
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass{
        T memOne;
        U memTwo;
    public:
        T getFstMem() <span class="keyword">const</span>; //想要类外实现一个特殊化的这个接口函数
    };
//实现：
<span class="keyword">template</span>&lt;&gt;
    <span class="type">int</span> tmplClass&lt;<span class="type">int</span>, long&gt;::getFstMem() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> memOne;
    }
</code></pre><p>  如果此时已经存在一个完全特殊化的模板类的时候：</p>
<pre><code><span class="comment">//Code-16</span>
<span class="comment">//这个假设在已有一个普通的模板类为前提之上。</span>
<span class="keyword">template</span>&lt;&gt; <span class="comment">//完全特殊化的语法</span>
    <span class="keyword">class</span> tmplClass&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt;{ <span class="comment">//显式的定义了一个 &lt;int, long&gt; 的版本</span>
        <span class="keyword">int</span> memOne;
        <span class="keyword">long</span> memTwo;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">int</span> <span class="title">getFstMem</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//定义它，只需要和普通类一样即可</span>
    };
<span class="comment">//实现：</span>
<span class="keyword">int</span> tmplClass&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt;::getFstMem() <span class="keyword">const</span>
{
    <span class="keyword">return</span> memOne;
}
</code></pre></li>
</ul>
</li>
<li><p>使用模板会导致一个问题，就是 <strong>代码膨胀</strong>，对于每一个具体类型的实现都会有一段新的代码产生，而编译器对此的措施就是，只有用到的才会生成对应的代码，否则就不生成。</p>
<ul>
<li>例如，对于一个模板类而言，其成员函数只有被使用了，才会产生相应的代码，否则就当成摆设。</li>
<li>其次，可以人为的避免过大的代码膨胀，例如使用之前提到的，完全/部分特殊化的方法。<ol>
<li>当拥有一个基本的模板类时，我们可以在考虑后续使用的基础上，为其生成一个 <strong>完全特殊化</strong> 的类</li>
<li>使用这个类作为一个基类，产生一个继承体系，继承体系中的各个派生类便是我们真正会生成的类，派生类使用 部分特殊化 实现，继承之前的 完全特殊化 生的类</li>
<li>如此能够利用已经生成的代码，而不需要反复生成同样的代码。</li>
<li>继承 完全特殊化 类的 部分特殊化 类，需要对每一个接口函数重新定义（可以直接调用基类定义好的函数，通过域解析作用符<code>::</code>），因为继承的时候采用的是 <code>private</code> 继承。</li>
<li>最明显的用处便是当不同的类型是指针的时候，用 <code>void*</code> 生成完全特殊化基类，其他类型指针做派生类的对象。</li>
</ol>
</li>
</ul>
</li>
<li><p>模板中的友元</p>
<ul>
<li><p>在模板类中使用友元函数</p>
<ol>
<li>最简洁的写法便是将友元函数作为类内(in-class)函数声明且定义</li>
<li><p>否则，对于需要在类外进行定义的友元函数，只有将其声明为模板，且需要声明两次，定义一次，才能生效：顺序（1.模板类声明，2.模板友元函数声明，3.模板类定义，4.类定义的同时使用友元修饰符<code>friend</code> 重新声明该函数，5.类外定义该友元函数）</p>
<pre><code>//<span class="type">Code</span>-<span class="number">17</span>
//非类内(<span class="keyword">in</span>-class)写法
<span class="keyword">template</span>&lt;typename T&gt; class templClass;// <span class="number">1</span>.
<span class="keyword">template</span>&lt;typename T&gt; <span class="type">void</span> show(<span class="keyword">const</span> templClass&lt;T&gt;&amp;);// <span class="number">2</span>.

<span class="keyword">template</span>&lt;typename T&gt; // <span class="number">3</span>。
    class templClass{
         T x;
      public:
        templClass&lt;T&gt;(<span class="keyword">const</span> T&amp; para):x(para){}
        friend <span class="type">void</span> show&lt;&gt;(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo); //<span class="number">4</span>.
    };
//类外定义友元函数
<span class="keyword">template</span>&lt;typename T&gt; // <span class="number">5</span>.
    <span class="type">void</span> show(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo)
    {
        cout &lt;&lt; fo.x &lt;&lt; endl;
    }
</code></pre><p> .</p>
<pre><code>//<span class="type">Code</span>-<span class="number">18</span>
//类内(<span class="keyword">in</span>-class)写法
<span class="keyword">template</span>&lt;typename T&gt; 
    class templClass{
         T x;
      public:
        templClass&lt;T&gt;(<span class="keyword">const</span> T&amp; para):x(para){}
        friend <span class="type">void</span> show&lt;&gt;(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo)
        {
            cout &lt;&lt; fo.x &lt;&lt; endl;
        }
    };
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
<p>转载注明: www.wushxin.top/2015/07/21/Practical-cpp.htm</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="try-throw-catch_三段式">try-throw-catch 三段式</h4><p>这是异常抛出的方式，简单的用法便是在外部使用的try-catch形式：</p>
<pre><code><span class="comment">//Code-1</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> get_num;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; get_num;
    <span class="keyword">try</span>
    {
        <span class="keyword">if</span>(get_num &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> get_num
        <span class="comment">//Something happen</span>
    }
    <span class="keyword">catch</span>(<span class="keyword">int</span> e) <span class="comment">//此处括号内的参数的类型和抛出的类型需要一致</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number "</span> &lt;&lt; get_num &lt;&lt; <span class="string">" is negative"</span>
                  &lt;<span class="built_in">std</span>::endl;
    }
    <span class="comment">//...</span>
}
</code></pre><ul>
<li><p>这是最简单的使用，在三段式中，<code>try</code>充当的是正常代码块，而<code>catch</code>则是对于抛出异常的处理。<code>catch</code> 可以不止一个，但一定要合理，实际来说，三段式能少用尽量少用，我们一般是这么使用三段式的：]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp记录10.1k]]></title>
    <link href="http://www.wushxin.top/2015/07/09/Cpp%E8%AE%B0%E5%BD%9510.1k.html"/>
    <id>http://www.wushxin.top/2015/07/09/Cpp记录10.1k.html</id>
    <published>2015-07-09T02:03:28.000Z</published>
    <updated>2016-03-25T00:04:09.538Z</updated>
    <content type="html"><![CDATA[<h3 id="更新于_2015/7/14_21:14:21">更新于 2015/7/14 21:14:21</h3><h4 id="再记录_operator=_重载">再记录 operator= 重载</h4><ul>
<li>因为在类的设计中 重载 <code>=</code> 可能是在所难免的，如果你的类设计比较复杂。</li>
<li>之所以需要重载它是为了当类中包含了复杂的关系的时候，提供了一个人为的保证，最典型的莫过于对象的拷贝：<ol>
<li>假设 类中有一个成员是指针，指向一个对象，这个对象可以是数组，也可以是其他类或者容器。</li>
<li>当我们执行赋值操作符的时候，假定这里规范的使用赋值运算符，让其一定能调用<strong>赋值拷贝构造函数</strong> <code>=</code> ，此时对于这个指针成员，就有两种情形： <strong>拷贝指针</strong> 或者 <strong>拷贝对象</strong> 。</li>
</ol>
</li>
<li><strong>拷贝指针</strong>，即便不重载运算符 <code>=</code> 编译器也会帮你自动实现，这在国内大概就叫做 <strong>浅拷贝</strong> ，如果仅仅拷贝指针，这就引发了一个问题，多个对象共享一个实际内存，当执行析构函数的时候，会造成多次析构同一个内存块。</li>
<li><strong>拷贝对象</strong>，这是普遍的解决方法，在拷贝的同时，将指针所指向的对象同样做一份拷贝，似乎也不错，但是如果对象太大，似乎并不是什么很喜人的事 情，但也不失为一种好的解决方案 <a id="more"></a> </li>
<li>当使用拷贝对象这个方案的时候，发现内存使用超过自己所能承受的范围，我们就应该重新考虑一下拷贝指针这个方法，即我们勀使用一个 <strong>计数器</strong>，用来记录有多少个指针指向这个共享的内存块(即对象)，这很像 <strong>C++11</strong> 中智能指针 <code>shared_ptr</code> 的做法，实际上的确可以使用 它来作为解决方法，当然也可以自己实现。</li>
<li>实现的方法就是增加一个计数成员(不是在本类中，而是在指针指向的对象的类中，当然容器和数组另找方法实现，可以考虑用静态成员)，用来记录是否还有指针指向这个内存，对象每次析构的时候，减少计数器。如果还有指针指向它那么在析构函数执行时就不释放那块内存。</li>
<li>总之，总是重载赋值拷贝构造函数 <code>=</code> 总是一个好的习惯。</li>
</ul>
<h4 id="自动类型转换">自动类型转换</h4><ul>
<li><p>对于内建类型，类型转换自然由语言来定义，而自己的类，自然也是可以有的</p>
<ol>
<li><p>加上一个特殊的构造函数即可：</p>
<pre><code>ClDefByMe<span class="list">(<span class="keyword">const</span> otherClass&amp;)</span><span class="comment">;</span>
</code></pre><p>只需要如此定义了构造函数，我们就能实现自动类型转换，但是。</p>
</li>
</ol>
<ul>
<li><p>往往自动类型转换不是什么好事，因为我们如果定义了这么一个构造函数，当我们传递<code>otherClass</code>类型的对象给某个需要 <code>ClDefByMe</code>作为参数的函数的时候，编译器甚至不会警告你，一个更好的办法就是告诉编译器，别偷偷的做自动类型转换，即使我的确有类型转换的意思：</p>
<pre><code><span class="function"><span class="keyword">explicit</span> <span class="title">ClDefByMe</span><span class="params">(<span class="keyword">const</span> otherClass&amp;)</span></span>;
</code></pre><p>只要加了关键字 <code>explicit</code> 我们就只能通过显式的类型转换才能成功通过编译</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> ClDefByMe &amp; other)</span>
</span>{
<span class="comment">//..Do Something</span>
}
otherClass tmp1 = <span class="keyword">new</span> otherClass;
<span class="comment">//调用</span>
testFunc(tmp1);<span class="comment">// 添加关键字 explicit 后报错，需要显式的转换</span>
testFunc(ClDefByMe(tmp)); <span class="comment">//编译通过</span>
</code></pre><p><strong>同样的理由，尽量给自己的构造函数加上关键字 <code>explicit</code> 防止发生自己不知道的默认类型转换，或者隐式调用构造函数。</strong></p>
</li>
<li>隐式调用构造函数的情况是，当某个构造函数只有一个参数(有多个参数，但只有一个参数无默认值，其他都有默认值的也属于这个范围)，那么也会达成触发隐式调用构造函数的条件。</li>
<li><p>例如<code>ClDefByMe</code>有一个构造函数，需要一个<code>int</code>类型的参数，那么：</p>
<pre><code><span class="comment">//testFunc(1);  //是合法的</span>
<span class="comment">//testFunc(1.0) //是合法的</span>
<span class="function">testFunc</span>(<span class="function">ClDefByMe</span>(1));   <span class="comment">//合法</span>
<span class="function">testFunc</span>(<span class="function">ClDefByMe</span>(1<span class="class">.0</span>)); <span class="comment">//合法</span>
</code></pre></li>
</ul>
<ol>
<li><p>在类中重载一个特殊的运算符：</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
...
    <span class="function"><span class="keyword">operator</span> <span class="title">otherClass</span><span class="params">()</span><span class="keyword">const</span> </span>{
        <span class="keyword">return</span> otherClass();<span class="comment">//某个otherClass的构造函数</span>
    }
</code></pre></li>
<li>然而并不是自动类型转换一无是处，它能够让类很好的适应由C语言带过来的库函数，最大的体现便是，C形式的字符串 <code>const char*</code>。只要我们在类中提过了如实现2这种形式的运算符重载，就能让自己的类在C语言的库函数中畅通无阻。</li>
</ol>
</li>
</ul>
<h4 id="重载_new_和_delete">重载 new 和 delete</h4><ul>
<li>全局重载 和 类内重载</li>
<li>全局重载也就是让每个地方用到的 <code>new/delete</code> 都是你重载过的效果</li>
<li>类内重载就像重载运算符一样，只对特别的类有效 </li>
<li><p>可以分为两种:</p>
<pre><code><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(site_t sizes)</span></span>;
<span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* dele_p)</span></span>;
</code></pre><ul>
<li>在重载的实现中，如果想分配的内存要在堆上，那么就使用 <strong>C语言</strong> 提供的内存管理机制<code>malloc, calloc, realloc, free</code>，并且如果这是重载全局的 <code>new/delete</code>，就不能使用 <code>istream</code> 之类的流对象进行输入输出，因为这些流会调用原来的 <code>new/delete</code> 去分配内存空间创建对戏那个，但是实际上此时已经不存在原来的 <code>new/delete</code> 了。</li>
<li>如果重载发生在了某个特定的类中，那么依旧可以调用全局的 <code>new/delete</code> 帮自己完成重载的工作，调用方法便是通过，域解析作用符 <code>::</code></li>
<li>在重载的实现中，如果想分配的内存要在栈上，那么就需要在类设计的时候，预先定义好一个 <strong>内存池</strong>，这个 <strong>内存池</strong> 的大小是固定的，无法改变，但是我们可以使用它来实现一个内存分配的效果，即将这个内存池看作一个系统内存，而我们重载的   <code>new/delete</code> 负责从里面分配和归还内存，这能达到一个目的，可以精确操控内存，让任意一个对象落在我们想要让他们出现的内存里。</li>
</ul>
</li>
<li><p>实现的时候，若是类内重载，则可以使用全局的 <code>new/delete</code>，进行辅助设计：</p>
<pre><code><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(site_t sizes)</span>
</span>{
    <span class="keyword">return</span> ::<span class="keyword">new</span> <span class="keyword">char</span>[sizes];
}
</code></pre><p>其中 <code>sizes</code> 是经过编译器计算得到的，并不需类设计这操心，在实现完之后，只需要正常使用即可</p>
</li>
<li>对于<code>new/delete</code>的重载，我们仅仅只能改变内存分配的位置而已。</li>
<li><code>new</code>所分配的内存会比原先所要求的内存要大一些，多出来的内存是用来存储一些有用的信息，即本次分配了多少个内存，(每个内存是对象的大小)，以便<code>delete</code>的操作。</li>
<li><p>相应的，我们也可以传递别的参数给<code>new</code>，以此来调用不同的构造函数来初始化：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t sizes, <span class="keyword">void</span>* arg1)</span>
</span>{
    <span class="keyword">return</span> arg1; ...
<span class="comment">//..调用</span>
<span class="keyword">int</span> arr_[<span class="number">11</span>] = {<span class="number">0</span>};
<span class="comment">//假设有一个构造函数，将唯一的成员初始化为括号内传递的参数的值</span>
ClDefByMe* tmp = <span class="keyword">new</span>(arr_) ClDefByMe(<span class="number">22</span>);<span class="comment">//在这个数组里创建对象。</span>
                                         <span class="comment">//每个对象大小为 int</span>
<span class="comment">//销毁的时候无法使用delete否则会造成程序错误，只能显式调用析构函数</span>
<span class="comment">//这相当于另一种内存池的实现。</span>
</code></pre><p>使用的方式：</p>
<pre><code><span class="comment">//下一个对象可以是</span>
ClDefByMe* tmp2 = <span class="keyword">new</span>(arr_+<span class="number">1</span>) ClDefByMe(<span class="number">33</span>); <span class="comment">//此处+1 代表下一个对象的位置</span>
</code></pre><p>但是因为没有内存检测，所以需要很小心的使用，不能让其越界，因为<code>C++</code>和 <code>C</code> 语言一样，是不提供越界检查的。</p>
<pre><code><span class="comment">//此时的内存示意|22|33|0|0|0|0|0|0|0|0|0| &lt;&lt;代表arr_的内存示意图</span>
ClDefByMe<span class="subst">*</span> tmp3 <span class="subst">=</span> <span class="literal">new</span>(arr_<span class="subst">+</span><span class="number">3</span>) ClDefByMe(<span class="number">44</span>);
<span class="comment">//此时的内存示意|22|33|0|44|0|0|0|0|0|0|0|</span>
tmp3<span class="subst">-&gt;</span>~ClDefByMe(); <span class="comment">//只能显式调用析构函数，而不能使用 delete</span>
                     <span class="comment">//调用完析构函数，发现内存中的值依旧存在，但实际上已经</span>
                    <span class="comment">//被“销毁”了，涉及到计算机的删除的实现。</span>
</code></pre></li>
</ul>
<h4 id="类设计中的关键字_public,_private,_protected">类设计中的关键字 public, private, protected</h4><ul>
<li>在类声明定义中，可以设定外部对象对本身成员的访问权限<ul>
<li><code>public:</code> 代表任何权限的对象都能访问</li>
<li><code>private:</code> 代表只有该类设计者本身和友元(类/函数)能够访问，继承类也无法直接访问</li>
<li><code>protected:</code> 代表只有 类设计者本身 和 友元 还有 继承类 能访问</li>
</ul>
</li>
<li><p>在类继承中</p>
<ul>
<li><code>public</code> 继承 代表将基类的公有，私有，保护关系，原封不动的继承</li>
<li><p>不写或者 <code>private</code> 继承 代表 所有成员都作为继承类的私有成员。</p>
<ul>
<li><p>当所有继承来的成员都成为是 <code>pirvate</code> 时，可以使用 <code>using</code> 关键字使得其权限改变。例如：</p>
<pre><code><span class="keyword">class</span> Deri : ClDefByMe{
<span class="keyword">public</span>:
    <span class="keyword">using</span> ClDefByMe::counts; <span class="comment">//使得counts由private变为public</span>
    <span class="keyword">using</span> ClDefByMe::address; <span class="comment">//使得接口函数address()成为public</span>
...
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="继承中的重定义">继承中的重定义</h4><ul>
<li><p>在继承的时候，继承类对于基类的成员都照搬继承，但是当基类中的成员函数，在继承类中被重写，被改变返回值或者参数列表，那么基类所继承过来的同名函数将被 <strong>隐藏</strong> </p>
<pre><code><span class="keyword">class</span> ClDefByMe{
    <span class="keyword">int</span> counts;
<span class="keyword">public</span>:
    <span class="comment">//...</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>{ 
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is ClDefByMe -- "</span> &lt;&lt; counts &lt;&lt; endl;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> args)</span></span>{
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is ClDefByMe -- "</span> &lt;&lt; args &lt;&lt; <span class="string">"of"</span> &lt;&lt; counts &lt;&lt; endl;
    }
<span class="comment">//...</span>
};
<span class="keyword">class</span> Deri : <span class="keyword">public</span> ClDefByMe{
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>{
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is Deri --"</span> &lt;&lt; endl;
    }
<span class="comment">//...</span>
};
Deri tmp;
</code></pre><p>使用 <code>tmp.output();</code> 调用的是 <strong>Deri</strong> 中的 <code>output()</code>，当选择编译 <code>tmp.output(11);</code> 时，编译器会提示你 </p>
<blockquote>
<p><strong>no matching function for call to ‘Deri::output(int)’</strong></p>
</blockquote>
<p>  这便是继承类隐藏了基类的实现，如果要调用基类的 <code>output</code>函数，只能显式调用，依旧是采用域解析操作符 <code>::</code> 实现： <code>tmp.ClDefByMe::output();</code></p>
</li>
<li>如果在继承类中出现了和基类一致的函数名，无论修改其返回值或者参数列表与否，都会 将基类中的同名函数隐藏，如果没有出现，那么继承类可以正常的调用基类的接口函数。</li>
</ul>
<h4 id="继承的函数">继承的函数</h4><ul>
<li><p>并不是所有公有函数都会被继承</p>
<ul>
<li>构造函数，并不会被继承，虽然看起来像是继承(即基类中可以调用)</li>
<li>重载或者自动生成的 <code>operator=</code> 不会被继承，因为它表现的十分类似一个构造函数干的事情</li>
</ul>
</li>
<li><p>当我们试图去创建一个对象的时候，构造函数会按照既定的顺序(基类到继承类)依次调用</p>
</li>
<li>其中 拷贝构造函数在被调用的时候，会默认去调用其上一级基类的 <strong>默认构造函数</strong> 而非 上一级基类的 <strong>拷贝构造函数</strong>，如果要调用上一级的 <strong>拷贝构造函数</strong>， 就需要<strong>显式</strong>地在 初始化列表 中调用，否则可能会导致拷贝失败。<ul>
<li>出现 <strong>拷贝构造函数</strong> 调用上一级基类的 <strong>默认构造函数</strong> 的情况，只有当类设计者自行编写 <strong>拷贝构造函数</strong> 且未显式调用上一级基类的 <strong>拷贝构造函数</strong> 才会发生</li>
<li>故设计类时：<ol>
<li>如果决定让 <strong>拷贝构造函数</strong> 由编译器自动生成，那么就证明新类(即当前类)中没有 <strong>复杂类型</strong> 成员(或复杂类型够健全)，那么编译器自动生成的拷贝构造函数会自动调用基类的拷贝构造函数，以及类成员的拷贝构造函数。</li>
<li>如果决定自己实现 <strong>拷贝构造函数</strong> 那么久需要记住，一定要显式的调用基类的拷贝构造函数，否则将会出错(编译器会默认调用基类的<strong>默认构造函数</strong>)</li>
</ol>
</li>
</ul>
</li>
<li><code>operator=</code> 也是如此。</li>
</ul>
<h3 id="虚函数_和_多态">虚函数 和 多态</h3><ul>
<li><p><code>virtual</code>关键字修饰的函数(虚函数)的重定义叫做 <strong>重写</strong>, 在 <strong>C++11</strong> 中可以使用 <code>override</code> 来防止不小心写成重载</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="comment">//...</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span>{ 
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"counts = "</span> &lt;&lt; counts &lt;&lt; endl;
    }
<span class="comment">//...</span>
<span class="keyword">class</span> Deri : <span class="keyword">public</span> ClDefByMe{
<span class="comment">//...</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> override</span>{ <span class="comment">//如果不小心写成重载，编译器就会提醒你。</span>
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"counts of Deri = "</span> &lt;&lt; counts &lt;&lt; endl;
    }
</code></pre><p>无论是传递参数的形式，或者数组(容器也一样)的存储，只要是 <strong>指针/引用</strong> 的形式，都能触发多态效果。</p>
</li>
<li>虚函数的一个最关键的性质就是 <strong>延后绑定</strong> ，用来实现 <strong>多态</strong></li>
<li>对于虚函数而言，在类设计的继承体系中，<strong>要么不用，要么就到处都用</strong>。</li>
<li><p>绑定(提前绑定 和 延后绑定)</p>
<ol>
<li>提前绑定 这是 C 与 C++ 共有的特性</li>
<li>延后绑定，当运行时(runtime)才进行绑定，只对 <strong>引用</strong> 以及 <strong>指针</strong> 有效，也就是说对实际的对象是不起作用的。绑定的内容就是决定调用继承体系中某个类的某个函数。</li>
<li>如果使用的是 <strong>完整的类对象</strong> 调用虚函数，编译器会将其自动处理(<strong>可能</strong>)为 提前绑定(因为即使此时时候延后绑定也是同样的结果，只是耗时而已，但更简单)，因为这时候所有的信息都是完整的，足以判断调用哪个版本的函数。而指针和引用则不同，某个类型的 <strong>指针/引用</strong> 也可以指向其继承类的对象，所以需要延后绑定来判断。</li>
</ol>
</li>
<li><p>虚函数是如何被调用的，实现的机制就是指针</p>
<ul>
<li>首先一个类中有至少一个的虚函数。</li>
<li>编译器隐式地创建了一张表，整个继承体系的每个类都拥有一张这种表，称之为<strong>虚函数表</strong>(<strong>VTABLE</strong>)，表中存放着类中的所有虚函数</li>
<li>在每个类(继承类和基类)中，自行添加一个成员 <strong>vpointer</strong>(简写为<strong>VPTR</strong>)，类型是指针的指针，指向这张虚函数表(虚函数表中保存着函数的地址)。</li>
<li>每次通过父类的指针或引用调用虚函数的时候，编译器就会迅速地通过<strong>VTPR</strong>去虚函数表中查找正确的函数地址，并调用它。 </li>
<li>无论有多少虚函数，都只有每个类都只有一个 <strong>VPTR</strong>，原因很明显。</li>
</ul>
</li>
<li><p>关系呈现</p>
<pre><code> <span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">_           _</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>_
| ClDefByMe |      ----&gt;|  ClDefByMe::output      |
|<span class="strong">_____</span><span class="emphasis">_vptr_</span>| <span class="strong">____|    |__</span><span class="strong">____其他虚函数__</span><span class="strong">_____</span><span class="emphasis">___</span>|
<span class="strong">_____</span><span class="strong">_____</span><span class="strong">___          __</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>
| Deri      |     ----&gt;|     Deri::output        |    
|<span class="strong">_____</span><span class="emphasis">_vptr_</span>| <span class="strong">____|    |__</span><span class="strong">____其他虚函数__</span><span class="strong">_____</span><span class="emphasis">___</span>|
</code></pre><ul>
<li>虚函数表中的函数指针，顺序是一定的，由编译器决定如何排序。可以保证的是所有表的顺序是一致的，和类设计这按什么顺序重写无关。</li>
<li>也就是说，表中相同位置的函数指向的是同名函数，如果没有在继承类中<strong>重写</strong>某个虚函数，则继承类会延用基类的版本。这些工作都在一个类对象创建的时候完成，也就是构造函数的工作(初始化VPTR)。</li>
</ul>
</li>
<li><p>纯虚函数 与 抽象基类</p>
<ul>
<li>抽象就是将所有相关物体具有的共性提取出来，抽象程度越高代表的特性也就越多，也越难以理解，<strong>C++</strong>中抽象基类无法创建实际对象，只是一个承载接口的平台，用以被继承。</li>
<li><p>纯虚函数是抽象基类的特点，其可以只有声明而，没有定义。但是抽象基类的继承类必须重写该虚函数(这个只对最近一级的继承类有效)。</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数，无函数体</span>
<span class="comment">//...</span>
<span class="keyword">class</span> <span class="title">Deri</span> : <span class="title">public</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>{
    <span class="comment">//Do something</span>
}
</code></pre></li>
<li>这也是为什么抽象基类无法创建对象的原因，由于抽象基类含有纯虚函数，而编译器依然会为其生成一张<strong>VTABLE</strong>表,一个<strong>VPTR</strong>指针，但是仅仅只是预留了位置给出纯虚函数，表中并没有有用的实际信息，而一个包含不完整信息的类是无法创建对象的，所以只要一个类拥有了纯虚函数，其就无法创建实际对象。</li>
<li>这也能及时发现是否误写为按值传递，导致动态绑定没有成功，因为抽象基类没有办法创建对象，也就无法按值传递了。</li>
</ul>
</li>
<li><p>由于在继承类中重定义(重写)一个在基类中存在重载的函数，会隐藏所有的重载版本，对于虚函数来说，其无法改变返回值和参数：</p>
<ul>
<li>返回值，在不改变参数的条件下，改变返回值，会无法通过编译，因为如果在继承类中重定义了一个在基类中重载的函数，那么基类的所有重载函数都将在继承类中被隐藏，导致如果基类的这个 <strong>重写的函数</strong> 如果不与继承类的虚函数一致的话，将会导致 <strong>多态失效</strong> ，这将会导致某些后续的问题，所以编译器阻止了修改返回值的行为。</li>
<li>参数，如果修改了参数，就相当于重载了这个函数，那么将隐藏基类继承来的虚函数及其重载函数，此时如果将其上切(upcasting)，可以恢复被隐藏的函数。    </li>
<li><p>当虚函数的返回值是 <strong>继承体系中类的指针或者引用</strong> 的时候，在继承类中可以修改返回值的类型，类型可以是继承体系中的任意的类，只要在继承之中即可。</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="keyword">virtual</span> ClDefByMe* output(){
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
<span class="comment">//...</span>
<span class="keyword">class</span> <span class="title">Deri</span> : <span class="title">public</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    Deri* output() <span class="keyword">override</span>{
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
</code></pre><p>编译通过，由于添加了 <code>override</code> 关键字，我们可以确保这的确是虚函数的重写 </p>
</li>
</ul>
</li>
<li>在构造函数里调用虚函数，那就是调用本类(本地)的虚函数版本，并不涉及到延后绑定机制</li>
<li>在析构函数里也是如此</li>
<li><p><strong>成为虚函数的析构函数</strong> </p>
<ul>
<li>让析构函数成为虚函数的目的就是为了防止在程序员动态分配内存(heap上)，并且销毁对象时可能出现的错误</li>
<li><p>这种错误出现在，当你对析构函数使用多态这种机制的时候：</p>
<ul>
<li><p>在创建一个对象，起先并不知道其类型，用继承体系中的基类指针指向(即使用new创建)，在之后的某个情形下，使用 <code>delete</code> 销毁，如果此时析构函数非虚函数，则会导致内存泄漏的Bug，因为此时 <code>delete</code> 只会调用当前类型版本的析构函数，对于其基类的析构函数并不会调用.</p>
<pre><code><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">___</span>_
|        Deri2         |
|    <span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>   |
|    |    Deri1    |   |
|    |    <span class="strong">_____</span>_   |   |
|    |    |Base|   |   |
|    |    |<span class="emphasis">___</span>_|   |   |
|    |<span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">___</span>|   |
|<span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>__|
</code></pre><p>  其中如果让析构函数成为虚函数，则 <code>delete</code> 时会层层调用各个类的析构函数，如果为普通成员函数，则只会调用某一层的析构函数。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数的 析构函数</p>
<ul>
<li><p>它要有一个函数体，即所谓的定义。可以显式的定义它为 内联。因为要给它函数体，所以必定要在类外定义，这就无法成为内联函数，所以需要显式指定</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="comment">//..</span>
    <span class="keyword">virtual</span> ~ClDefByMe() = <span class="number">0</span>;
...
<span class="keyword">inline</span> ClDefByMe::~ClDefByMe() {} <span class="comment">//即使没做任何事</span>
</code></pre></li>
<li>对于析构函数而言，当它是<strong>纯虚函数</strong> 时，其继承类并没有被强制要求 需要重写这个函数，为了达到这个目的，所以我们给了基类的纯虚函数 一个函数体，这样编译器就能自动为我们生成继承类的析构函数版本。</li>
</ul>
</li>
</ul>
<h4 id="C++_显式类型转换">C++ 显式类型转换</h4><ul>
<li>一共四个转换： <ol>
<li><code>static_cast</code> </li>
<li><code>const_cast</code> </li>
<li><code>reinterpret_cast</code> </li>
<li><code>dynamic_cast</code></li>
</ol>
</li>
<li>之所以需要他们，是因为由 C语言继承过来的<strong>强制类型转换</strong>含有许多漏洞，它无法给予我们任何信息，只是简单的执行了类型转换。</li>
</ul>
<ol>
<li><p>用于普通的类型转换，即强制类型转换能做的，它也能做，区别于是否在必要的时候提供一个警告信息：</p>
<pre><code><span class="keyword">int</span> i = <span class="number">0</span>
<span class="keyword">float</span> j = <span class="number">0</span>;
<span class="keyword">long</span> k = <span class="number">0</span>;
i = k;
i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(k);
j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(k);
</code></pre></li>
<li><p>用来去除 <strong>const/volatile</strong> 属性</p>
<pre><code><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;
<span class="keyword">int</span> * j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;i);
</code></pre></li>
</ol>
<p>转载注明: <a href="http://www.wushxin.top/2015/07/09/Cpp%E8%AE%B0%E5%BD%9510.1k.html" target="_blank" rel="external">http://www.wushxin.top/2015/07/09/Cpp%E8%AE%B0%E5%BD%9510.1k.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="更新于_2015/7/14_21:14:21">更新于 2015/7/14 21:14:21</h3><h4 id="再记录_operator=_重载">再记录 operator= 重载</h4><ul>
<li>因为在类的设计中 重载 <code>=</code> 可能是在所难免的，如果你的类设计比较复杂。</li>
<li>之所以需要重载它是为了当类中包含了复杂的关系的时候，提供了一个人为的保证，最典型的莫过于对象的拷贝：<ol>
<li>假设 类中有一个成员是指针，指向一个对象，这个对象可以是数组，也可以是其他类或者容器。</li>
<li>当我们执行赋值操作符的时候，假定这里规范的使用赋值运算符，让其一定能调用<strong>赋值拷贝构造函数</strong> <code>=</code> ，此时对于这个指针成员，就有两种情形： <strong>拷贝指针</strong> 或者 <strong>拷贝对象</strong> 。</li>
</ol>
</li>
<li><strong>拷贝指针</strong>，即便不重载运算符 <code>=</code> 编译器也会帮你自动实现，这在国内大概就叫做 <strong>浅拷贝</strong> ，如果仅仅拷贝指针，这就引发了一个问题，多个对象共享一个实际内存，当执行析构函数的时候，会造成多次析构同一个内存块。</li>
<li><strong>拷贝对象</strong>，这是普遍的解决方法，在拷贝的同时，将指针所指向的对象同样做一份拷贝，似乎也不错，但是如果对象太大，似乎并不是什么很喜人的事 情，但也不失为一种好的解决方案]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp记录10.4k]]></title>
    <link href="http://www.wushxin.top/2015/06/21/Cpp%E8%AE%B0%E5%BD%9510.4k.html"/>
    <id>http://www.wushxin.top/2015/06/21/Cpp记录10.4k.html</id>
    <published>2015-06-21T03:38:55.000Z</published>
    <updated>2016-03-25T00:03:39.045Z</updated>
    <content type="html"><![CDATA[<h4 id="更新于_2015/7/9_10:03:12">更新于 2015/7/9 10:03:12</h4><h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span>
{
    <span class="keyword">int</span> challenge = <span class="number">0</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>
    </span>{
        ...
}
</code></pre></li>
<li><p>名称空间的创建</p>
</li>
</ul>
<p>一般来说，声明实现是要分离的，而对于一个名称空间来说，不能再某个名称空间中声明了，却在另一个名称空间里定义，所以我们一般在头文件中声明它，并在实现文件中定义它们</p>
<pre><code><span class="comment">// file1.h</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        ...
}


<span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }

        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }
}
</code></pre><ul>
<li><p>使用名称空间的时候，最好避免全部倒入，容易造成名称污染。<a id="more"></a></p>
<pre><code><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//不建议这么做</span>

<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;
<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="comment">//最好如此或者，更好的做法是:</span>

<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In the Real Code"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="comment">//但是这么做会让代码显得十分臃肿，所以取舍在于自己。</span>
</code></pre></li>
</ul>
<ul>
<li>类设计中特殊的函数</li>
</ul>
<p>一个类，当它拥有这样的构造函数时：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Wushxin</span></span>{

<span class="keyword">public</span>:
        Wushxin() {}
        Wushxin(<span class="keyword">double</span> heigth);
...
<span class="keyword">private</span>:
        <span class="keyword">double</span> my_heth;
...
};
</code></pre><p>我们可以这么使用它：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Wushxin FirstCopy;
    FirstCopy = <span class="number">178.6</span>; <span class="comment">//这样的赋值是成立的</span>
                       <span class="comment">//首先调用Wushxin(double heigth)，将176.8传入，</span>
                       <span class="comment">//将生成一个临时的Wushxin类型的对象，再拷贝进FirstCopy对象中。</span>
    <span class="keyword">double</span> heigth = FirstCopy; <span class="comment">// 可行吗？，答案是不可行</span>
...
</code></pre><p>但是，如果要让他成立，自然也有方法：</p>
<p>很少使用的特殊函数：</p>
<pre><code><span class="keyword">class</span> <span class="title">Wushxin</span>{
...
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>{
            <span class="keyword">return</span> my_heth;
    }
...
}; 
</code></pre><p>如此定义一个特殊的转换函数之后，我们就能无错的编译通过并运行上述代码了。</p>
<h4 id="const">const</h4><ul>
<li><p>在C++中，<code>const</code>默认是内部链接，即只能在本文件中可见，如果想让其他文件也能使用，则应该添加<code>extern</code>说明符</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> sizes = <span class="number">100</span>;
</code></pre><p>代表着，编译器给它分配了内存空间，使得其他文件能够找到它</p>
</li>
<li><p>一个<code>const</code>的临时变量，总能将自己的地址传递给函数：</p>
<ul>
<li><p>这句话的意义在于，我们可以让一个函数返回值的过程中，所创建的临时变量，被林一个函数以<code>const &amp;</code>接收，并保证它的正确性和效率。</p>
</li>
<li><p>一个函数的返回值所创建的临时对象(编译器创建它的目的是为了保存返回值)，只能被<code>const</code>的参数列表接收，这是因为任何对临时变量进行修改的操作都是无意义的，因为最后临时变量都是要被销毁的(在表达式之后)。</p>
</li>
<li><p>一个临时变量是不能够被取地址的，而且编译器总是把<strong>临时类对象</strong>当成常量。</p>
</li>
</ul>
</li>
<li><p>一个<code>const</code>对象，必须在创立的时候就初始化它，所以选择在构造函数里的参数列表中对<code>const</code>进行初始化是一个最好的选择。</p>
<pre><code><span class="tag">MyClass</span>(int args)<span class="pseudo">:mem_int</span>(args) {} 
</code></pre></li>
</ul>
<h4 id="引用">引用</h4><ul>
<li>引用经常被用在函数的参数列表以及返回值类型。</li>
<li><p>当使用引用作为参数的时候，如非必要，我们要尽最大限度的让参数是 <code>const &amp;</code>：</p>
<ul>
<li>如果我们按值传递(Pass By value),那么我们就需要一个构造函数和一个析构函数的调用，而如果是常量引用，我们紧紧需要将这个对象的地址压入函数建立的栈中。</li>
</ul>
</li>
</ul>
<h4 id="auto_(C++11)">auto (C++11)</h4><ul>
<li><code>auto</code> 并不能自动的添加 <code>const</code> 属性，只能人为选择是否添加</li>
<li><p><code>auto</code> 可以与 <code>decltype</code> 配合使用，来推断函数的返回值，在<strong>C++14</strong>中可以只用 <code>auto</code> ，但对于 <strong>C++11</strong> 而言：</p>
<pre><code><span class="function"><span class="keyword">auto</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> -&gt; <span class="title">decltype</span><span class="params">(arg_1+arg_2)</span> 
</span>{
    <span class="keyword">return</span> arg_1+arg_2;
}
</code></pre><p>在代码中，auto的作用就是占一个位置，类型由 <code>-&gt; decltype(x+y)</code> 提供，与Lambdas的语法类似。</p>
</li>
</ul>
<h4 id="copy-construction">copy-construction</h4><ul>
<li>对于一个类而言，一个拷贝构造函数是十分有必要的，它能有效的防止你的类对象在传递的时候不出错，否则，由于C++要与C语言进行兼容，在按值传递(<strong>Pass By Value</strong>)故采用的是<strong>位拷贝</strong>，这会导致并不是真正的重新构造一个新的临时对象，但是在退出函数的时候，却会调用<strong>析构函数</strong>，相当于一不小心把传递进来的这个对象给销毁了！而我们并没有想让它被改变，所以我们当初才采用按值传递。</li>
<li>这一点十分重要。</li>
<li><p>拷贝构造函数，通常是这样的：</p>
<pre><code>ClassDefineByMe(<span class="keyword">const</span> ClassDefineByMe &amp; PassObj);
<span class="comment">//ClassDefineByMe是自己定义的类型</span>
</code></pre></li>
<li>总之，拷贝构造函数是为了解决按值传递这个问题的，如果你不会用到按值传递，那么可以关闭它(<code>=delete</code> — <strong>C++11</strong> OR <code>private it</code> — <strong>C++98</strong>)。或者干脆一些，不显式定义，交给编译器去自动生成。</li>
</ul>
<h4 id="operator=_重载">operator= 重载</h4><ul>
<li>当我们在表达式中使用 <code>=</code> 时，对于内建类型，自然是很简单的拷贝，对于C++的容器而言，自有重载好的 <code>=</code> 进行拷贝操作。</li>
<li><p>对于自己定义的类而言，当我们：</p>
<pre><code><span class="title">ClDefByMe</span> tmp1 = <span class="number">1</span>;
<span class="title">ClDefByMe</span> tmp2 = tmp1;
<span class="title">tmp1</span> = tmp2;
</code></pre><p>第一句调用匹配的构造函数或者默认构造函数，第二句调用拷贝构造函数(而不是 <code>=</code> )，第三句才是使用重载后的<code>=</code>(假设类中重载了它)</p>
</li>
<li><p>所以对于初始化以及赋值而言，为了清晰明了，我们在初始化定义一个新的对象的时候，时空直接初始化的语法即：</p>
<pre><code><span class="function">ClDefByMe <span class="title">tmp</span><span class="params">(<span class="number">1</span>)</span></span>;
</code></pre></li>
<li><p>对于已经创建好的对象进行赋值的时候，使用<code>=</code></p>
<pre><code><span class="attribute">tmp2 </span>=<span class="string"> tmp;</span>
</code></pre><p>这样就能很清楚的看出使用的是<code>=</code>的功能。</p>
</li>
</ul>
<h4 id="指向类成员的指针">指向类成员的指针</h4><ul>
<li>实际上，因为类的实际对象，一直到运行时才会有具体的地址，但是我们如果对某个还没有生成的对象中的成员取地址呢？</li>
<li>可以，但那并不是真正的地址，而是取到<strong>偏移量</strong>，但是表面上看着像取了地址一般，所以由此引发了两种新的怪异语法糖： <code>-&gt;*</code> 和 <code>.*</code></li>
<li><p>也就是说，对一个类成员成员，无论是数据成员还是成员函数，都是一样的。就是语法有些怪异。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ClDefByMe</span></span>{
<span class="keyword">public</span>:
    ClDefByMe():count(0),pubIntMem(0){}
    ClDefByMe(<span class="keyword">int</span> PreKey):count(PreKey),pubIntMem(0){}
    <span class="function"><span class="keyword">void</span> <span class="title">getCounts</span><span class="params">()</span></span>{
        std::cout &lt;&lt; <span class="string">"The count is "</span> &lt;&lt; count &lt;&lt; std::endl;
    }
    <span class="keyword">int</span> pubIntMem;
<span class="keyword">private</span>:    
    <span class="keyword">int</span> count;
};
</code></pre><p>这是类的实现，类中有一个 <code>int</code> 私有数据成员, <code>int</code> 公有数据成员，和一个成员函数</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    ClDefByMe testObj, *pToObj = &amp;testObj;
    <span class="comment">//我们可以这么用</span>
    <span class="keyword">int</span> ClDefByMe::*pToInt = &amp;ClDefByMe::pubIntMem;
    <span class="keyword">void</span> (ClDefByMe::*pToFunc) = &amp;ClDefByMe::getCounts;
    <span class="comment">//可以直接初始化，也可以声明完后再初始化。</span>
    testObj.*pToInt = <span class="number">10</span>; <span class="comment">//现在数据成员pubIntMem的值为10</span>
    (testObj.*pToFunc)(); <span class="comment">//调用。</span>
    <span class="comment">//pToObj-&gt;*pToInt = 10;</span>
    <span class="comment">//(pToObj-&gt;*pToFunc)();</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>其中域解析操作符 <code>::</code> 一定要有，其次函数前方的取地址符号<code>&amp;</code>也一定要有。虽然函数名即使函数地址，但是此处并非真正的取函数地址，而是偏移量。</p>
</li>
</ul>
<h4 id="运算符重载">运算符重载</h4><ul>
<li>用于自定义类的运算符重载</li>
<li>不能重载一切内建类型的运算符，不能重载不存在的运算符(如 <code>**</code> )，</li>
</ul>
<blockquote>
<p>重载方式1： <strong>友元函数形式</strong></p>
</blockquote>
<ul>
<li><p>.</p>
<ul>
<li>特点：<ul>
<li>可以在类的外部直接操作类的私有成员</li>
<li>但是不能使用 <code>this</code> 指针</li>
<li>类外实现时，可以不带域解析操作符，而一般类成员函数却要</li>
<li>使用所重载的运算符时，可以任意调换<strong>运算符</strong>两边的<strong>操作数</strong>，只需要有对应的重载函数即可。</li>
</ul>
</li>
<li><p>声明：</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="keyword">public</span>:
    <span class="comment">//...构造函数 和 接口</span>
    <span class="comment">//新增接口:</span>
    ClDefByMe* address(){ <span class="keyword">return</span> <span class="keyword">this</span>; }

    <span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">friend</span> ClDefByMe* 
            <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> ClDefByMe&amp;); <span class="comment">//重载取地址运算符</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe&amp;
            <span class="keyword">operator</span>++(ClDefByMe&amp;); <span class="comment">//重载前缀递增操作符</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>++(ClDefByMe&amp;, <span class="keyword">int</span>); <span class="comment">//重载后缀形式</span>
    <span class="comment">//递减运算符类似。</span>
    <span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

    <span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>+(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">int</span>);

    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="keyword">friend</span> ClDefByMe&amp;
            <span class="keyword">operator</span>&amp;=(ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="keyword">private</span>:
    <span class="comment">//...数据成员</span>
};
</code></pre></li>
<li><p>类外部实现：</p>
<pre><code><span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;记得不必写friend&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
ClDefByMe* operator&amp;(<span class="keyword">const</span> ClDefByMe&amp; GetAddress)
{
    <span class="keyword">return</span> GetAddress.address();
}<span class="comment">//此处并没有用到域解析操作符，因为是友元函数</span>
<span class="keyword">const</span> ClDefByMe&amp; operator++(<span class="keyword">const</span> ClDefByMe&amp; PrePlus)
{
    ++PrePlus.<span class="keyword">count</span>;
    <span class="keyword">return</span> PrePlus;
}
<span class="keyword">const</span> ClDefByMe operator++(ClDefByMe&amp; PostPlus, int)
{<span class="comment">//int可以看成一个永远不会被使用的标志，值由编译器提供。</span>
    ClDefByMe tmpRet(PostPlus.getCounts());
    ++PostPlus.counts; <span class="comment">//此处使用前缀后缀都无所谓，推荐前缀</span>
    <span class="keyword">return</span> tmpRet; <span class="comment">//使用这个返回值的表达式结束后，这个对象立刻被销毁，不用担心内存问题</span>
}
<span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&amp;在此处是二元运算符与&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe operator+(<span class="keyword">const</span> ClDefByMe&amp; addObjLeft, <span class="keyword">const</span> ClDefByMe&amp; addObjRight)
{
    <span class="keyword">return</span> ClDefByMe(addObjLeft.<span class="keyword">count</span> + addObjRight.<span class="keyword">count</span>);
}

<span class="keyword">const</span> ClDefByMe operator&amp;(<span class="keyword">const</span> ClDefByMe&amp; andObjLetf, <span class="keyword">const</span> ClDefByMe&amp; andObjRight)
{
    <span class="keyword">return</span> ClDefByMe(andObjLeft.<span class="keyword">count</span> &amp; andObjRight.<span class="keyword">count</span>);
}
ClDefByMe&amp; operator&amp;=(ClDefByMe&amp; andassiLeft, <span class="keyword">const</span> ClDefByMe&amp; adnassiRight)
{<span class="comment">//此处注意，Left是非const，因为根据语法 x &amp;= y 中的x是需要拥有被改变的权限的，</span>
 <span class="comment">//并且返回值设为非const也是为了这个权限考虑</span>
    <span class="comment">//在这种永久改变操作对象的实现中，我们要注意一点就是，</span>
    <span class="comment">//如果运算符两边的操作数是同一个的情况</span>
    <span class="keyword">if</span>(&amp;andassiLeft == &amp;andassiRight) <span class="comment">//判断是否相同</span>
    {
        andassiLeft.<span class="keyword">count</span> = andassiRight.<span class="keyword">count</span> &amp; andassiRight.<span class="keyword">count</span>;
        <span class="keyword">return</span> andassiLeft;    
    }
    andassiLeft.<span class="keyword">count</span> &amp;= andssiLeft.<span class="keyword">count</span>;
    <span class="keyword">return</span> andassiLeft;
}

<span class="keyword">const</span> ClDefByMe operator&lt;&lt;(<span class="keyword">const</span> ClDefByMe&amp; lmoveLeft, int moveBits)
{
    <span class="keyword">return</span> ClDefByMe(lmoveLeft.<span class="keyword">count</span> &lt;&lt; moveBits);
}<span class="comment">//注意这不是重载输出流的运算符，而是移位运算符</span>
<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>重载方式2：<strong>成员函数形式</strong></p>
</blockquote>
<ul>
<li><p>.</p>
<ul>
<li>特点：<ul>
<li>可以使用this指针</li>
<li>与普通的成员函数一眼</li>
<li>当所重载的运算符左边不是该类的对象时重载失效。</li>
<li>成员函数形式的重载，相当于运算符左边的操作数被默认定下（即对象本身）</li>
</ul>
</li>
<li><p>声明：</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="keyword">public</span>:
    <span class="comment">//...构造函数 和 接口</span>

    <span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">const</span> ClDefByMe&amp; <span class="keyword">operator</span>+(); <span class="comment">//一元运算符 取正</span>
    <span class="keyword">const</span> ClDefByMe&amp; <span class="keyword">operator</span>--(); <span class="comment">//前缀递减</span>
    <span class="keyword">const</span> ClDefByMe  <span class="keyword">operator</span>--(<span class="keyword">int</span>); <span class="comment">//后缀递减</span>
    <span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

    <span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>-(<span class="keyword">const</span> ClDefByMe&amp;);  <span class="comment">//二元运算符 减法</span>
    <span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span>); <span class="comment">//二元运算符 右移</span>
    ClDefByMe&amp;      <span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> ClDefByMe &amp;); <span class="comment">//组合运算</span>
    <span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">private</span>:
    <span class="comment">//...</span>
};
</code></pre></li>
<li><p>类外部实现：</p>
<pre><code><span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;使用域解析操作符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>+()
{
    <span class="keyword">return</span> ClDefByMe(counts); <span class="comment">//也可以返回 *this,不过类型要变为</span>
                              <span class="comment">// const ClDefByMe &amp;</span>
}
<span class="keyword">const</span> ClDefByMe&amp; ClDefByMe::<span class="keyword">operator</span>--()
{
    --counts;     <span class="comment">//因为是成员函数，可以直接操作私有成员</span>
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    <span class="keyword">return</span> ClDefByMe(counts--);
}
<span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>+(<span class="keyword">const</span> ClDefByMe&amp; addArgRight)
{
    <span class="keyword">return</span> ClDefByMe(count+addArgRight.count);<span class="comment">//直接操作私有成员    </span>
}
<span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span> moveBits)
{
    <span class="keyword">return</span> ClDefByMe(count &gt;&gt; moveBits);
}

ClDefByMe&amp; <span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> ClDefByMe &amp; andassiRight)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;andassiRight)
    {
        count = andassiRight.count &amp; andassiRight.count;
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }
    count &amp;= andassiRight.count;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>某些特殊的操作符重载</p>
</blockquote>
<pre><code><span class="comment">//某些操作实现包含在&lt;iostream&gt;中</span>
<span class="keyword">friend</span> ostream &amp; 
    <span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> ClDefByMe &amp;);<span class="comment">//类中声明 重载输出</span>
ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; streams, <span class="keyword">const</span> ClDefByMe &amp; outRight)
{
    streams &lt;&lt; outRight.count &lt;&lt; endl;
    <span class="keyword">return</span> streams; <span class="comment">//没有return其实也行，但是就无法嵌套输出了。</span>
}
</code></pre><p>此处，传递的参数和返回值必须是引用(对于流)，这样在函数里的改变才能影响到外部。</p>
<p>输入也是一样。</p>
<ul>
<li><p>总结</p>
<ol>
<li>对于一元运算符而言，成员函数形式总是比较适合的。</li>
<li>一些正常的数学运算，将传递的参数都置为 常量引用(<code>const &amp;</code>)</li>
<li>对比成员函数形式和友元函数形式的重载，后者可能将具有更高的灵活性，例如类型转换，比如表达式： <code>a+1</code>,两种形式的重载都合法，但是换一个写法 <code>1+a</code>,成员函数形式的写法一定会报错，但是友元函数的写法只要有对应的构造函数进行类型转换(将1构造成对应的类型)就能通过编译。<strong>因为</strong>对于成员函数的实现而言，其左操作数的类型必须是完全匹配的。</li>
<li>所有赋值运算符这一类运算符(如=, +=, &amp;=, …)的重载，需要改变其左边的操作数，<ul>
<li>对于友元函数形式的，就需要将左操作数声明为非 <code>const</code> 参数，否则就在函数参数列表中把它们都声明为 <code>const</code> </li>
<li>对于成员函数形式的，就需要将函数声明为 <code>const</code> 即可，其余不需考虑。</li>
</ul>
</li>
<li><p>返回值类型：</p>
<ul>
<li>对于返回临时对象，需要让返回值类型为 const value.</li>
<li>对于返回非临时对象的，需要让返回值类型为 const value reference.</li>
<li>如果是改变左值的运算符，那么就去掉返回值中的const，其余结构不变，何时改变，就是所有赋值一类的运算符。</li>
<li>但临时对象总是默认为 <code>const</code>，所以如果返回临时对象，但是不在返回值地方声明为 <code>const</code>，它依然是 <code>const</code>。</li>
<li><p>如果没有必要，请不要把(如果是版本新的编译器就无所谓了，会帮你优化)：</p>
<pre><code><span class="command">return</span> ClDefByMe(addObjLeft.<span class="command">count</span> + addObjRight.<span class="command">count</span>);
</code></pre><p>  写成</p>
<pre><code>ClDefByMe tmp(addObjLeft.<span class="command">count</span> + addObjRight.<span class="command">count</span>)；
<span class="command">return</span> tmp;
</code></pre><p>  这涉及到编译器的操作，一般情况下后面这种写法会多出一个操作，也就是调用拷贝构造函数，如果你的类恰好没定义，而这个类的拷贝又需要自己定义的拷贝构造函数，那就 Boom！</p>
</li>
</ul>
</li>
<li>推荐的重载写法：<ul>
<li>推荐写成 <strong>友元函数形式</strong> 的运算符： <code>所有二元运算符</code></li>
<li>必须写成 <strong>成员函数形式</strong> 的运算符： <code>=, (), [], -&gt;, -&gt;*</code></li>
<li>推荐写成 <strong>成员函数形式</strong> 的运算符： <code>所有赋值相关的运算符，如：</code><br><code>+=, /=, *=, &gt;&gt;=, ...</code></li>
<li>推荐写成 <em>*成员函数形式</em> * 的运算符： <code>所有一元运算符</code></li>
</ul>
</li>
<li>不可以重载的运算符：<ul>
<li><code>**</code>(不存在)， <code>.</code>(点运算符), <code>.*</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<p>转载注明: www.wushxin.top/2015/06/21/Cpp记录10.4k.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="更新于_2015/7/9_10:03:12">更新于 2015/7/9 10:03:12</h4><h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span>
{
    <span class="keyword">int</span> challenge = <span class="number">0</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>
    </span>{
        ...
}
</code></pre></li>
<li><p>名称空间的创建</p>
</li>
</ul>
<p>一般来说，声明实现是要分离的，而对于一个名称空间来说，不能再某个名称空间中声明了，却在另一个名称空间里定义，所以我们一般在头文件中声明它，并在实现文件中定义它们</p>
<pre><code><span class="comment">// file1.h</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        ...
}


<span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }

        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }
}
</code></pre><ul>
<li><p>使用名称空间的时候，最好避免全部倒入，容易造成名称污染。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Qt记录]]></title>
    <link href="http://www.wushxin.top/2015/06/12/Qt%E8%AE%B0%E5%BD%95.html"/>
    <id>http://www.wushxin.top/2015/06/12/Qt记录.html</id>
    <published>2015-06-12T00:42:47.000Z</published>
    <updated>2016-03-24T23:57:31.286Z</updated>
    <content type="html"><![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4><a id="more"></a>
<p>作为信号(signal)与槽(slot)，我们的信号函数的<strong>参数个数</strong>可以多于槽函数的参数个数，也就是说，我们可以选择接受不多于信号函数<strong>参数个数</strong>的参数，有点绕：</p>
<ul>
<li><p>信号函数的类：</p>
<pre><code><span class="keyword">class</span> Signal_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span>:
...
    <span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
    </span>{
        <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName, UserAge)</span></span>;
        <span class="comment">//UserName, UserAge 是该类的私有属性。</span>
    }
signals:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name, <span class="keyword">int</span> age)</span></span>;
<span class="comment">// ...</span>
</code></pre></li>
</ul>
<pre><code>-<span class="ruby"> 对于这段代码而言，有两个地方需要注意，<span class="string">`emit`</span>, <span class="string">`public signals:`</span>
</span>
    -<span class="ruby"> 此处故意令信号函数重载，是为了在后方体现，槽函数的参数个数可以小于或者等于信号函数的参数个数。
</span>    -<span class="ruby"> <span class="string">`emit`</span> 就是发射信号的意思。</span>
</code></pre><ul>
<li><p>槽函数的类：</p>
<pre><code><span class="keyword">class</span> Slot_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span> slots:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSlot</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span>
    </span>{
         QMessageBox mesbox;
         mesbox.setText(<span class="string">"Receive : "</span>+name);
         mesbox.exec();
    }
<span class="comment">// ...</span>
</code></pre></li>
<li><p>测试：</p>
<pre><code><span class="keyword">void</span> (Signal_Class::* p_to_test)(<span class="keyword">const</span> QString &amp;, <span class="keyword">int</span>) = 
     &amp;Signal_Class::Q_TestSignal;
    <span class="comment">//因为是重载函数，所以需要明确指明使用哪个作为连接的信号函数 </span>
QObject::connect(&amp;test_sig, p_to_test,
                 &amp;test_slot, Slot_Class::Q_TestSlot);
test_sig.Q_SendSignal(); <span class="comment">//发射信号</span>
</code></pre><blockquote>
<p>效果图</p>
</blockquote>
</li>
<li><p><img src="http://ww1.sinaimg.cn/mw690/81b736ebtw1et2ajoj7ydj20bk09f3ye.jpg" alt=""></p>
</li>
</ul>
<p>我们会发现，即使槽函数的参数个数与信号函数不一致（小于），但是依然可以接收到参数，但是需要注意的是，虽然能够自由选择接受的参数，但是依旧需要按照顺序(按照C++语法上的顺序)。</p>
<p>既然槽函数能够接受不多于信号函数参数个数的参数，那么我们自然而然能够想到，是否可以使用让槽函数拥有默认参数，以此来扩大槽函数的适用范围，答案是可以。</p>
<ul>
<li><p>依旧是上方的代码，改动些许：</p>
<ul>
<li><p>信号函数的类改动</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
</span>{
    <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName)</span></span>;
    <span class="comment">//UserName 是该类的私有属性。</span>
}
</code></pre></li>
<li><p>信号函数类改动</p>
<pre><code><span class="keyword">void</span> Q_TestSlot(<span class="keyword">const</span> QString &amp; name
              , <span class="keyword">const</span> QDate &amp; time = QDate::currentDate())
{
    <span class="comment">//需要添加#include &lt;QDebug&gt;</span>
    <span class="comment">//如果接受成功，可在终端看到输出。</span>
    qDebug() &lt;&lt; name &lt;&lt; time;
}
</code></pre></li>
<li>测试代码改动（关键点）</li>
<li><p>在此刻我们需要让编译器知道，我们的信号函数是一个参数，而槽函数是两个参数，其中一个是带有默认参数的，我们应该怎么做？函数指针对于默认参数是无效的，那么除了使用C++11新特性<strong>Lambda匿名函数</strong>以外，最直接的还是使用宏<strong>SLOT 和 SIGNAL</strong>，在这里我们使用这两个宏可以节省很多工作量，缺点就是无法在编译时刻知道是否匹配，所以我们需要小心谨慎的使用。</p>
<pre><code><span class="rule"><span class="attribute">QObject</span>:<span class="value">:<span class="function">connect</span>(&amp;new_paper_1, <span class="function">SIGNAL</span>(<span class="function">newPaper</span>(QString)),
                &amp;new_reader_1, <span class="function">SLOT</span>(<span class="function">receive_newpaper</span>(QString)))</span></span>;
</code></pre><p>可以看到，我们的槽函数明明有两个参数，但是此处<strong>SLOT</strong>宏内只出现了一个，这就表明已经告知编译器是默认参数。</p>
</li>
</ul>
</li>
<li><p><strong>Lambda 匿名函数在 connect 的应用</strong></p>
<ul>
<li>再实在没有办法用其他方法实现两个窗口或者不同对象之间的<strong>直接对话</strong>时候，可以考虑使用信号槽来间接实现</li>
<li><strong>Lambda</strong> 扮演的角色是让类更加简洁，语法更加简单。</li>
<li><p>到了 <strong>Qt5</strong> 时代，在使用信号槽语法的时候，更多的是用函数指针地址，而不是之前的<code>SIGNAL</code> 和 <code>SLOT</code> 宏，这样更能充分的发挥 <strong>Lambda</strong> 的性质。</p>
<pre><code>class MainWindows::MainWindow():
<span class="comment">//... 一些自动生成的初始化</span>
{
    <span class="comment">//...setup Ui</span>
    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=](){
       ui-&gt;browser_show-&gt;setText(QStringLiteral(<span class="string">"成功使用Lambda语法设置文本显示"</span>))；<span class="comment">//一个槽</span>
    ui-&gt;pushButton-&gt;setEnable(<span class="keyword">false</span>);<span class="comment">// 另一个槽</span>
    qDebug &lt;&lt; QStringLiteral(<span class="string">"成功使用Lambda语法！"</span>);

    }
    ...
}
</code></pre><p>这是基本使用方式，好处就是可以一次性的调用多个槽，而不是一个connect只能对应一对信号槽链接。</p>
</li>
</ul>
</li>
</ul>
<h4 id="老生常谈的_中文显示">老生常谈的 中文显示</h4><ul>
<li>使用 <strong>UTF-8</strong> 模式存储源文件（借助其他编辑器，例如 <strong>NotePad++</strong>, <strong>Sublime Text</strong> 等）</li>
<li>使用 <code>QStringLiteral 包裹中文</code></li>
<li>行了。</li>
</ul>
<p>转载注明: www.wushxin.top/2015/06/12/Qt记录.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4>]]>
    
    </summary>
    
      <category term="Qt" scheme="http://www.wushxin.top/tags/Qt/"/>
    
      <category term="杂货居" scheme="http://www.wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Opencv3.0.0配置]]></title>
    <link href="http://www.wushxin.top/2015/06/08/Opencv3%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.wushxin.top/2015/06/08/Opencv3配置.html</id>
    <published>2015-06-08T08:26:15.000Z</published>
    <updated>2016-03-24T23:59:58.858Z</updated>
    <content type="html"><![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/" target="_blank" rel="external">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="external">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html" target="_blank" rel="external">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/" target="_blank" rel="external">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4><a id="more"></a>
<p>有了上述两个工具之后，我们就可以着手配置自己的开发环境了，但是先要声明的是，每一个不同的工程项目就需要重新配置一次。</p>
<ol>
<li><p>工程项目是什么？就是 <strong>文件 -&gt; 新建 -&gt; 项目</strong>，在这里我们点击了项目之后出现一个窗口：<br><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwljr6jj211y0lc418.jpg" alt=""></p>
<p> 图片可能不太清晰，但是大概是这么一个回事，修改一下名称，以及存储位置(为了方便)之后，点击 <strong>确定</strong> 之后 Visual Studio 自动帮你生成一个工程项目，这时候先停下，回到桌面。</p>
<ul>
<li>打开目录： <strong>C:\opencv\build\x64\vc12\bin</strong>，查看里面是否有文件，并将目录添加到系统环境变量(<strong>PATH</strong>)当中，如何添加？<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwivdbyj20mz0cbdgq.jpg" alt=""> </li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwh92pcj20dp0gtq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgi9m8j20cp0fkdg7.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkxxz0j20bh05adfs.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>添加完环境变量以后，我们可以开始下一步的配置，根据第一步所创建的项目，我们打开它的属性管理器，当然很可能的就是你创建完成以后，自动就在这个界面，初始情况下，我们创建的是Win32(x86)的工程，这个时候我们需要做的就是，因地制宜。先前说了我是X86_64，也就是64位操作系统，那么我们就应该让整个环境适配他，<strong>(至于32位网上的教程很多)</strong></p>
<ul>
<li><p><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkirl7j20880hh749.jpg" alt=""></p>
<p>接下来，右键你的工程，选择 <strong>属性</strong>，可以很清楚的看见，右上角显示的是<strong>Win32</strong>，我们的目的是将其改为适配64位的开发环境：</p>
</li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwjcj8kj20lc0ea3zk.jpg" alt=""></li>
<li>如图所示，点击配置管理器，选择X64，并在外面将目标计算机改成x64<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwehzjxj20jw0e0aa7.jpg" alt=""></li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwf0k50j20jw0e0jrp.jpg" alt=""></li>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwfiqf9j20lc0fc3zn.jpg" alt=""> </li>
</ul>
</li>
<li>架构问题解决。接下去才是真正的配置步骤。</li>
<li>在属性管理器中，打开你的工程看见四个包含文件夹，删除Win32的两个，留下x64，右键 <strong>Debug|x64</strong> 文件夹，选择 <strong>添加新项目属性表(P)…</strong>，保存为 <strong>opencv_debug</strong> 以后，会发现多了一个属性表文件，如法炮制<strong>Release|x64</strong>文件夹，接下来的操作直到第五步，其它的两个属性表都一样</li>
<li><strong>(opencv_release)</strong></li>
</ul>
</li>
<li><p>首先是打开任意一个属性表文件(双击它= =)，在 <strong>配置属性 -&gt; VC++目录 -&gt; 包含目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>include 目录</strong>，按照我的路径格式，需要添加三个路径分别是：</p>
<blockquote>
<p>C:\opencv\build\include</p>
<p>C:\opencv\build\include\opencv</p>
<p>C:\opencv\build\include\opencv2</p>
</blockquote>
<ul>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwg1wm4j20lc0f4ab0.jpg" alt=""></li>
</ul>
</li>
<li><p>其次是，在 <strong>配置属性 -&gt; VC++目录 -&gt; 库目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>lib</strong> 目录，按照我的路径格式，需要添加路径是：</p>
<blockquote>
<p>C:opencv\build\x64\vc12\lib</p>
</blockquote>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwhuj95j20lc0gaab2.jpg" alt=""><br>这个便是存放依赖文件的地方，后续会用到。</li>
</ul>
</li>
<li><p>最后是，在 <strong>配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; &lt;编辑…&gt;</strong> 之中添加依赖，对于 <strong>Opencv-3.0.0</strong> 来说，我们只需要添加两个依赖就足够了，此处分为两部分：</p>
<ul>
<li><p>对于<strong>Debug|x64</strong>，也就是当下我们正在配置的这个属性表，添加两个文件:</p>
<blockquote>
<p>opencv_ts300d.lib</p>
<p>opencv_world300d.lib</p>
</blockquote>
<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwib94kj20sb0e1dh5.jpg" alt=""></li>
</ul>
</li>
<li><p>对于 <strong>Release|x64</strong>的属性表来说，需要添加剩下的两个文件：</p>
<blockquote>
<p>opencv_ts300.lib</p>
<p>opencv_world300.lib  </p>
</blockquote>
</li>
</ul>
</li>
<li>Ps: 对于其他版本的Opencv的依赖库添加，可以自行打开 <strong>lib</strong> 文件夹进行查看，不一定需要网上的教程。</li>
<li>如果不想每次创建工程的时候都这么麻烦，那么我们只需要把两个属性表拷贝出来就行了，下次直接导入即可。 </li>
<li>当两个属性表都配置完成之后，我们就大功告成啦，接下来进入最后一步，测试</li>
</ol>
<h4 id="测试">测试</h4><p>在 <strong>属性管理器</strong> 的旁边有一个 <strong>解决方案资源管理器</strong> ，点击之后，会发现这才是以后工作的场景</p>
<ol>
<li>在 <strong>源文件</strong> 文件夹中，添加C++源文件，在其中输入测试代码：<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgxfdfj20j009o74r.jpg" alt=""></li>
</ul>
</li>
</ol>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt; </span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\core\core.hpp&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\highgui\highgui.hpp&gt;  </span>

<span class="keyword">using</span> <span class="keyword">namespace</span> cv;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Mat img = imread(<span class="string">"temp.jpg"</span>);    

    <span class="keyword">if</span> (img.empty())
    {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>;
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    imshow(<span class="string">"mypic"</span>, img);
    waitKey();

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>保存。</p>
<ol>
<li>在 <strong>资源文件</strong> 文件夹中，添加图片<strong>temp.jpg</strong>，随便找一张格式是jpg的图，放进去就行，放进去的方式是 <strong>右键资源文件 -&gt; 添加 -&gt; 现有项(G)…</strong>，找到你的图片，双击，添加完成。</li>
</ol>
<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwnccirj20iy076wer.jpg" alt=""></li>
</ul>
<ol>
<li><p>点击 <strong>生成 -&gt; 生成解决方案</strong> ，之后点击 <strong>启动调试</strong> 也就是运行的意思。</p>
</li>
<li><p>很大的几率发现并不能正常的运行，错误提示无法打开PDB文件，查了一下，似乎尿性很高，于是乎有一个解决办法，不是无法打开吗？那就从微软的服务器在线下载过来，这个方法对每个工程都需要进行一次，但是第一次过后就不需要第二次了。请在联网情况下，完成下列操作，具体方法： </p>
<ul>
<li>依次点击 <strong>调试 -&gt; 选项与设置(G)…</strong> <ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwd6uz9j20ag0e9jry.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 常规</strong> ，勾选 <strong>启动源服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwdmf0nj20l20dqjsk.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 符号</strong> ，勾选 <strong>Microsoft服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwe3srkj20l20dqt9j.jpg" alt=""> </li>
</ul>
</li>
<li>中间如果有警告，一律选择是。</li>
</ul>
</li>
</ol>
<h4 id="2_配置_Code::Blocks_13-12">2 配置 Code::Blocks 13.12</h4><ul>
<li><p>首先打开安装好的 <strong>CMake-gui</strong>，在<strong>source code</strong>一栏加入源文件的路径，也就是下载的<strong>opencv</strong>里的<strong>source</strong>，在<strong>build binaries</strong>一栏加入输出的路径。</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9ay0n5j20n20jdq30.jpg" alt=""></li>
</ul>
</li>
<li><p>点击<strong>Tools -&gt; Configure</strong>，如图配置：</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9bdr6hj20n20jdglz.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后出现红色的选项，将<strong>WITH_IPP</strong>选项去掉，之后点击<strong>Options -&gt; Sipress dev Warnings</strong>，后点击<strong>Generate</strong>生成makefile文件：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9bvra5j20n20jd0td.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后，打开目录<strong>C:\opencv\mybuild</strong>，双击打开工程文件<strong>OpenCV.cbp</strong>开始编译，并附上编译后的文件夹图：<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1esxo9cnz6sj20h70eq0u6.jpg" alt=""></li>
</ul>
</li>
<li>编译结束后，如果一切正常，将上图中的<strong>bin</strong>加入路径</li>
<li>打开<strong>Code::Blocks</strong>，新建一个Console Application工程，右键工程名字，选择<strong>Build Option</strong>出现一个新窗口，在其中我们要开始配置<strong>Opencv</strong>：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo99ko98j20kw0fmq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo99xg7wj20kw0fmjrp.jpg" alt=""></li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9ajo5qj20rw0gataz.jpg" alt=""></li>
</ul>
</li>
<li>添加测试文件（和VS的一样）。</li>
</ul>
<h4 id="结束">结束</h4><p>就是这样如果还有什么错误的话，不妨去Google看看，比如dll不存在的问题，那一定是你没有把要使用的bin目录加入到系统环境当中</p>
<p>转载注明: www.wushxin.top/2015/06/08/Opencv3配置.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://www.wushxin.top/tags/Cpp/"/>
    
      <category term="Opencv" scheme="http://www.wushxin.top/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(5)---效率(下)]]></title>
    <link href="http://www.wushxin.top/2015/05/29/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C-5.html"/>
    <id>http://www.wushxin.top/2015/05/29/我为什么学C-5.html</id>
    <published>2015-05-29T13:19:50.000Z</published>
    <updated>2015-06-06T14:46:48.104Z</updated>
    <content type="html"><![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。<a id="more"></a>    
<ul>
<li>打个不太贴切的比喻，假设计算机是一个家，CPU是一个人，想象一下这个家中的所有物品都是井然有序的，这个人想要工作必然会需要工作物品，所以他需要从某些地方拿来，用完以后再放回去，这些地方就是存储器，但是过了一段时间发现这么做太浪费时间，有时候某些东西太远了，所以，人想把它把它放在离自己更进的地方，这样自己的效率就高很多，如果这个东西一段时间内不再用，则把它放回原处，留出位置给更需要的工作物品，于是形成了越常使用的物品离人越近的现象。这便是计算机存储器的分层结构的意义。</li>
<li>而对于一个有良好局部性的程序而言，我们总能在离自己最近的地方找到我们所需要的数据，回到计算机：我们知道计算机的存储器是分层结构的，即每一层对应着不同的读写速度等级(CPU寄存器 &gt; 高速缓存 &gt; 主存 &gt; 硬盘)，而我们的程序总是按照从左至右的顺序依次查找，每次找到一个所需要数据，不出意外，总是将其移动到上一层次的存储器中存储，以便下次更高速的访问，我们称这种行为叫做 <strong>命中</strong> 。越好的程序，越能将当时所需的数据放在越靠近左边的地方。这便是局部性的意义所在。</li>
<li>当然，存储器如此分层也是出于无奈，在处理器的速度和存储器的速度实在差距的情况下只有如此做才能让处理器更加充分的利用，而不至于等待存储器读写而空闲，也许某一天，当内存的<strong>位价</strong>和普通硬盘不相上下或者差距不多的时候，也许内存就是硬盘了。而当今也有人使用某些特殊的软件在实现这个功能，凭着自己计算机上大容量的内存，分割出来当作硬盘使用，存取速度让硬盘望尘莫及。</li>
</ul>
</li>
</ul>
<h4 id="局部性">局部性</h4><p>前方提到了局部性，局部性体现在了，当步长越大，空间局部性越低，大多数情况下会造成性能降低，比如最常见的多维数组循环(我鲜少使用多维数组的原因之一便在于此)，前面说过多维数组实际上只是数个一维数组的包装而已，C语言中并没有真正的多维数组，而是将其解读成内存中的一维的连续内存，但是当我们遍历它的时候，C语言为了不让我们被底层实现所困扰，所以生成了多维数组遍历的假象：</p>
<p>让我们重温一遍”多维数组”：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;    </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> dim_1_arr[<span class="number">4</span>]    = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
    <span class="keyword">int</span> dim_2_arr[<span class="number">2</span>][<span class="number">2</span>] = { {<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>} };
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)
        result_1 += dim_1_arr[i];
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>此例中，对一维数组进行步长为 <code>1</code> 遍历求和，假设内存中数组的起始位置是 <code>0</code></p>
<p><code>0 =&gt; 4 =&gt; 8 =&gt; 12</code></p>
<pre><code><span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; <span class="number">3</span>;++j)<span class="comment">{
    for(int i = 0;i &lt; 3;++i){
        result_2 += dim_2_arr[i][j];
    }</span>
}
</code></pre><p>此例中，我们的步长是多少呢？我们来看一下</p>
<p><code>0 =&gt; 8 =&gt; 4 =&gt; 12</code></p>
<p>可以很清晰的看出两段不同代码之间的跳跃，为什么？观察到多维数组的遍历中我们和平时的做法有些不同，是先对<code>i</code>进行遍历，再对<code>j</code>进行遍历，这就导致了程序必须在内存块中<strong>无规律</strong>的跳动，这里的无规律是计算机认为的无规律，虽然在我们看来的确是有迹可寻，优秀的编译器能够对它进行优化处理。就事论事，即这段程序的空间局部性比较差，对于一个在内存中大幅度跳跃，无规律跳跃的程序都将影响程序的性能。这个判定对于一个连续的内存块来说是很重要的，比如C语言中的结构体。</p>
<p>实际上C语言也是能够面向对象的，但是十分复杂，就像拿着棒子织衣服一样。而C语言的机构体能够让我们在一定程度上初步理解对象这个概念，因为它是一个完整的个体，虽然对外界<strong>毫不设防</strong>。</p>
<blockquote>
<p><strong>对于结构体</strong></p>
</blockquote>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> VECTOR 4</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">double</span> salary;
        <span class="keyword">int</span>    index[<span class="number">4</span>];
}test_data;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;
    test_data dim_1_arr[VECTOR];
    <span class="comment">/* ...填充数据 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
    {    
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
            result_1 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 1 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
            result_2 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 2 */</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre><p>还是和上方一样，假设 <code>dim_1_arr</code> 起始位置为 <code>0</code></p>
<p> <strong>for loop 1</strong>：</p>
<p><code>8 =&gt; 12 =&gt; 16 =&gt; 20 ==&gt; 32 =&gt; 36 =&gt; 40 =&gt; 44 ==&gt; ...</code></p>
<p><strong>for loop 2</strong>：</p>
<p><code>8 =&gt; 32 =&gt; 56 =&gt; 80 ==&gt; 12 =&gt; 36 =&gt; 60 =&gt; 84 ==&gt; ...</code></p>
<p>从上方不完整的比较来看，<strong>loop 1</strong> 相对于 <strong>loop 2</strong> 来说有更好的空间局部性，很明显在 <strong>loop 2</strong> 中，CPU读取是在无规律的内存位置跳跃，而 <strong>loop 1</strong> 则是以单调递增的趋势向前(这里的向前指的是直观上的向前)读取内存。</p>
<ul>
<li>在此处回顾一下C语言的结构体性质与知识：<ul>
<li>对于任意一个完整定义的结构体，每一个对象所占有的内存大小都符合<strong>内存对齐</strong>的规则。</li>
<li>对于结构体内的各个成员而言，其相对于对象存储地址起始的距离，称为<strong>偏移量</strong>。</li>
</ul>
</li>
<li><p>解释：</p>
<ul>
<li><p>内存对齐便是对于一个结构体而言，其所占内存大小总是最大成员的整数倍，其中最大成员指的是最基本成员，即：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
    test_data test_1;
    <span class="keyword">int</span>       test_2;
}test_data_2;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_2 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_2));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 32</code></p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index[<span class="number">4</span>];
        <span class="keyword">int</span> store_1;
        <span class="keyword">int</span> store_2;
}test_data_3;
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        test_data_3 test_3;
        <span class="keyword">int</span>         test_4;
}test_data_4;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_4 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_4));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 28</code></p>
<p>  仔细对比<code>test_data_3</code>与<code>test_data</code>的差异，可以发现不同处，在前者的内部包含了一个<code>double</code>类型的成员，在我的机器上它的长度为 <code>8</code> ，后者的内部包含了两个<code>int</code>类型的成员，每个长度为 <code>4</code>，但是他们的长度在直观上是一样的！但是真正在使用的时候我们才能察觉到其中的差异，这就是我所说的<strong>最基本成员</strong>的意义所在。虽然我们在使用结构体的时候，能够将其当作一个整体，但是实际上他们与内建(build-in)的类型还是有一些差异的。</p>
</li>
<li>偏移量通俗地说，就是该成员起始地址距离起始位置的长度，在结构体中，C语言是怎么为结构体分配设定大小的呢？除了内存对齐外，还需要考虑定义结构体时，其中成员的声明顺序，换句话说，谁首先声明，谁的位置就靠前。而某个成员的偏移量代表着其<strong>起始位置</strong>减去其所属对象的<strong>起始位置</strong>，(此处需要注意的是，两个毫不相干的指针相减所得到的结果是无意义的，只有当两个指针同在一个作用域内时，减法才是有意义的，为了避免潜在的错误，我们要谨慎使用指针减法操作)。</li>
</ul>
</li>
<li><p>就此回过头去再看看上方的 <strong>loop</strong> 解释，应该能够理解到，那些数字是通过偏移量来进行计算得到的。</p>
</li>
<li><p>之所以没有详细的介绍时间局部性是因为，对于时间局部性而言，其最大的影响因素便是操作区域的大小，比如我们操作的数组或者文件的大小，越小时间局部性越好，试想一下对于一个小的文件和大的文件，我们更容易操作到同一块地方多次的，必定是小的文件。而操作文件的大小有时候并不能很好得成为我们的操作因素，故只能多关注空间局部性。</p>
</li>
</ul>
<h4 id="高速缓存器">高速缓存器</h4><ol>
<li><p>在前方提到了，一般情况下，局部性好的程序能够让程序比局部性差的程序更有效率，而对于局部变量而言，一个好的编译器总是尽可能的将之优化，使其能充分使用<strong>CPU寄存器</strong>,那么寄存器的下方,也就是速度最接近寄存器的,便是所谓的<strong>高速缓存器</strong>了，对于高速缓存器而言，其最大的功效便是缓冲，缓冲有两层意思：</p>
<ul>
<li>缓存数据，使下一次需要的数据尽可能的<strong>“靠近”</strong>CPU，此处的靠近并不是物理意义上的距离靠近。</li>
<li>缓冲一下CPU于存储器巨大的速度差距，防止CPU空闲浪费。</li>
</ul>
</li>
<li><p>对于现在的计算机而言，CPU基本都是三层缓存：<strong>一级缓存(L1)</strong>,<strong>二级缓存(L2)</strong>,<strong>三级缓存(L3)</strong>，可以通过 <strong>CPU-Z(Windows) / Mac OS系统报告</strong> 来查看自己的CPU缓存，在软件中我们能够看到，在一级缓存中会分为两个部分 ：<strong>一级数据</strong>，<strong>一级指令</strong>，这代表着<strong>只读写数据</strong>，<strong>只读写指令</strong>，这样分开的意义在于处理器能够同时处理一个数据和一个指令，上述所说的都是对于一个CPU核而言的，也就是说当CPU是多核的时候，那就有多个这种<strong>“功能集合(L1+L2)”</strong>。二级缓存则与一级缓存同在一个核中，每个核都拥有自己的二级缓存，最后所有核共享唯一一个(L3)</p>
<ul>
<li>总的来说，对于高速缓存器来说，一般分为三层，第一层比较特殊由独立的两个部分组成，第二层第三层则是各自独立一体并未区分功能(既存数据又存指令)，而第一层和第二层则是每个核单独享有不同的缓存器，第三层则是各个核共享一个层，所以我们经常看见在个人计算机上，L3的大小经常是以<strong>MB</strong>为单位的，而第一层则多以KB甚至是Byte为单位。</li>
<li>在实际中，喜欢研究计算机的人经常会在一些专业软件中看见自己的<strong>CPU</strong>配置，在<strong>缓存</strong>一栏的一级和二级中总能看见<code>2 x 32 KBytes</code>之类的参数，<code>32</code>代表的就是某级的缓存大小，而前方的<code>2</code>则是核数，即有几个核便有乘多少，和之前所说的一致，具体可参见下方的<strong>缓存器图示</strong></li>
</ul>
</li>
</ol>
<ol>
<li><p>高速缓存器的各个层依然遵守逐步降速的规律，即读取周期 <strong>L1 &lt; L2 &lt; L3</strong>，而影响较大的便是上文提到的的命中率，我们知道越上层的高速缓存器总是将下层的存储器映射在自己的存储器中，而按照逻辑推断，上层的实际空间比下层的要小，因为上层的空间更加宝贵速度更快，这就导致我们无法将下层的空间一一对应的映射到上层里，那么我们就想到一个办法，并不是将下层存储器的内容完全映射到上层，<strong>而是上层有选择性的将下层的部分内容抽取到上层</strong>，这便是不命中之后的操作。</p>
</li>
<li><p>对于CPU从存储器中读取数据这个操作，如果我们使用了高速缓存以及内存这两个概念，那么就会有一个延伸概念，命中。而对于这个概念只有两种情况，命中或者不命中。而对于一个初始化的高速缓存器，它一定是空的，也许在物理意义上它并不是空，但是实际上在程序看来它的确是空的，为了区分这个，高速缓存器专门使用了一个<strong>位(bit)</strong>来表示此组是否有效(即是否为空)，既然它是空的那么，我们第一次无论如何都无法命中数据，这时候该层的高速缓存器就会向下一层，在该层中寻找所要的数据，每次要向下一层申请寻找的行为一般称为<strong>惩罚</strong>，而当我们从存储器中将所需的数据加载到高速缓存器中的时候，我们便开始了运算，而一切关于高速缓存器效率的改进都集中在命中率的提升。</p>
<ul>
<li><p>假设有一个数组需要操作，由于数组是一个连续的内存空间，对其进行步长为<code>1</code>的操作拥有很好的空间局部性，那么可以当成一个很好的例子，在高速缓存器看来读取一个有<code>n(n&gt;N)</code>个元素的数组<code>vector</code>并不是一次性读完，而是分次读取，如果读取了<code>k</code>次那么至少有<code>k</code>次不命中，这是不可避免的，而对于读取的数据也不一定是我们需要的，用书上的例子来说：<br><code>vector:|[0]|[1]|[2]|[3]|[]|[]|[]|[]|[]|[]|[]|</code><br>假设操作数组的每一个元素，我们一次读取三个内存的值，类型为<code>int</code>，因为原理都一样。那么在初始化时候，高速缓存器为空，在第一次操作的时候，读取了四个(如上所示)，此时一定经过了一次 <strong>不命中</strong> 。</p>
<p>  很好理解，因为缓存器空，所以第一次操作必然不命中，所以我们需要向下级存储器读取我们需要的数据，那么第二访问高速缓存的时候，可以命中<code>vector[0]</code>，依次命中后续两个，直到需要<code>vector[4]</code>，出现了不命中，那么我们就需要重复上一步，再次读取三个数据，依次类推直到结束。<br><code>vector:|[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[]|[]|[]|</code></p>
<p>  现在我们能够从一定层面上解释为什么局部性好的程序比局部性差的程序要有更好的效率了，原因就在对于高速缓存器的利用，<strong>首先反复利用本地临时变量能够充分的调用高速缓存器的功能做到读写的最优化，其次步长为越小也越能尽最大的能力发挥高速缓存器读取的数据</strong>，在这点上再回过头思考多维数组的遍历并进行操作，如果没有考虑空间局部性(即先操作大块，再操作小块)，那么在高速缓存器中，它的不命中率令人发指，这也是操作不当效率低的原因。</p>
</li>
<li><p>另一方面，对于不同步长而言，其影响的也是高速缓存器的命中率，还是上方的<code>vector</code></p>
<pre><code>步长       | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> |
不命中<span class="regexp">/命中 |1/</span><span class="number">4</span>|<span class="number">1</span><span class="regexp">/2|2/</span><span class="number">3</span>|<span class="number">1</span><span class="regexp">/1|1/</span><span class="number">1</span>|
</code></pre><p>可以看出来，对于步长而言，当到了一定的上限以后，每次的请求都会不命中，那么这时候本层的高速缓存器相当于作废，时间全都耗费在下层数据传送到上层的时间，因为每次读取都是不命中，可以利用上方的例子自己试着推理一下。</p>
</li>
</ul>
</li>
<li><p>在参考文献中提到了一种优化程序的技巧，便是充分的利用高速缓存器，并且不受缓存器大小的限制，做法是当所操作的数据过大的情况下，通过构造循环来创建一个有一个大块，这些块能够被高速缓存器容纳，那么我们就能够充分利用高速缓存器来实现功能。 </p>
</li>
</ol>
<blockquote>
<p>缓存器示意图</p>
</blockquote>
<pre><code><span class="code">----------------------------------------------
|  CPU某个核                                  |  ......其他核
| ----------  ----------  ------------------ | 
| |        |  |        |  |                | |  
| |   L1   |  |   L1   |  |   L2高速缓存器  | | 
| | 一级数据|  | 一级指令|   |    二级缓存器   | |
| ----------  ----------  ------------------ |
----------------------------------------------</span>

<span class="code">------------------------------------------------------------------------------------
|                                                                                  |
|                                   L3高速缓存器                                    |
|                                    三级缓存器                                     |
------------------------------------------------------------------------------------</span>
</code></pre><h4 id="参考:[1]深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">[1]深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(4)---效率(上)]]></title>
    <link href="http://www.wushxin.top/2015/05/20/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(4).html"/>
    <id>http://www.wushxin.top/2015/05/20/我为什么学C(4).html</id>
    <published>2015-05-20T03:06:38.000Z</published>
    <updated>2015-06-03T11:50:43.786Z</updated>
    <content type="html"><![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的<a id="more"></a></li>
<li><p>注：随着编译器的版本更新，即使不开启优化选项，自带的编译器优化依旧能够为我们编写的代码提供一部分优化，这便是不使用老版本编译器的原因，虽然作为一个程序员不应该太依赖于编译器，但是我认为，时代在进步，信息量正在无限的膨胀，但是人类的大脑以及精力在一个大时代内是有限的，换句话说对于普通人而言我们的记忆是有限的，我们不应该把精力放在前人已经做完的事情上，而是要站在巨人的肩膀上向更远处眺望，如此我们应该充分利用工具来帮助我们实现一些既有的功能，而程序员应该更 专注于发现新的思路，以及想法，在图灵测试尚未有人打破之前，程序员依赖编译器并不是一件错误的事情。</p>
<p>  对于当下的编译器，以<code>GCC</code>(<strong>GCC不仅仅是一个编译器，但这里将它当成编译器的代名词</strong>)为例，<code>-O2</code>是一个为大众所接受的优化等级，对于其他编译器，一般程序员可以选择使用由Google和Apple联合开发的编译器<code>clang</code>也是一个很好的选择， 在<code>-O2</code>的优化等级下，<code>GCC</code>一般情况下能够自动执行<strong>循环展开</strong>优化，</p>
</li>
</ul>
<h4 id="开始">开始</h4><ol>
<li><p>.</p>
<pre><code><span class="comment">/*struct.h*/</span>   
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> me{
        <span class="keyword">int</span>        value;
        <span class="keyword">struct</span> me* next;
}data_t;

<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index;
        data_t* storage;
}block;    
</code></pre><p>为了测试方便我们首先定义了两个结构体，分别是:</p>
<p> <code>block</code>代表一个块，每个块都有一个序号(<code>int</code>)，一个数据域<code>data_t</code><br><br> <code>data_t</code>代表一个数据域，原型是一个链表，每个<code>data_t</code>对象中包含一个数据和一个指针。</p>
<pre><code>/*main.c*/
<span class="comment">#include "struct.h"</span>
<span class="comment">#define ARR_SIZE 10</span>
<span class="keyword">static</span> inline <span class="type">int</span> get_len(<span class="keyword">const</span> data_t* data)
{
    <span class="type">int</span> len = <span class="number">0</span>;

    <span class="keyword">if</span>(!data)
        fprintf(<span class="literal">stderr</span>,<span class="string">"The data in %p is NULL\n"</span>,data);
    <span class="keyword">else</span>
        <span class="keyword">while</span>(!data-&gt;next)
        {
            ++len;
            data = data-&gt;next;
        }
    <span class="keyword">return</span> len;
}

<span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; get_len(process-&gt;storage);++i)
    {
        *<span class="literal">result</span> += (process-&gt;storage)[i];
    }
}
</code></pre><p>此时我们得到了两个测试函数，<code>get_len</code>和<code>mix_cal</code>分别用来得到<code>data_t</code>长度，以及计算数据域的总和。</p>
<pre><code>/*main.c*/    
<span class="type">int</span> main(<span class="type">void</span>)
{
    <span class="keyword">block</span>* block_in_all[<span class="type">ARR_SIZE</span>]  = { <span class="type">NULL</span> };
    <span class="type">int</span>    result_in_all[<span class="type">ARR_SIZE</span>] = { <span class="number">0</span> };
    /*
    *假设生成了许多的`<span class="keyword">block</span>`类型对象
    *将许多的`<span class="keyword">block</span>`放置在一个数组中，每个元素类型为`<span class="keyword">block</span>*`
    *每个<span class="keyword">block</span>对象中都包含非空的data_t类型的数据域
    */
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        mix_cal(block_in_all[i], result_in_all+i);
    }
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        printf(<span class="string">"The %dth block have the total %d data\n"</span>,
                    block_in_all[i]-&gt;index, result_in_all[i]);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>耐心读完上述的代码，它是用来求和的，求一个域中的所有元素的和。仔细分析一下，很容易就能看见一些缺点，最大的莫过于在<code>mix_cal</code>函数中对于<code>get_len</code>函数的调用，在此处看来十分明显，但是我们在编写程序的时候是否能够注意到这个问题呢？<br><br>对于一些不必要的函数调用我们要做的便是将他们提取出来，使用临时变量是一个很好的办法，因为在编译器的帮助下<strong>临时变量</strong>在<strong>允许的情况下</strong>能够充分的利用CPU的寄存器。之所以是允许的情况下，是因为寄存器的数量并不多，而编译器在寄存器的使用上需要考虑许多的复杂因素，故并不是每次使用临时变量都能加入寄存器。但这并不妨碍我们提升程序的性能。</p>
<p> 在此处，我们应该将<code>for</code>循环中的判断语句里的<code>get_len</code>函数提取出来，在外部使用一个临时变量接收结果，而不是在循环中一直调用该函数。</p>
<pre><code><span class="typename">int</span> <span class="built_in">len</span> = get_len(process-&gt;storage);
</code></pre></li>
<li><p>.</p>
<p> 依旧是上方的代码，我们来讲述一下，循环展开。</p>
<p> 对于<code>mix_cal</code>函数，我们或者说编译器可以如何提升它的速度呢？我们说过一点的小改变都可能对一个程序的最终代码产生极大的影响，对此最常用的便是尝试，前人之路早已铺好，不需要重复造轮子了。</p>
<p> 循环展开:</p>
<pre><code><span class="type">int</span> reality = len - <span class="number">1</span>, i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
{
    *<span class="literal">result</span> = *<span class="literal">result</span> + (process-&gt;storage)[i] 
                      + (process-&gt;storage)[i+<span class="number">1</span>];
}
<span class="keyword">for</span>(;i &lt; len;++i)
{
    *<span class="literal">result</span> +=  (process-&gt;storage)[i];
}
</code></pre><p> 这就是循环展开中的<strong>2次循环展开</strong>，同样还有n次循环展开。</p>
<p> 同样，在刚才提到过寄存器的使用以及减少不必要的开销，在此程序中对于<code>(process-&gt;storage)[i]</code>这样的存储器位置解引用太过浪费，我们总是将其优化成本低临时变量的使用</p>
<pre><code><span class="typedef"><span class="keyword">data</span>* local_data = process-&gt;storage;</span>
</code></pre><p> 这将为程序带来十分可观的节约，虽然这些工作在编译器的优化中都能包括，但是一旦我们的代码难以被编译器所理解(虽然编译器的升级最大的目的就是提升优化效果)，那么我们很可能得到一个性能不够可观的程序。所以当我们并不是特别紧凑的时候，可以将这些工作当成我们的本分来做，而不是交给编译器来做。</p>
<p> 以及对于外部存储位置 <code>result</code> 我们在此处也是存在着浪费，同样我们应该使用一个临时变量来存储总和，而不是每次得到结果便对它进行解引用操作。</p>
<pre><code><span class="type">int</span> local_result = <span class="number">0</span>;
/*...*/
local_result = local_result + local_data[i] + local_data[i+<span class="number">1</span>];
/*...*/
*<span class="literal">result</span> = local_result;
</code></pre><p>在上方我们可以看见<strong>循环展开</strong>被称作<strong>2次循环展开</strong>，那么自然可以推断有<code>n</code>次循环展开，自然是有的，对于一个n次循环展开的式子我们有一个简便的上界确定公式即:</p>
<pre><code><span class="attribute">reality </span>=<span class="string"> len - n + 1;</span>
</code></pre><p>至于展开几次最好，依然是视环境而定。<br>故最终的版本应该为：</p>
<pre><code><span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="type">int</span> local_result = <span class="number">0</span>;
    <span class="type">int</span> len = get_len(process-&gt;storage);
    <span class="type">int</span> reality = len - <span class="number">1</span>, i;
    data* local_data = process-&gt;storage;

    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
        local_result += local_data[i] + local_data[i+<span class="number">1</span>];
    <span class="keyword">for</span>(;i &lt; len;++i)
        local_result += local_data[i];

    *<span class="literal">result</span> = local_result;
}
</code></pre><p>解释：循环展开将元素相加分为两个部分，第一部分每次加两个元素，由于如此做会剩余元素没有加，故在第二部分将剩下的元素都加起来。</p>
</li>
<li><p>.<br>还有一种叫做<strong>重新组合</strong>的技巧，即为让一个表达式中的运算数自由组合，组合出最快速的一种，但是这种方法未曾试验过。故不提及。</p>
</li>
<li><p>.<br>对于条件分支预测错误造成的时间损耗，称之为<strong>惩罚</strong>，最通俗的说法，就是当你编写的代码中含有条件分支的时候，处理器会选择去<strong>预判</strong>某一个分支是此次正确的支路，这样可以避免修改任何实际的寄存器和存储器，一直到确定了实际结果，要是不对，那就惨了，这段时间做的事情都白费了。但是也不必过分的关心这种条件分支的预测，这也是我放在最后说的意义所在。</p>
<p> 这里有两种较为客观的方法，一种被称为<strong>命令式</strong>，一种被称为<strong>功能式</strong></p>
<p> 命令式：</p>
<pre><code><span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{
    if(a[i] &gt; b[i]){
        int temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }</span>
}
</code></pre><p> 功能式：</p>
<pre><code>int min, max;
<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{    
    min = a[i] &lt; b[i] ? a[i] : b[i];
    max = a[i] &lt; b[i] ? b[i] : a[i];
    a[i] = min;
    b[i] = max;
}</span>
</code></pre><p>很清晰的一个例子，明显看出来，前者对于不同情况所作的程序步数明显不同，而后者无论什么情况都是相同的程序步。</p>
<p> 两个形式的好处前者对于可预测数据来说，是一个很好的模型，后者则是中庸之道，什么是可预测不可预测，比如一个数是负数还是正数这就是不可预测的，用前面那个代码会有很大的<strong>惩罚</strong>。</p>
</li>
<li><p>.<br>多路并行的技巧也是一个很重要的思路，可能在很多人眼中看来，两条语句依次写出和合并的效果一定是一样。但是多路并行有一个缺点就是对寄存器的数量有所要求，当寄存器不够时(称为溢出)，性能不升反降。同样是对于循环展开，此次使用<strong>四次循环展开</strong>加<strong>二路并行</strong>：</p>
<pre><code><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">4</span>){
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i] + <span class="built_in">local</span>_data[i+<span class="number">1</span>];
    <span class="built_in">local</span>_result_2 += <span class="built_in">local</span>_data[i+<span class="number">2</span>] + <span class="built_in">local</span>_data[i+<span class="number">3</span>];
}//也可以分成四路并行，每一路存一个。这种做法充分利用了CPU流水线的性能
<span class="keyword">for</span>(;i &lt; len;++i)
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i];

*result = <span class="built_in">local</span>_result_1 + <span class="built_in">local</span>_result_2;
</code></pre></li>
</ol>
<h4 id="结束">结束</h4><h4 id="Tips:">Tips:</h4><p>上文中写到的函数大都带有<code>static inline</code>关键字，这是何意？首先我们要确定一件事情，对于非工程的单文件而言，<code>static</code>函数并没有什么意义(意义指的是对于可见性而言，并非说它一无是处)，许多人对于<code>static</code>函数感到茫然的原因在于:我明明将一个函数声明定义成<code>static</code>类型了，但是我还是可以在别的文件中访问到啊！</p>
<p>其实这是因为你根本就没有理解<strong>C语言</strong>工程这个意思，大部分人是这么测试的:</p>
<ol>
<li><p>首先在一个文件夹里创建两个文件 <code>test_static.c</code>和<code>static.h</code>:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> "static.h"</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//编译通过，可以运行。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
<li><p>然后编译运行，发现可以通过啊！！标准怎么说在其他文件中不可见？而把<code>static.h</code>去掉<code>#include</code>之后发现报错<code>test undefined</code>，瞬间初学者就凌乱了。</p>
</li>
<li><p>好吧，实际上是前辈们以及教材的错，因为从始至终，所有外界现象都告诉我们<strong>C程序</strong>是独立的一个一个文件组成的，但是并没有告诉我们要先将他们弄成一个工程！此处如果是使用<strong>Visual Studio</strong>学习C语言的可能会对工程这个概念理解的稍微好一些，虽然极度反对排斥使用 VS 学习C语言这种行为。</p>
</li>
<li><p>你想要实现<code>static</code>函数仅在本文件可见的效果，请你先补习一下<strong>工程</strong>这个概念，对于任何可见或者不可见的概念而言都是建立在一个工程内而言，而不是像上方的代码，使用<code>#include</code>来表示，你都<code>#include</code>了，那还有什么可见不可见的当然都可见了。所以一个<code>static</code>函数可见于不可见是基于一个个工程里的所有C语言源文件而言的。所以你将常看见前辈们这么回答你的提问:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//报错，因为test是static函数。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>发现了吗？在上方代码中，少了一行<code>#include &quot;static.h&quot;</code>但是这个代码依旧可行，因为这两个文件是建立在同一个工程里的，而不是在一个文件夹中随意新建两个源文件这么简单，你可以使用各个<strong>IDE</strong>的工程功能来进行测试。</p>
</li>
</ol>
<p>回到正题，在这里稍微提一下<strong>static</strong>对函数的某些作用，它可以让函数放在一个静态的空间中，而不是栈里，这是的它的调用更加快速，经常与<strong>inline</strong>关键字一起使用，为的就是让函数更加快。但是有利有弊，可以自己权衡一下。</p>
<h4 id="参考:深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的]]>
    
    </summary>
    
      <category term="C" scheme="http://www.wushxin.top/tags/C/"/>
    
  </entry>
  
</feed>