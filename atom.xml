<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[WuShXin's fox]]></title>
  <subtitle><![CDATA[喜欢编程带来的快乐]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="//wushxin.top//"/>
  <updated>2015-06-21T05:00:24.397Z</updated>
  <id>//wushxin.top//</id>
  
  <author>
    <name><![CDATA[WuShengXin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Cpp记录]]></title>
    <link href="//wushxin.top/2015/06/21/Cpp%E8%AE%B0%E5%BD%95/"/>
    <id>//wushxin.top/2015/06/21/Cpp记录/</id>
    <published>2015-06-21T03:38:55.000Z</published>
    <updated>2015-06-21T05:00:24.397Z</updated>
    <content type="html"><![CDATA[<h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span>{
    <span class="keyword">int</span> challenge = <span class="number">0</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>
    </span>{
        ...
}
</code></pre></li>
<li><p>名称空间的创建</p>
</li>
</ul>
<p>一般来说，声明实现是要分离的，而对于一个名称空间来说，不能再某个名称空间中声明了，却在另一个名称空间里定义，所以我们一般在头文件中声明它，并在实现文件中定义它们<br>        // file1.h<br>        namespace mix_define{</p>
<pre><code>        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        ...
}


<span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }

        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }
}
</code></pre><ul>
<li><p>使用名称空间的时候，最好避免全部倒入，容易造成名称污染。</p>
<pre><code><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//不建议这么做</span>

<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;
<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="comment">//最好如此或者，更好的做法是:</span>

<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In the Real Code"</span> &lt;&lt; <span class="built_in">std</span>::endl;
</code></pre></li>
</ul>
<ul>
<li>类设计中特殊的函数</li>
</ul>
<p>一个类，当它拥有这样的构造函数时：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Wushxin</span></span>{

<span class="keyword">public</span>:
        Wushxin() {}
        Wushxin(<span class="keyword">double</span> heigth);
...
<span class="keyword">private</span>:
        <span class="keyword">double</span> my_heth;
...
};
</code></pre><p>我们可以这么使用它：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Wushxin FirstCopy;
    FirstCopy = <span class="number">178.6</span>; <span class="comment">//这样的赋值是成立的</span>
                       <span class="comment">//首先调用Wushxin(double heigth)，将176.8传入，</span>
                       <span class="comment">//将生成一个临时的Wushxin类型的对象，再拷贝进FirstCopy对象中。</span>
    <span class="keyword">double</span> heigth = FirstCopy; <span class="comment">// 可行吗？，答案是不可行</span>
</code></pre><p>但是，如果要让他成立，自然也有方法：</p>
<p>很少使用的特殊函数：</p>
<pre><code><span class="keyword">class</span> <span class="title">Wushxin</span>{
...
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>{
            <span class="keyword">return</span> my_heth;
    }
...
}; 
</code></pre><p>如此定义一个特殊的转换函数之后，我们就能无错的编译通过并运行上述代码了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace<]]>
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Qt记录]]></title>
    <link href="//wushxin.top/2015/06/12/Qt%E8%AE%B0%E5%BD%95/"/>
    <id>//wushxin.top/2015/06/12/Qt记录/</id>
    <published>2015-06-12T00:42:47.000Z</published>
    <updated>2015-06-13T03:51:56.420Z</updated>
    <content type="html"><![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4><a id="more"></a>
<p>作为信号(signal)与槽(slot)，我们的信号函数的<strong>参数个数</strong>可以多于槽函数的参数个数，也就是说，我们可以选择接受不多于信号函数<strong>参数个数</strong>的参数，有点绕：</p>
<ul>
<li><p>信号函数的类：</p>
<pre><code><span class="keyword">class</span> Signal_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span>:
...
    <span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
    </span>{
        <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName, UserAge)</span></span>;
        <span class="comment">//UserName, UserAge 是该类的私有属性。</span>
    }
signals:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name, <span class="keyword">int</span> age)</span></span>;
<span class="comment">// ...</span>
</code></pre></li>
</ul>
<pre><code>-<span class="ruby"> 对于这段代码而言，有两个地方需要注意，<span class="string">`emit`</span>, <span class="string">`public signals:`</span>
</span>
    -<span class="ruby"> 此处故意令信号函数重载，是为了在后方体现，槽函数的参数个数可以小于或者等于信号函数的参数个数。
</span>    -<span class="ruby"> <span class="string">`emit`</span> 就是发射信号的意思。</span>
</code></pre><ul>
<li><p>槽函数的类：</p>
<pre><code><span class="keyword">class</span> Slot_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span> slots:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSlot</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span>
    </span>{
         QMessageBox mesbox;
         mesbox.setText(<span class="string">"Receive : "</span>+name);
         mesbox.exec();
    }
<span class="comment">// ...</span>
</code></pre></li>
<li><p>测试：</p>
<pre><code><span class="keyword">void</span> (Signal_Class::* p_to_test)(<span class="keyword">const</span> QString &amp;, <span class="keyword">int</span>) = 
     &amp;Signal_Class::Q_TestSignal;
    <span class="comment">//因为是重载函数，所以需要明确指明使用哪个作为连接的信号函数 </span>
QObject::connect(&amp;test_sig, p_to_test,
                 &amp;test_slot, Slot_Class::Q_TestSlot);
test_sig.Q_SendSignal(); <span class="comment">//发射信号</span>
</code></pre><blockquote>
<p>效果图</p>
</blockquote>
</li>
<li><p><img src="http://ww1.sinaimg.cn/mw690/81b736ebtw1et2ajoj7ydj20bk09f3ye.jpg" alt=""></p>
</li>
</ul>
<p>我们会发现，即使槽函数的参数个数与信号函数不一致（小于），但是依然可以接收到参数，但是需要注意的是，虽然能够自由选择接受的参数，但是依旧需要按照顺序(按照C++语法上的顺序)。</p>
<p>既然槽函数能够接受不多于信号函数参数个数的参数，那么我们自然而然能够想到，是否可以使用让槽函数拥有默认参数，以此来扩大槽函数的适用范围，答案是可以。</p>
<ul>
<li><p>依旧是上方的代码，改动些许：</p>
<ul>
<li><p>信号函数的类改动</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
</span>{
    <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName)</span></span>;
    <span class="comment">//UserName 是该类的私有属性。</span>
}
</code></pre></li>
<li><p>信号函数类改动</p>
<pre><code><span class="keyword">void</span> Q_TestSlot(<span class="keyword">const</span> QString &amp; name
              , <span class="keyword">const</span> QDate &amp; time = QDate::currentDate())
{
    <span class="comment">//需要添加#include &lt;QDebug&gt;</span>
    <span class="comment">//如果接受成功，可在终端看到输出。</span>
    qDebug() &lt;&lt; name &lt;&lt; time;
}
</code></pre></li>
<li>测试代码改动（关键点）</li>
<li><p>在此刻我们需要让编译器知道，我们的信号函数是一个参数，而槽函数是两个参数，其中一个是带有默认参数的，我们应该怎么做？函数指针对于默认参数是无效的，那么除了使用C++11新特性<strong>Lambda匿名函数</strong>以外，最直接的还是使用宏<strong>SLOT 和 SIGNAL</strong>，在这里我们使用这两个宏可以节省很多工作量，缺点就是无法在编译时刻知道是否匹配，所以我们需要小心谨慎的使用。</p>
<pre><code><span class="rule"><span class="attribute">QObject</span>:<span class="value">:<span class="function">connect</span>(&amp;new_paper_1, <span class="function">SIGNAL</span>(<span class="function">newPaper</span>(QString)),
                &amp;new_reader_1, <span class="function">SLOT</span>(<span class="function">receive_newpaper</span>(QString)))</span></span>;
</code></pre><p>可以看到，我们的槽函数明明有两个参数，但是此处<strong>SLOT</strong>宏内只出现了一个，这就表明已经告知编译器是默认参数。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4>]]>
    
    </summary>
    
      <category term="Qt" scheme="//wushxin.top/tags/Qt/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Opencv3.0.0配置]]></title>
    <link href="//wushxin.top/2015/06/08/Opencv3%E9%85%8D%E7%BD%AE/"/>
    <id>//wushxin.top/2015/06/08/Opencv3配置/</id>
    <published>2015-06-08T08:26:15.000Z</published>
    <updated>2015-06-10T08:21:31.798Z</updated>
    <content type="html"><![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/" target="_blank" rel="external">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="external">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html" target="_blank" rel="external">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/" target="_blank" rel="external">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4><a id="more"></a>
<p>有了上述两个工具之后，我们就可以着手配置自己的开发环境了，但是先要声明的是，每一个不同的工程项目就需要重新配置一次。</p>
<ol>
<li><p>工程项目是什么？就是 <strong>文件 -&gt; 新建 -&gt; 项目</strong>，在这里我们点击了项目之后出现一个窗口：<br><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwljr6jj211y0lc418.jpg" alt=""></p>
<p> 图片可能不太清晰，但是大概是这么一个回事，修改一下名称，以及存储位置(为了方便)之后，点击 <strong>确定</strong> 之后 Visual Studio 自动帮你生成一个工程项目，这时候先停下，回到桌面。</p>
<ul>
<li>打开目录： <strong>C:\opencv\build\x64\vc12\bin</strong>，查看里面是否有文件，并将目录添加到系统环境变量(<strong>PATH</strong>)当中，如何添加？<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwivdbyj20mz0cbdgq.jpg" alt=""> </li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwh92pcj20dp0gtq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgi9m8j20cp0fkdg7.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkxxz0j20bh05adfs.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>添加完环境变量以后，我们可以开始下一步的配置，根据第一步所创建的项目，我们打开它的属性管理器，当然很可能的就是你创建完成以后，自动就在这个界面，初始情况下，我们创建的是Win32(x86)的工程，这个时候我们需要做的就是，因地制宜。先前说了我是X86_64，也就是64位操作系统，那么我们就应该让整个环境适配他，<strong>(至于32位网上的教程很多)</strong></p>
<ul>
<li><p><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkirl7j20880hh749.jpg" alt=""></p>
<p>接下来，右键你的工程，选择 <strong>属性</strong>，可以很清楚的看见，右上角显示的是<strong>Win32</strong>，我们的目的是将其改为适配64位的开发环境：</p>
</li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwjcj8kj20lc0ea3zk.jpg" alt=""></li>
<li>如图所示，点击配置管理器，选择X64，并在外面将目标计算机改成x64<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwehzjxj20jw0e0aa7.jpg" alt=""></li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwf0k50j20jw0e0jrp.jpg" alt=""></li>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwfiqf9j20lc0fc3zn.jpg" alt=""> </li>
</ul>
</li>
<li>架构问题解决。接下去才是真正的配置步骤。</li>
<li>在属性管理器中，打开你的工程看见四个包含文件夹，删除Win32的两个，留下x64，右键 <strong>Debug|x64</strong> 文件夹，选择 <strong>添加新项目属性表(P)…</strong>，保存为 <strong>opencv_debug</strong> 以后，会发现多了一个属性表文件，如法炮制<strong>Release|x64</strong>文件夹，接下来的操作直到第五步，其它的两个属性表都一样</li>
<li><strong>(opencv_release)</strong></li>
</ul>
</li>
<li><p>首先是打开任意一个属性表文件(双击它= =)，在 <strong>配置属性 -&gt; VC++目录 -&gt; 包含目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>include 目录</strong>，按照我的路径格式，需要添加三个路径分别是：</p>
<blockquote>
<p>C:\opencv\build\include</p>
<p>C:\opencv\build\include\opencv</p>
<p>C:\opencv\build\include\opencv2</p>
</blockquote>
<ul>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwg1wm4j20lc0f4ab0.jpg" alt=""></li>
</ul>
</li>
<li><p>其次是，在 <strong>配置属性 -&gt; VC++目录 -&gt; 库目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>lib</strong> 目录，按照我的路径格式，需要添加路径是：</p>
<blockquote>
<p>C:opencv\build\x64\vc12\lib</p>
</blockquote>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwhuj95j20lc0gaab2.jpg" alt=""><br>这个便是存放依赖文件的地方，后续会用到。</li>
</ul>
</li>
<li><p>最后是，在 <strong>配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; &lt;编辑…&gt;</strong> 之中添加依赖，对于 <strong>Opencv-3.0.0</strong> 来说，我们只需要添加两个依赖就足够了，此处分为两部分：</p>
<ul>
<li><p>对于<strong>Debug|x64</strong>，也就是当下我们正在配置的这个属性表，添加两个文件:</p>
<blockquote>
<p>opencv_ts300d.lib</p>
<p>opencv_world300d.lib</p>
</blockquote>
<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwib94kj20sb0e1dh5.jpg" alt=""></li>
</ul>
</li>
<li><p>对于 <strong>Release|x64</strong>的属性表来说，需要添加剩下的两个文件：</p>
<blockquote>
<p>opencv_ts300.lib</p>
<p>opencv_world300.lib  </p>
</blockquote>
</li>
</ul>
</li>
<li>Ps: 对于其他版本的Opencv的依赖库添加，可以自行打开 <strong>lib</strong> 文件夹进行查看，不一定需要网上的教程。</li>
<li>如果不想每次创建工程的时候都这么麻烦，那么我们只需要把两个属性表拷贝出来就行了，下次直接导入即可。 </li>
<li>当两个属性表都配置完成之后，我们就大功告成啦，接下来进入最后一步，测试</li>
</ol>
<h4 id="测试">测试</h4><p>在 <strong>属性管理器</strong> 的旁边有一个 <strong>解决方案资源管理器</strong> ，点击之后，会发现这才是以后工作的场景</p>
<ol>
<li>在 <strong>源文件</strong> 文件夹中，添加C++源文件，在其中输入测试代码：<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgxfdfj20j009o74r.jpg" alt=""></li>
</ul>
</li>
</ol>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt; </span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\core\core.hpp&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\highgui\highgui.hpp&gt;  </span>

<span class="keyword">using</span> <span class="keyword">namespace</span> cv;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Mat img = imread(<span class="string">"temp.jpg"</span>);    

    <span class="keyword">if</span> (img.empty())
    {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>;
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    imshow(<span class="string">"mypic"</span>, img);
    waitKey();

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>保存。</p>
<ol>
<li>在 <strong>资源文件</strong> 文件夹中，添加图片<strong>temp.jpg</strong>，随便找一张格式是jpg的图，放进去就行，放进去的方式是 <strong>右键资源文件 -&gt; 添加 -&gt; 现有项(G)…</strong>，找到你的图片，双击，添加完成。</li>
</ol>
<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwnccirj20iy076wer.jpg" alt=""></li>
</ul>
<ol>
<li><p>点击 <strong>生成 -&gt; 生成解决方案</strong> ，之后点击 <strong>启动调试</strong> 也就是运行的意思。</p>
</li>
<li><p>很大的几率发现并不能正常的运行，错误提示无法打开PDB文件，查了一下，似乎尿性很高，于是乎有一个解决办法，不是无法打开吗？那就从微软的服务器在线下载过来，这个方法对每个工程都需要进行一次，但是第一次过后就不需要第二次了。请在联网情况下，完成下列操作，具体方法： </p>
<ul>
<li>依次点击 <strong>调试 -&gt; 选项与设置(G)…</strong> <ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwd6uz9j20ag0e9jry.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 常规</strong> ，勾选 <strong>启动源服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwdmf0nj20l20dqjsk.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 符号</strong> ，勾选 <strong>Microsoft服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwe3srkj20l20dqt9j.jpg" alt=""> </li>
</ul>
</li>
<li>中间如果有警告，一律选择是。</li>
</ul>
</li>
</ol>
<h4 id="2_配置_Code::Blocks_13-12">2 配置 Code::Blocks 13.12</h4><ul>
<li><p>首先打开安装好的 <strong>CMake-gui</strong>，在<strong>source code</strong>一栏加入源文件的路径，也就是下载的<strong>opencv</strong>里的<strong>source</strong>，在<strong>build binaries</strong>一栏加入输出的路径。</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9ay0n5j20n20jdq30.jpg" alt=""></li>
</ul>
</li>
<li><p>点击<strong>Tools -&gt; Configure</strong>，如图配置：</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9bdr6hj20n20jdglz.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后出现红色的选项，将<strong>WITH_IPP</strong>选项去掉，之后点击<strong>Options -&gt; Sipress dev Warnings</strong>，后点击<strong>Generate</strong>生成makefile文件：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9bvra5j20n20jd0td.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后，打开目录<strong>C:\opencv\mybuild</strong>，双击打开工程文件<strong>OpenCV.cbp</strong>开始编译，并附上编译后的文件夹图：<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1esxo9cnz6sj20h70eq0u6.jpg" alt=""></li>
</ul>
</li>
<li>编译结束后，如果一切正常，将上图中的<strong>bin</strong>加入路径</li>
<li>打开<strong>Code::Blocks</strong>，新建一个Console Application工程，右键工程名字，选择<strong>Build Option</strong>出现一个新窗口，在其中我们要开始配置<strong>Opencv</strong>：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo99ko98j20kw0fmq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo99xg7wj20kw0fmjrp.jpg" alt=""></li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9ajo5qj20rw0gataz.jpg" alt=""></li>
</ul>
</li>
<li>添加测试文件（和VS的一样）。</li>
</ul>
<h4 id="结束">结束</h4><p>就是这样如果还有什么错误的话，不妨去Google看看，比如dll不存在的问题，那一定是你没有把要使用的bin目录加入到系统环境当中</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4>]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="Opencv" scheme="//wushxin.top/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(5)---效率(下)]]></title>
    <link href="//wushxin.top/2015/05/29/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C-5/"/>
    <id>//wushxin.top/2015/05/29/我为什么学C-5/</id>
    <published>2015-05-29T13:19:50.000Z</published>
    <updated>2015-06-06T14:46:48.104Z</updated>
    <content type="html"><![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。<a id="more"></a>    
<ul>
<li>打个不太贴切的比喻，假设计算机是一个家，CPU是一个人，想象一下这个家中的所有物品都是井然有序的，这个人想要工作必然会需要工作物品，所以他需要从某些地方拿来，用完以后再放回去，这些地方就是存储器，但是过了一段时间发现这么做太浪费时间，有时候某些东西太远了，所以，人想把它把它放在离自己更进的地方，这样自己的效率就高很多，如果这个东西一段时间内不再用，则把它放回原处，留出位置给更需要的工作物品，于是形成了越常使用的物品离人越近的现象。这便是计算机存储器的分层结构的意义。</li>
<li>而对于一个有良好局部性的程序而言，我们总能在离自己最近的地方找到我们所需要的数据，回到计算机：我们知道计算机的存储器是分层结构的，即每一层对应着不同的读写速度等级(CPU寄存器 &gt; 高速缓存 &gt; 主存 &gt; 硬盘)，而我们的程序总是按照从左至右的顺序依次查找，每次找到一个所需要数据，不出意外，总是将其移动到上一层次的存储器中存储，以便下次更高速的访问，我们称这种行为叫做 <strong>命中</strong> 。越好的程序，越能将当时所需的数据放在越靠近左边的地方。这便是局部性的意义所在。</li>
<li>当然，存储器如此分层也是出于无奈，在处理器的速度和存储器的速度实在差距的情况下只有如此做才能让处理器更加充分的利用，而不至于等待存储器读写而空闲，也许某一天，当内存的<strong>位价</strong>和普通硬盘不相上下或者差距不多的时候，也许内存就是硬盘了。而当今也有人使用某些特殊的软件在实现这个功能，凭着自己计算机上大容量的内存，分割出来当作硬盘使用，存取速度让硬盘望尘莫及。</li>
</ul>
</li>
</ul>
<h4 id="局部性">局部性</h4><p>前方提到了局部性，局部性体现在了，当步长越大，空间局部性越低，大多数情况下会造成性能降低，比如最常见的多维数组循环(我鲜少使用多维数组的原因之一便在于此)，前面说过多维数组实际上只是数个一维数组的包装而已，C语言中并没有真正的多维数组，而是将其解读成内存中的一维的连续内存，但是当我们遍历它的时候，C语言为了不让我们被底层实现所困扰，所以生成了多维数组遍历的假象：</p>
<p>让我们重温一遍”多维数组”：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;    </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> dim_1_arr[<span class="number">4</span>]    = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
    <span class="keyword">int</span> dim_2_arr[<span class="number">2</span>][<span class="number">2</span>] = { {<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>} };
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)
        result_1 += dim_1_arr[i];
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>此例中，对一维数组进行步长为 <code>1</code> 遍历求和，假设内存中数组的起始位置是 <code>0</code></p>
<p><code>0 =&gt; 4 =&gt; 8 =&gt; 12</code></p>
<pre><code><span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; <span class="number">3</span>;++j)<span class="comment">{
    for(int i = 0;i &lt; 3;++i){
        result_2 += dim_2_arr[i][j];
    }</span>
}
</code></pre><p>此例中，我们的步长是多少呢？我们来看一下</p>
<p><code>0 =&gt; 8 =&gt; 4 =&gt; 12</code></p>
<p>可以很清晰的看出两段不同代码之间的跳跃，为什么？观察到多维数组的遍历中我们和平时的做法有些不同，是先对<code>i</code>进行遍历，再对<code>j</code>进行遍历，这就导致了程序必须在内存块中<strong>无规律</strong>的跳动，这里的无规律是计算机认为的无规律，虽然在我们看来的确是有迹可寻，优秀的编译器能够对它进行优化处理。就事论事，即这段程序的空间局部性比较差，对于一个在内存中大幅度跳跃，无规律跳跃的程序都将影响程序的性能。这个判定对于一个连续的内存块来说是很重要的，比如C语言中的结构体。</p>
<p>实际上C语言也是能够面向对象的，但是十分复杂，就像拿着棒子织衣服一样。而C语言的机构体能够让我们在一定程度上初步理解对象这个概念，因为它是一个完整的个体，虽然对外界<strong>毫不设防</strong>。</p>
<blockquote>
<p><strong>对于结构体</strong></p>
</blockquote>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> VECTOR 4</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">double</span> salary;
        <span class="keyword">int</span>    index[<span class="number">4</span>];
}test_data;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;
    test_data dim_1_arr[VECTOR];
    <span class="comment">/* ...填充数据 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
    {    
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
            result_1 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 1 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
            result_2 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 2 */</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre><p>还是和上方一样，假设 <code>dim_1_arr</code> 起始位置为 <code>0</code></p>
<p> <strong>for loop 1</strong>：</p>
<p><code>8 =&gt; 12 =&gt; 16 =&gt; 20 ==&gt; 32 =&gt; 36 =&gt; 40 =&gt; 44 ==&gt; ...</code></p>
<p><strong>for loop 2</strong>：</p>
<p><code>8 =&gt; 32 =&gt; 56 =&gt; 80 ==&gt; 12 =&gt; 36 =&gt; 60 =&gt; 84 ==&gt; ...</code></p>
<p>从上方不完整的比较来看，<strong>loop 1</strong> 相对于 <strong>loop 2</strong> 来说有更好的空间局部性，很明显在 <strong>loop 2</strong> 中，CPU读取是在无规律的内存位置跳跃，而 <strong>loop 1</strong> 则是以单调递增的趋势向前(这里的向前指的是直观上的向前)读取内存。</p>
<ul>
<li>在此处回顾一下C语言的结构体性质与知识：<ul>
<li>对于任意一个完整定义的结构体，每一个对象所占有的内存大小都符合<strong>内存对齐</strong>的规则。</li>
<li>对于结构体内的各个成员而言，其相对于对象存储地址起始的距离，称为<strong>偏移量</strong>。</li>
</ul>
</li>
<li><p>解释：</p>
<ul>
<li><p>内存对齐便是对于一个结构体而言，其所占内存大小总是最大成员的整数倍，其中最大成员指的是最基本成员，即：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
    test_data test_1;
    <span class="keyword">int</span>       test_2;
}test_data_2;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_2 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_2));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 32</code></p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index[<span class="number">4</span>];
        <span class="keyword">int</span> store_1;
        <span class="keyword">int</span> store_2;
}test_data_3;
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        test_data_3 test_3;
        <span class="keyword">int</span>         test_4;
}test_data_4;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_4 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_4));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 28</code></p>
<p>  仔细对比<code>test_data_3</code>与<code>test_data</code>的差异，可以发现不同处，在前者的内部包含了一个<code>double</code>类型的成员，在我的机器上它的长度为 <code>8</code> ，后者的内部包含了两个<code>int</code>类型的成员，每个长度为 <code>4</code>，但是他们的长度在直观上是一样的！但是真正在使用的时候我们才能察觉到其中的差异，这就是我所说的<strong>最基本成员</strong>的意义所在。虽然我们在使用结构体的时候，能够将其当作一个整体，但是实际上他们与内建(build-in)的类型还是有一些差异的。</p>
</li>
<li>偏移量通俗地说，就是该成员起始地址距离起始位置的长度，在结构体中，C语言是怎么为结构体分配设定大小的呢？除了内存对齐外，还需要考虑定义结构体时，其中成员的声明顺序，换句话说，谁首先声明，谁的位置就靠前。而某个成员的偏移量代表着其<strong>起始位置</strong>减去其所属对象的<strong>起始位置</strong>，(此处需要注意的是，两个毫不相干的指针相减所得到的结果是无意义的，只有当两个指针同在一个作用域内时，减法才是有意义的，为了避免潜在的错误，我们要谨慎使用指针减法操作)。</li>
</ul>
</li>
<li><p>就此回过头去再看看上方的 <strong>loop</strong> 解释，应该能够理解到，那些数字是通过偏移量来进行计算得到的。</p>
</li>
<li><p>之所以没有详细的介绍时间局部性是因为，对于时间局部性而言，其最大的影响因素便是操作区域的大小，比如我们操作的数组或者文件的大小，越小时间局部性越好，试想一下对于一个小的文件和大的文件，我们更容易操作到同一块地方多次的，必定是小的文件。而操作文件的大小有时候并不能很好得成为我们的操作因素，故只能多关注空间局部性。</p>
</li>
</ul>
<h4 id="高速缓存器">高速缓存器</h4><ol>
<li><p>在前方提到了，一般情况下，局部性好的程序能够让程序比局部性差的程序更有效率，而对于局部变量而言，一个好的编译器总是尽可能的将之优化，使其能充分使用<strong>CPU寄存器</strong>,那么寄存器的下方,也就是速度最接近寄存器的,便是所谓的<strong>高速缓存器</strong>了，对于高速缓存器而言，其最大的功效便是缓冲，缓冲有两层意思：</p>
<ul>
<li>缓存数据，使下一次需要的数据尽可能的<strong>“靠近”</strong>CPU，此处的靠近并不是物理意义上的距离靠近。</li>
<li>缓冲一下CPU于存储器巨大的速度差距，防止CPU空闲浪费。</li>
</ul>
</li>
<li><p>对于现在的计算机而言，CPU基本都是三层缓存：<strong>一级缓存(L1)</strong>,<strong>二级缓存(L2)</strong>,<strong>三级缓存(L3)</strong>，可以通过 <strong>CPU-Z(Windows) / Mac OS系统报告</strong> 来查看自己的CPU缓存，在软件中我们能够看到，在一级缓存中会分为两个部分 ：<strong>一级数据</strong>，<strong>一级指令</strong>，这代表着<strong>只读写数据</strong>，<strong>只读写指令</strong>，这样分开的意义在于处理器能够同时处理一个数据和一个指令，上述所说的都是对于一个CPU核而言的，也就是说当CPU是多核的时候，那就有多个这种<strong>“功能集合(L1+L2)”</strong>。二级缓存则与一级缓存同在一个核中，每个核都拥有自己的二级缓存，最后所有核共享唯一一个(L3)</p>
<ul>
<li>总的来说，对于高速缓存器来说，一般分为三层，第一层比较特殊由独立的两个部分组成，第二层第三层则是各自独立一体并未区分功能(既存数据又存指令)，而第一层和第二层则是每个核单独享有不同的缓存器，第三层则是各个核共享一个层，所以我们经常看见在个人计算机上，L3的大小经常是以<strong>MB</strong>为单位的，而第一层则多以KB甚至是Byte为单位。</li>
<li>在实际中，喜欢研究计算机的人经常会在一些专业软件中看见自己的<strong>CPU</strong>配置，在<strong>缓存</strong>一栏的一级和二级中总能看见<code>2 x 32 KBytes</code>之类的参数，<code>32</code>代表的就是某级的缓存大小，而前方的<code>2</code>则是核数，即有几个核便有乘多少，和之前所说的一致，具体可参见下方的<strong>缓存器图示</strong></li>
</ul>
</li>
</ol>
<ol>
<li><p>高速缓存器的各个层依然遵守逐步降速的规律，即读取周期 <strong>L1 &lt; L2 &lt; L3</strong>，而影响较大的便是上文提到的的命中率，我们知道越上层的高速缓存器总是将下层的存储器映射在自己的存储器中，而按照逻辑推断，上层的实际空间比下层的要小，因为上层的空间更加宝贵速度更快，这就导致我们无法将下层的空间一一对应的映射到上层里，那么我们就想到一个办法，并不是将下层存储器的内容完全映射到上层，<strong>而是上层有选择性的将下层的部分内容抽取到上层</strong>，这便是不命中之后的操作。</p>
</li>
<li><p>对于CPU从存储器中读取数据这个操作，如果我们使用了高速缓存以及内存这两个概念，那么就会有一个延伸概念，命中。而对于这个概念只有两种情况，命中或者不命中。而对于一个初始化的高速缓存器，它一定是空的，也许在物理意义上它并不是空，但是实际上在程序看来它的确是空的，为了区分这个，高速缓存器专门使用了一个<strong>位(bit)</strong>来表示此组是否有效(即是否为空)，既然它是空的那么，我们第一次无论如何都无法命中数据，这时候该层的高速缓存器就会向下一层，在该层中寻找所要的数据，每次要向下一层申请寻找的行为一般称为<strong>惩罚</strong>，而当我们从存储器中将所需的数据加载到高速缓存器中的时候，我们便开始了运算，而一切关于高速缓存器效率的改进都集中在命中率的提升。</p>
<ul>
<li><p>假设有一个数组需要操作，由于数组是一个连续的内存空间，对其进行步长为<code>1</code>的操作拥有很好的空间局部性，那么可以当成一个很好的例子，在高速缓存器看来读取一个有<code>n(n&gt;N)</code>个元素的数组<code>vector</code>并不是一次性读完，而是分次读取，如果读取了<code>k</code>次那么至少有<code>k</code>次不命中，这是不可避免的，而对于读取的数据也不一定是我们需要的，用书上的例子来说：<br><code>vector:|[0]|[1]|[2]|[3]|[]|[]|[]|[]|[]|[]|[]|</code><br>假设操作数组的每一个元素，我们一次读取三个内存的值，类型为<code>int</code>，因为原理都一样。那么在初始化时候，高速缓存器为空，在第一次操作的时候，读取了四个(如上所示)，此时一定经过了一次 <strong>不命中</strong> 。</p>
<p>  很好理解，因为缓存器空，所以第一次操作必然不命中，所以我们需要向下级存储器读取我们需要的数据，那么第二访问高速缓存的时候，可以命中<code>vector[0]</code>，依次命中后续两个，直到需要<code>vector[4]</code>，出现了不命中，那么我们就需要重复上一步，再次读取三个数据，依次类推直到结束。<br><code>vector:|[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[]|[]|[]|</code></p>
<p>  现在我们能够从一定层面上解释为什么局部性好的程序比局部性差的程序要有更好的效率了，原因就在对于高速缓存器的利用，<strong>首先反复利用本地临时变量能够充分的调用高速缓存器的功能做到读写的最优化，其次步长为越小也越能尽最大的能力发挥高速缓存器读取的数据</strong>，在这点上再回过头思考多维数组的遍历并进行操作，如果没有考虑空间局部性(即先操作大块，再操作小块)，那么在高速缓存器中，它的不命中率令人发指，这也是操作不当效率低的原因。</p>
</li>
<li><p>另一方面，对于不同步长而言，其影响的也是高速缓存器的命中率，还是上方的<code>vector</code></p>
<pre><code>步长       | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> |
不命中<span class="regexp">/命中 |1/</span><span class="number">4</span>|<span class="number">1</span><span class="regexp">/2|2/</span><span class="number">3</span>|<span class="number">1</span><span class="regexp">/1|1/</span><span class="number">1</span>|
</code></pre><p>可以看出来，对于步长而言，当到了一定的上限以后，每次的请求都会不命中，那么这时候本层的高速缓存器相当于作废，时间全都耗费在下层数据传送到上层的时间，因为每次读取都是不命中，可以利用上方的例子自己试着推理一下。</p>
</li>
</ul>
</li>
<li><p>在参考文献中提到了一种优化程序的技巧，便是充分的利用高速缓存器，并且不受缓存器大小的限制，做法是当所操作的数据过大的情况下，通过构造循环来创建一个有一个大块，这些块能够被高速缓存器容纳，那么我们就能够充分利用高速缓存器来实现功能。 </p>
</li>
</ol>
<blockquote>
<p>缓存器示意图</p>
</blockquote>
<pre><code><span class="code">----------------------------------------------
|  CPU某个核                                  |  ......其他核
| ----------  ----------  ------------------ | 
| |        |  |        |  |                | |  
| |   L1   |  |   L1   |  |   L2高速缓存器  | | 
| | 一级数据|  | 一级指令|   |    二级缓存器   | |
| ----------  ----------  ------------------ |
----------------------------------------------</span>

<span class="code">------------------------------------------------------------------------------------
|                                                                                  |
|                                   L3高速缓存器                                    |
|                                    三级缓存器                                     |
------------------------------------------------------------------------------------</span>
</code></pre><h4 id="参考:[1]深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">[1]深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(4)---效率(上)]]></title>
    <link href="//wushxin.top/2015/05/20/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(4)/"/>
    <id>//wushxin.top/2015/05/20/我为什么学C(4)/</id>
    <published>2015-05-20T03:06:38.000Z</published>
    <updated>2015-06-03T11:50:43.786Z</updated>
    <content type="html"><![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的<a id="more"></a></li>
<li><p>注：随着编译器的版本更新，即使不开启优化选项，自带的编译器优化依旧能够为我们编写的代码提供一部分优化，这便是不使用老版本编译器的原因，虽然作为一个程序员不应该太依赖于编译器，但是我认为，时代在进步，信息量正在无限的膨胀，但是人类的大脑以及精力在一个大时代内是有限的，换句话说对于普通人而言我们的记忆是有限的，我们不应该把精力放在前人已经做完的事情上，而是要站在巨人的肩膀上向更远处眺望，如此我们应该充分利用工具来帮助我们实现一些既有的功能，而程序员应该更 专注于发现新的思路，以及想法，在图灵测试尚未有人打破之前，程序员依赖编译器并不是一件错误的事情。</p>
<p>  对于当下的编译器，以<code>GCC</code>(<strong>GCC不仅仅是一个编译器，但这里将它当成编译器的代名词</strong>)为例，<code>-O2</code>是一个为大众所接受的优化等级，对于其他编译器，一般程序员可以选择使用由Google和Apple联合开发的编译器<code>clang</code>也是一个很好的选择， 在<code>-O2</code>的优化等级下，<code>GCC</code>一般情况下能够自动执行<strong>循环展开</strong>优化，</p>
</li>
</ul>
<h4 id="开始">开始</h4><ol>
<li><p>.</p>
<pre><code><span class="comment">/*struct.h*/</span>   
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> me{
        <span class="keyword">int</span>        value;
        <span class="keyword">struct</span> me* next;
}data_t;

<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index;
        data_t* storage;
}block;    
</code></pre><p>为了测试方便我们首先定义了两个结构体，分别是:</p>
<p> <code>block</code>代表一个块，每个块都有一个序号(<code>int</code>)，一个数据域<code>data_t</code><br><br> <code>data_t</code>代表一个数据域，原型是一个链表，每个<code>data_t</code>对象中包含一个数据和一个指针。</p>
<pre><code>/*main.c*/
<span class="comment">#include "struct.h"</span>
<span class="comment">#define ARR_SIZE 10</span>
<span class="keyword">static</span> inline <span class="type">int</span> get_len(<span class="keyword">const</span> data_t* data)
{
    <span class="type">int</span> len = <span class="number">0</span>;

    <span class="keyword">if</span>(!data)
        fprintf(<span class="literal">stderr</span>,<span class="string">"The data in %p is NULL\n"</span>,data);
    <span class="keyword">else</span>
        <span class="keyword">while</span>(!data-&gt;next)
        {
            ++len;
            data = data-&gt;next;
        }
    <span class="keyword">return</span> len;
}

<span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; get_len(process-&gt;storage);++i)
    {
        *<span class="literal">result</span> += (process-&gt;storage)[i];
    }
}
</code></pre><p>此时我们得到了两个测试函数，<code>get_len</code>和<code>mix_cal</code>分别用来得到<code>data_t</code>长度，以及计算数据域的总和。</p>
<pre><code>/*main.c*/    
<span class="type">int</span> main(<span class="type">void</span>)
{
    <span class="keyword">block</span>* block_in_all[<span class="type">ARR_SIZE</span>]  = { <span class="type">NULL</span> };
    <span class="type">int</span>    result_in_all[<span class="type">ARR_SIZE</span>] = { <span class="number">0</span> };
    /*
    *假设生成了许多的`<span class="keyword">block</span>`类型对象
    *将许多的`<span class="keyword">block</span>`放置在一个数组中，每个元素类型为`<span class="keyword">block</span>*`
    *每个<span class="keyword">block</span>对象中都包含非空的data_t类型的数据域
    */
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        mix_cal(block_in_all[i], result_in_all+i);
    }
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        printf(<span class="string">"The %dth block have the total %d data\n"</span>,
                    block_in_all[i]-&gt;index, result_in_all[i]);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>耐心读完上述的代码，它是用来求和的，求一个域中的所有元素的和。仔细分析一下，很容易就能看见一些缺点，最大的莫过于在<code>mix_cal</code>函数中对于<code>get_len</code>函数的调用，在此处看来十分明显，但是我们在编写程序的时候是否能够注意到这个问题呢？<br><br>对于一些不必要的函数调用我们要做的便是将他们提取出来，使用临时变量是一个很好的办法，因为在编译器的帮助下<strong>临时变量</strong>在<strong>允许的情况下</strong>能够充分的利用CPU的寄存器。之所以是允许的情况下，是因为寄存器的数量并不多，而编译器在寄存器的使用上需要考虑许多的复杂因素，故并不是每次使用临时变量都能加入寄存器。但这并不妨碍我们提升程序的性能。</p>
<p> 在此处，我们应该将<code>for</code>循环中的判断语句里的<code>get_len</code>函数提取出来，在外部使用一个临时变量接收结果，而不是在循环中一直调用该函数。</p>
<pre><code><span class="typename">int</span> <span class="built_in">len</span> = get_len(process-&gt;storage);
</code></pre></li>
<li><p>.</p>
<p> 依旧是上方的代码，我们来讲述一下，循环展开。</p>
<p> 对于<code>mix_cal</code>函数，我们或者说编译器可以如何提升它的速度呢？我们说过一点的小改变都可能对一个程序的最终代码产生极大的影响，对此最常用的便是尝试，前人之路早已铺好，不需要重复造轮子了。</p>
<p> 循环展开:</p>
<pre><code><span class="type">int</span> reality = len - <span class="number">1</span>, i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
{
    *<span class="literal">result</span> = *<span class="literal">result</span> + (process-&gt;storage)[i] 
                      + (process-&gt;storage)[i+<span class="number">1</span>];
}
<span class="keyword">for</span>(;i &lt; len;++i)
{
    *<span class="literal">result</span> +=  (process-&gt;storage)[i];
}
</code></pre><p> 这就是循环展开中的<strong>2次循环展开</strong>，同样还有n次循环展开。</p>
<p> 同样，在刚才提到过寄存器的使用以及减少不必要的开销，在此程序中对于<code>(process-&gt;storage)[i]</code>这样的存储器位置解引用太过浪费，我们总是将其优化成本低临时变量的使用</p>
<pre><code><span class="typedef"><span class="keyword">data</span>* local_data = process-&gt;storage;</span>
</code></pre><p> 这将为程序带来十分可观的节约，虽然这些工作在编译器的优化中都能包括，但是一旦我们的代码难以被编译器所理解(虽然编译器的升级最大的目的就是提升优化效果)，那么我们很可能得到一个性能不够可观的程序。所以当我们并不是特别紧凑的时候，可以将这些工作当成我们的本分来做，而不是交给编译器来做。</p>
<p> 以及对于外部存储位置 <code>result</code> 我们在此处也是存在着浪费，同样我们应该使用一个临时变量来存储总和，而不是每次得到结果便对它进行解引用操作。</p>
<pre><code><span class="type">int</span> local_result = <span class="number">0</span>;
/*...*/
local_result = local_result + local_data[i] + local_data[i+<span class="number">1</span>];
/*...*/
*<span class="literal">result</span> = local_result;
</code></pre><p>在上方我们可以看见<strong>循环展开</strong>被称作<strong>2次循环展开</strong>，那么自然可以推断有<code>n</code>次循环展开，自然是有的，对于一个n次循环展开的式子我们有一个简便的上界确定公式即:</p>
<pre><code><span class="attribute">reality </span>=<span class="string"> len - n + 1;</span>
</code></pre><p>至于展开几次最好，依然是视环境而定。<br>故最终的版本应该为：</p>
<pre><code><span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="type">int</span> local_result = <span class="number">0</span>;
    <span class="type">int</span> len = get_len(process-&gt;storage);
    <span class="type">int</span> reality = len - <span class="number">1</span>, i;
    data* local_data = process-&gt;storage;

    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
        local_result += local_data[i] + local_data[i+<span class="number">1</span>];
    <span class="keyword">for</span>(;i &lt; len;++i)
        local_result += local_data[i];

    *<span class="literal">result</span> = local_result;
}
</code></pre><p>解释：循环展开将元素相加分为两个部分，第一部分每次加两个元素，由于如此做会剩余元素没有加，故在第二部分将剩下的元素都加起来。</p>
</li>
<li><p>.<br>还有一种叫做<strong>重新组合</strong>的技巧，即为让一个表达式中的运算数自由组合，组合出最快速的一种，但是这种方法未曾试验过。故不提及。</p>
</li>
<li><p>.<br>对于条件分支预测错误造成的时间损耗，称之为<strong>惩罚</strong>，最通俗的说法，就是当你编写的代码中含有条件分支的时候，处理器会选择去<strong>预判</strong>某一个分支是此次正确的支路，这样可以避免修改任何实际的寄存器和存储器，一直到确定了实际结果，要是不对，那就惨了，这段时间做的事情都白费了。但是也不必过分的关心这种条件分支的预测，这也是我放在最后说的意义所在。</p>
<p> 这里有两种较为客观的方法，一种被称为<strong>命令式</strong>，一种被称为<strong>功能式</strong></p>
<p> 命令式：</p>
<pre><code><span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{
    if(a[i] &gt; b[i]){
        int temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }</span>
}
</code></pre><p> 功能式：</p>
<pre><code>int min, max;
<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{    
    min = a[i] &lt; b[i] ? a[i] : b[i];
    max = a[i] &lt; b[i] ? b[i] : a[i];
    a[i] = min;
    b[i] = max;
}</span>
</code></pre><p>很清晰的一个例子，明显看出来，前者对于不同情况所作的程序步数明显不同，而后者无论什么情况都是相同的程序步。</p>
<p> 两个形式的好处前者对于可预测数据来说，是一个很好的模型，后者则是中庸之道，什么是可预测不可预测，比如一个数是负数还是正数这就是不可预测的，用前面那个代码会有很大的<strong>惩罚</strong>。</p>
</li>
<li><p>.<br>多路并行的技巧也是一个很重要的思路，可能在很多人眼中看来，两条语句依次写出和合并的效果一定是一样。但是多路并行有一个缺点就是对寄存器的数量有所要求，当寄存器不够时(称为溢出)，性能不升反降。同样是对于循环展开，此次使用<strong>四次循环展开</strong>加<strong>二路并行</strong>：</p>
<pre><code><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">4</span>){
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i] + <span class="built_in">local</span>_data[i+<span class="number">1</span>];
    <span class="built_in">local</span>_result_2 += <span class="built_in">local</span>_data[i+<span class="number">2</span>] + <span class="built_in">local</span>_data[i+<span class="number">3</span>];
}//也可以分成四路并行，每一路存一个。这种做法充分利用了CPU流水线的性能
<span class="keyword">for</span>(;i &lt; len;++i)
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i];

*result = <span class="built_in">local</span>_result_1 + <span class="built_in">local</span>_result_2;
</code></pre></li>
</ol>
<h4 id="结束">结束</h4><h4 id="Tips:">Tips:</h4><p>上文中写到的函数大都带有<code>static inline</code>关键字，这是何意？首先我们要确定一件事情，对于非工程的单文件而言，<code>static</code>函数并没有什么意义(意义指的是对于可见性而言，并非说它一无是处)，许多人对于<code>static</code>函数感到茫然的原因在于:我明明将一个函数声明定义成<code>static</code>类型了，但是我还是可以在别的文件中访问到啊！</p>
<p>其实这是因为你根本就没有理解<strong>C语言</strong>工程这个意思，大部分人是这么测试的:</p>
<ol>
<li><p>首先在一个文件夹里创建两个文件 <code>test_static.c</code>和<code>static.h</code>:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> "static.h"</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//编译通过，可以运行。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
<li><p>然后编译运行，发现可以通过啊！！标准怎么说在其他文件中不可见？而把<code>static.h</code>去掉<code>#include</code>之后发现报错<code>test undefined</code>，瞬间初学者就凌乱了。</p>
</li>
<li><p>好吧，实际上是前辈们以及教材的错，因为从始至终，所有外界现象都告诉我们<strong>C程序</strong>是独立的一个一个文件组成的，但是并没有告诉我们要先将他们弄成一个工程！此处如果是使用<strong>Visual Studio</strong>学习C语言的可能会对工程这个概念理解的稍微好一些，虽然极度反对排斥使用 VS 学习C语言这种行为。</p>
</li>
<li><p>你想要实现<code>static</code>函数仅在本文件可见的效果，请你先补习一下<strong>工程</strong>这个概念，对于任何可见或者不可见的概念而言都是建立在一个工程内而言，而不是像上方的代码，使用<code>#include</code>来表示，你都<code>#include</code>了，那还有什么可见不可见的当然都可见了。所以一个<code>static</code>函数可见于不可见是基于一个个工程里的所有C语言源文件而言的。所以你将常看见前辈们这么回答你的提问:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//报错，因为test是static函数。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>发现了吗？在上方代码中，少了一行<code>#include &quot;static.h&quot;</code>但是这个代码依旧可行，因为这两个文件是建立在同一个工程里的，而不是在一个文件夹中随意新建两个源文件这么简单，你可以使用各个<strong>IDE</strong>的工程功能来进行测试。</p>
</li>
</ol>
<p>回到正题，在这里稍微提一下<strong>static</strong>对函数的某些作用，它可以让函数放在一个静态的空间中，而不是栈里，这是的它的调用更加快速，经常与<strong>inline</strong>关键字一起使用，为的就是让函数更加快。但是有利有弊，可以自己权衡一下。</p>
<h4 id="参考:深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可视化Qt信号与槽]]></title>
    <link href="//wushxin.top/2015/05/19/%E5%8F%AF%E8%A7%86%E5%8C%96Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>//wushxin.top/2015/05/19/可视化Qt信号与槽/</id>
    <published>2015-05-19T01:38:38.000Z</published>
    <updated>2015-06-12T12:52:32.538Z</updated>
    <content type="html"><![CDATA[<h2 id="Qt5_中的信号与槽">Qt5 中的信号与槽</h2><p>对于已经有了IDE的Qt而言，我们拥有更多的建立<strong>信号-槽</strong>方法的选择，但是作为一名自然人类，我们最喜欢的还是眼见为实，既然Qt为我们设计了 <strong>Qt Creator</strong>，那么我们就应该充分利用它，然而国内的教程大都停留在非可视化操作下，这里记录在 <strong>Qt Creator</strong> 下我们该如何设计一个<strong>信号-槽</strong>机制</p>
<h4 id="准备工作">准备工作</h4><p>打开<strong>Qt Creator</strong>，创建<strong>Qt Gui</strong>项目，我使用的是Qt5，但是同样也适用于Qt4，两者的在本次中的区别就在于建立连接<code>(QObject::connect)</code>的时候，Qt5更加灵活。</p>
<p>项目是<code>MainWindow</code>类，建立完成之后， <strong>Qt Creator</strong> 自动生成一系列文件</p>
<ol>
<li>打开<code>mainwindow.h</code>头文件，进行添加测试函数 <code>void test();</code></li>
<li><p>首先包含以下测试使用的头文件<code>&lt;QDebug&gt; &lt;QMessageBox&gt;</code><br>该函数原型需要首先加在<code>private:</code>下，作为私有成员函数。</p>
</li>
<li><p>其次打开<code>mainwindow.cpp</code>文件，进行测试函数的定义:</p>
<pre><code><span class="tag">void</span> <span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">test</span>()
{
    <span class="function">qDebug</span>() &lt;&lt; <span class="string">"Test Successful!"</span></span></span>;
    <span class="rule"><span class="attribute">QMessageBox</span>:<span class="value">:<span class="function">information</span>(this, <span class="function">tr</span>(<span class="string">"Tip"</span>), <span class="function">tr</span>(<span class="string">"Test"</span>))</span></span>;
}
</code></pre></li>
<li>上方的系列操作，<code>2</code>这个功能在Qt5下成功，Qt4需要在标签<code>public slots:</code>下放置该函数声明。<code>3</code>这个操作中定义了<code>test()</code>的函数体，其中<code>qDebug()</code>是在终端调试的时候使用的一个函数，我们使用它来在 <strong>应用程序输出</strong> 窗口显示是否成功。<code>QMessageBox::information(...)</code>则是用来显示一个窗口，也用来显示是否成功。</li>
</ol>
<h4 id="方法1">方法1</h4><ol>
<li><p>双击<code>.ui</code>文件，进入<strong>Qt Designer</strong>，至于不懂这个的也无所谓，只是个叫法而已，只需要知道如何在这个界面操作即可。</p>
<a id="more"></a>  
<ul>
<li>这时候我们为了演示，拖动添加一个<code>Push Button</code>按钮进窗口，这时候发现主界面上多了一个 <strong>PushButton</strong>，这时候看到你的右下方，有一个<strong>属性</strong>窗口，有过设计经验的都很熟悉，</li>
<li><code>objectName</code>代表的是在代码中这个控件的名字，记好它，当然你也可以修改它</li>
<li><code>QAbstractButton</code>下的<code>text</code>代表的是，你的程序运行起来以后该控件在你面前显示出来的名字。</li>
<li><code>statusTip</code>代表的是，当你鼠标移动到这个控件上时，在整个窗口中的下部有一块区域 <strong>Status Bar</strong> ，在此处显示你在其中填写的信息</li>
<li><code>shortcut</code>顾名思义就是快捷键的意思，但是此处快捷键使用<strong>Qt Designer</strong>设置有一个不太好的地方便是，无法很好的跨平台支持，如Mac OS下是<code>Command</code>代替了很多Windows下的<code>Ctrl</code>操作，使用代码则可以调用Qt所配置好的API。</li>
<li>以上几个是常用的几个属性。</li>
</ul>
</li>
<li><p>做完<strong>PushButton</strong>的准备工作之后，<code>objectName</code>为<strong>Button_1</strong></p>
<ul>
<li>由于<strong>Qt Designer</strong>只支持Qt的内置槽函数的建立连接，但是我们可以想办法让它变为可行，右键主窗体，选择 <strong>改变信号/槽</strong>，在出现的窗口中的槽里，点击加号，在其中输入刚才预先做好的测试函数<code>test()</code>，点击<code>OK</code>即可</li>
<li>这时候我们在下方找到一个窗口<code>Signals &amp; Slots Editor</code>,如果没有可以仔细找找，或者上网查询如何打开它，在此处我们可以很轻松的使用Qt中的信号与槽的连接，点击加号，出现一个新的记录，记录中包含 <strong><code>发送者(sender), 信号(signal), 接收者(receiver), 槽(slot)</code></strong> 犹如字面意思</li>
<li>在其中发送者选择<strong>Button_1</strong>，信号选择<strong>triggered</strong>，接收者选择<strong>MainWindow</strong>，槽选择<strong>open()</strong></li>
</ul>
</li>
<li><p>这样做完就行，这时候只需要保证<code>main.cpp</code>中包含有如下代码</p>
<pre><code>MainWindow win_1<span class="comment">;</span>
win_1.<span class="literal">show</span>()<span class="comment">;</span>
</code></pre><p> 就行，这时候编译运行，OK，你想要的效果就出来啦</p>
<ul>
<li>这就是全程的可视化操作，省去了一部份精力<h4 id="方法2">方法2</h4></li>
</ul>
</li>
<li><p>步骤1与上方的方法1一致，直到</p>
</li>
<li><p>在此处我们记下了<strong>PushButton</strong>的<code>objectName</code>之后，在<code>mainwindow.cpp</code>文件的类构造函数的定义中，修改代码，以代码形式得到我们上面使用可视化操作的效果，在这一步，往往有人会卡住，总是发现，明明关联没有错误，但是总是提示错误: <strong>QObject connect invaild null parameter</strong>，这是为什么？我们看一下<code>mainweindow.cpp</code>的构造函数的原始状态</p>
<pre><code><span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">MainWindow</span>(QWidget *parent) :
    <span class="function">QMainWindow</span>(parent),
    <span class="function">ui</span>(new Ui::MainWindow)
{
    ui-&gt;<span class="function">setupUi</span>(this)</span></span>;
}
</code></pre><p> 其中最后一句代码是将<strong>Qt Designer</strong>中的实现自动转化为代码，如果你在这句代码之前使用使用<code>QObject::connect</code>那么会导致，无法找到刚才创建的控件对象。所以我们只需要把<code>connect</code>放在后面即可。</p>
<pre><code>ui-&gt;setupUi(<span class="keyword">this</span>);
QObject::connect(ui-&gt;pushButton, &amp;QPushButton::click, 
                <span class="keyword">this</span>, <span class="keyword">this</span>-&gt;open);
</code></pre><p> 在此处<code>QObject::connect</code>可以简写为<code>connect</code>,因为此刻我们正处于<code>MainWindow::MainWindow</code>这个对象的作用域当中。</p>
</li>
<li>最后也是保证<code>main.cpp</code>的代码即可。</li>
</ol>
<h4 id="对于可视化">对于可视化</h4><p>虽然<strong>Qt Creator</strong>给予了我们极大的便利，但是在实际的复杂功能实现中，个人感觉还是需要代码操作占到主体，而界面设计毕竟只是一小部分，虽然Qt这个框架十分之大，但是其命名却是非常的人性化，常见的几个属性:</p>
<pre><code>ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setText(tr(<span class="string">"button_name_you_want"</span>));
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setStatusTip(tr(<span class="string">""</span>));
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setShortcut(QKeySequence<span class="tag">::shortcut_you_want</span>);
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setIcon(QIcon(<span class="string">":/adressofpicture"</span>));
<span class="attribute">...</span>
</code></pre><p>如此看，基本只要是属性的函数命名都是以<code>set...</code>开头，每个成员函数都能很清楚的看出功能。</p>
<p>并且其中大部分都是以<code>QString</code>为类型参数，即<code>tr(&quot;...&quot;)</code>代表的就是将<strong>C风格字符串</strong>转为<code>QString</code>类型。</p>
<p>而某些特殊的则需要记住，例如<code>QKeySequence::...</code>代表的是由Qt自带的快捷键API,使用它能更好的适应跨平台的问题。<code>QKeySequence::Open</code>在Windows下默认为<strong>Ctrl+O</strong>,Mac下为<strong>Command+O</strong></p>
<h4 id="最后的最后感谢_Haavard_Nord_和_Eirik_Chambe-Eng_为我们无私贡献了这么强大的Qt开源库">最后的最后感谢 Haavard Nord 和 Eirik Chambe-Eng 为我们无私贡献了这么强大的Qt开源库</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Qt5_中的信号与槽">Qt5 中的信号与槽</h2><p>对于已经有了IDE的Qt而言，我们拥有更多的建立<strong>信号-槽</strong>方法的选择，但是作为一名自然人类，我们最喜欢的还是眼见为实，既然Qt为我们设计了 <strong>Qt Creator</strong>，那么我们就应该充分利用它，然而国内的教程大都停留在非可视化操作下，这里记录在 <strong>Qt Creator</strong> 下我们该如何设计一个<strong>信号-槽</strong>机制</p>
<h4 id="准备工作">准备工作</h4><p>打开<strong>Qt Creator</strong>，创建<strong>Qt Gui</strong>项目，我使用的是Qt5，但是同样也适用于Qt4，两者的在本次中的区别就在于建立连接<code>(QObject::connect)</code>的时候，Qt5更加灵活。</p>
<p>项目是<code>MainWindow</code>类，建立完成之后， <strong>Qt Creator</strong> 自动生成一系列文件</p>
<ol>
<li>打开<code>mainwindow.h</code>头文件，进行添加测试函数 <code>void test();</code></li>
<li><p>首先包含以下测试使用的头文件<code>&lt;QDebug&gt; &lt;QMessageBox&gt;</code><br>该函数原型需要首先加在<code>private:</code>下，作为私有成员函数。</p>
</li>
<li><p>其次打开<code>mainwindow.cpp</code>文件，进行测试函数的定义:</p>
<pre><code><span class="tag">void</span> <span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">test</span>()
{
    <span class="function">qDebug</span>() &lt;&lt; <span class="string">"Test Successful!"</span></span></span>;
    <span class="rule"><span class="attribute">QMessageBox</span>:<span class="value">:<span class="function">information</span>(this, <span class="function">tr</span>(<span class="string">"Tip"</span>), <span class="function">tr</span>(<span class="string">"Test"</span>))</span></span>;
}
</code></pre></li>
<li>上方的系列操作，<code>2</code>这个功能在Qt5下成功，Qt4需要在标签<code>public slots:</code>下放置该函数声明。<code>3</code>这个操作中定义了<code>test()</code>的函数体，其中<code>qDebug()</code>是在终端调试的时候使用的一个函数，我们使用它来在 <strong>应用程序输出</strong> 窗口显示是否成功。<code>QMessageBox::information(...)</code>则是用来显示一个窗口，也用来显示是否成功。</li>
</ol>
<h4 id="方法1">方法1</h4><ol>
<li><p>双击<code>.ui</code>文件，进入<strong>Qt Designer</strong>，至于不懂这个的也无所谓，只是个叫法而已，只需要知道如何在这个界面操作即可。</p>]]>
    
    </summary>
    
      <category term="Qt" scheme="//wushxin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(3)---预处理器]]></title>
    <link href="//wushxin.top/2015/05/13/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(3)/"/>
    <id>//wushxin.top/2015/05/13/我为什么学C(3)/</id>
    <published>2015-05-13T09:17:49.000Z</published>
    <updated>2015-06-03T11:50:20.405Z</updated>
    <content type="html"><![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x06-C语言预处理器">0x06-C语言预处理器</h4><p><strong>预处理最大的标志便是大写，虽然这不是标准，但请你在使用的时候大写，为了自己，也为了后人。</strong></p>
<p>预处理器在一般看来，用得最多的还是宏，这里总结一下预处理器的用法。</p>
<pre><code><span class="id">#include</span> &lt;stdio.h&gt;
<span class="hexcolor">#def</span>ine MACRO_OF_MINE
<span class="id">#ifdef</span> MACRO_OF_MINE
<span class="id">#else</span>
#endif
</code></pre><p>上述五个预处理是最常看见的，第一个代表着包含一个头文件，可以理解为没有它很多功能都无法使用，例如C语言并没有把输入输入纳入标准当中，而是使用库函数来提供，所以只有包含了<code>stdio.h</code>这个头文件，我们才能使用那些输入输出函数。<br><code>#define</code>则是使用频率第二高的预处理机制，广泛用在常量的定义，只不过它和<code>const</code>声明的常量有所所区别:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MAR_VA 100</span>
<span class="keyword">const</span> <span class="keyword">int</span> Con_va = <span class="number">100</span>;
...
<span class="comment">/*定义两个数组*/</span>
...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
{
    mar_arr[i] = MAR_VA;
    con_arr[i] = Con_va;
}
</code></pre><ul>
<li>区别1,定义上<code>MAR_VA</code>可以用于数组维数，而<code>Con_va</code>则不行</li>
<li>区别2,在使用时，MAR_VA的原理是在文中找到所有使用本身的地方，用值替代，也就是说<code>Con_va</code>将只有一分真迹，而<code>MAR_VA</code>则会有<code>n</code>份真迹(n为使用的次数)<br>剩下三个则是在保护头文件中使用颇多。<a id="more"></a></li>
</ul>
<p>几个比较实用的用于调试的宏,由C语言自带</p>
<ul>
<li><code>__LINE__和__FILE__</code><br>用于显示当前行号和当前文件名</li>
<li><code>__DATA__和__TIME__</code><br>用于显示当前的日期和时间</li>
<li><code>__func__</code><strong>(C99)</strong><br>用于显示当前所在外层函数的名字</li>
</ul>
<p><em>上述所说的五种宏直接当成值来使用即可。</em></p>
<ul>
<li><p><code>__STDC__</code></p>
<ul>
<li><p>如果你想检验你现在使用的编译器是否遵循ISO标准，用它，如果是他的值为1。</p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, __STDC_<span class="number">_</span>);
</code></pre><p><code>输出: 1</code></p>
</li>
<li><p>如果你想进一步确定编译器使用的标准版本是C99还是C89可以使用<code>__STDC__VERSION__</code>，C99(199901) </p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, __STDC_VERSION_<span class="number">_</span>);
</code></pre><p><code>输出: 199901</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="对于#define">对于<code>#define</code></h5><ol>
<li><p>预处理器一般只对同一行定义有效，但如果加上反斜杠，也能一直读取下去</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">err</span><span class="params">(flag)</span></span> \
    <span class="function"><span class="title">if</span><span class="params">(flag)</span></span> \
      <span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Correctly"</span>)</span></span>
</code></pre><p>可以看出来，并没有在末尾添加<code>;</code>，并不是因为宏不需要，而是因为，我们总是将宏近似当成函数在使用，而函数调用之后总是需要以<code>;</code>结尾，为了不造成混乱，于是在宏定义中我们默认不添加<code>;</code>，而在代码源文件中使用，防止定义混乱。</p>
</li>
<li><p>预处理同样能够带来一些便利</p>
<pre><code><span class="title">#define SWAP1</span><span class="comment">(a, b)</span> <span class="comment">(a += b, b = a - b, a -= b)</span>
<span class="title">#define SWAP2</span><span class="comment">(x, y)</span> {x ^= y; y ^= x; x ^= y}
</code></pre><p>引用之前的例子，交换两数的宏写法可以有效避免函数开销，由于其是直接在调用处展开代码块，故其比拟直接嵌入的代码。但，偶尔还是会出现一些不和谐的错误，对于初学者来说:</p>
<pre><code>int v1 = <span class="number">10</span><span class="comment">;</span>
int v2 = <span class="number">20</span><span class="comment">;</span>
SWAP1<span class="list">(<span class="keyword">v1</span>, v2)</span><span class="comment">;</span>
SWAP2<span class="list">(<span class="keyword">v1</span>, v2)</span><span class="comment">;//报错</span>
</code></pre><p>对于上述代码块的情况，为什么<code>SWAP2</code>报错？对于一般的初学者来说，经常忽略诸如<code>，</code> <code>goto</code> <code>do...while</code>等少见关键字用法，故很少见<code>SWAP1</code>的写法，大多集中于<code>SWAP2</code>的类似错误，错就错在<code>{}</code>代表的是一个代码块，不需要使用<code>;</code>来进行结尾，这便是宏最容易出错的地方<br><strong>宏只是简单的将代码展开，而不会做任何处理</strong><br>对于此，即便是老手也常有失足，有一种应用于单片机等地方的C语言写法可以在此借鉴用于保护代码:</p>
<pre><code><span class="title">#define SWAP3</span><span class="comment">(x ,y)</span> <span class="keyword">do</span>{ \
        x ^= y; y ^= x; x ^= y; \
        }<span class="keyword">while</span><span class="comment">(0)</span>
</code></pre><p>如此便能在代码中安全使用花括号内的代码了，并且如之前所约定的那样，让宏的使用看起来像函数。</p>
</li>
<li><p>但正所谓，假的总是假的，即使宏多么像函数，它依旧不是函数，如果真的把它当成函数，你会在某些时候错的摸不着头脑,还是一个经典的例子，比较大小:</p>
<pre><code><span class="comment">#define CMP(x, y) (x &gt; y ? x : y)</span>
...
<span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;
<span class="type">int</span> <span class="literal">result</span> = <span class="type">CMP</span>(x, y++);
printf(<span class="string">"x = %d, y = %d, result = %d\n"</span>, x, y, <span class="literal">result</span>);
</code></pre><p>执行这部分代码，会输出什么呢？<br>答案是，<strong>不知道！</strong>至少<code>result</code>的值我们无法确定，我们将代码展开得到</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = (x &gt; y++ ? x : y++);
</code></pre><p>看起来似乎就是<code>y</code>递增两次，最后<code>result</code>肯定是<code>200</code>。真是如此？C语言标准对于一个确定的程序语句中，一个对象只能被修改一次，超过一次那么结果是未定的，由编译器决定，除了三目操作符<code>?:</code>外，还有<code>&amp;&amp;</code>, <code>||</code>或是<code>,</code>之中，或者函数参数调用，<code>switch控制表达式，for里的控制语句</code><br>由此可看出，宏的使用也是有风险的，所以虽然宏强大，但是依旧不能滥用。</p>
</li>
<li><p>对于宏而言，前面说过，它只是进行简单的展开，这有时候也会带来一些问题:</p>
<pre><code><span class="comment">#define MULTI(x, y) (x * y)</span>
...
<span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;
<span class="type">int</span> <span class="literal">result</span> = <span class="type">MULTI</span>(x+y, y);
</code></pre><p>看出来问题了吧？展开之后会变成:<br><code>int result = x+y * y;</code><br>完全违背了当初我们设计时的想法，一个比较好的修改方法是对每个参数加上括号:<br><code>#define MULTI(x, y) ((x) * (y))</code>如此，展开以后:</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = ((x+y) * (y));
</code></pre><p>这样能在很大程度上解决一部分问题。</p>
</li>
<li><p>如果对自己的宏十分自信，可以嵌套宏，即一个表达式中使用宏作为宏的参数，但是宏只展开这一级的宏，对于多级宏另有办法展开</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = <span class="type">MULTI</span>(<span class="type">MULTI</span>(x, y), y);
</code></pre><p>展开成:<code>int result = ((((x) * (y))) * (y));</code></p>
</li>
</ol>
<h5 id="对宏的应用">对宏的应用</h5><ol>
<li><p>由于我们并不明白，在某些情况下宏是否被定义了，<strong>(NULL宏是一个例外，它可以被重复定义)</strong>，所以我们可以使用一些预处理保护机制来防止错误发生</p>
<pre><code><span class="id">#ifndef</span> MY_MACRO
<span class="hexcolor">#def</span>ine MY_MACRO <span class="number">10000</span>
#endif
</code></pre><p>如果定义了<code>MY_MACRO</code>那就不执行下面的语句，如果没定义那就执行。</p>
</li>
<li><p>在宏的使用中有两个有用的操作符，姑且叫它操作符<code>#</code>, <code>##</code></p>
<ul>
<li><p>对于<code>#</code><br>我们可以认为<code>#</code>操作符的作用是将宏参数转化为字符串。</p>
<pre><code><span class="variable">#define</span> HCMP(x, y) printf(<span class="variable">#x</span><span class="string">" is equal to"</span> <span class="variable">#y</span><span class="string">" ? %d\n"</span>, (x) <span class="subst">==</span> (y))
<span class="attribute">...</span>
int x <span class="subst">=</span> <span class="number">100</span>, y <span class="subst">=</span> <span class="number">200</span>;
HCMP(x, y);
</code></pre><p>展开以后</p>
<pre><code>printf<span class="list">(<span class="string">"x is equal to y ? %d\n"</span>, <span class="list">(<span class="number">100</span>)</span> == <span class="list">(<span class="number">200</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>总结起来，即将宏参数放于<code>#</code>操作符之后便由预处理器自动转换为字符串常量，转义也由预处理器自动完成，而不需要我们自行添加转义符号。</p>
</li>
<li><p>对于<code>##</code><br>它实现的是将本操作符两边的参数合并成为一个完整的标记，但需要注意的是，由于预处理器只负责展开，所以程序员必须自己保证这种标记的合法性，这里涉及到一些写法问题，都列出来</p>
<pre><code><span class="comment">#define MERGE(x, y) have_define_ ## (x + y)</span>
<span class="comment">#define MERGE(x, y) have_define_##(x + y)</span>
...
<span class="literal">result</span> = <span class="type">MERGE</span>(<span class="number">1</span>, <span class="number">3</span>);
</code></pre><p>这里首先说明，上述写法由于习惯原因，我使用第二种，但是无论哪种都无伤大雅，效果一样。上述代码展开以后是什么呢？</p>
<pre><code><span class="literal">result</span> = have_define_1 + <span class="number">3</span>;
</code></pre><p>在我看来，这就有点<code>C++</code>中模版的思想了，虽然十分原始，但是总是有了一个方向，凭借这种方法我们能够使用宏来进行相似却不同函数的调用，虽然我们可以使用函数指针数组来存储，但需要提前知晓有几个函数，并且如果要实现动态增长还需要消耗内存分配，但宏则不同。</p>
<pre><code><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_0</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 + arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_1</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 - arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_2</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 * arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_3</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 / arg_2; }
<span class="preprocessor">#<span class="keyword">define</span> CALL(x, arg1, arg2) func_##x(arg1, arg2)</span>
...
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">0</span> ,CALL(<span class="number">0</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">1</span> ,CALL(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">2</span> ,CALL(<span class="number">2</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">3</span> ,CALL(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>));
</code></pre><p>十分简便的一种用法，在我们增加减少函数时我们不必考虑如何找到这些函数只需要记下每个函数对应的编号即可，但还是那句话，不可滥用。</p>
<pre><code><span class="comment">#define CAT(temp, i) (cat##i)</span>
//...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)
{
    <span class="keyword">int</span> CAT(<span class="keyword">x</span>,i) = i*i;
    <span class="keyword">printf</span>(<span class="string">"x<span class="variable">%d</span> = <span class="variable">%d</span> \n"</span>,i,CAT(<span class="keyword">x</span>,i));
}
</code></pre></li>
</ul>
</li>
<li><p>对于宏，在使用时一定要注意，宏只能展开当前层的宏，如果你嵌套使用宏，即将宏当作宏的参数，那么将导致宏无法完全展开，即作为参数的宏只能传递名字给外部宏</p>
<pre><code>#define WHERE(value_name, line) #value_name <span class="preprocessor">#line</span>
...
puts(WHERE(x, <span class="keyword">__LINE__</span>)); <span class="comment">//x = 11</span>
</code></pre><p><code>输出: 11__LINE__</code></p>
</li>
<li><p>对于其他的预编译器指令，如:<code>#program, #line, #error</code>和各类条件编译并不在此涉及，因为使用上并未有陷阱及难点。</p>
</li>
</ol>
<h4 id="Create_By_WuShengxin_@_2015">Create By WuShengxin @ 2015</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x06-C语言预处理器">0x06-C语言预处理器</h4><p><strong>预处理最大的标志便是大写，虽然这不是标准，但请你在使用的时候大写，为了自己，也为了后人。</strong></p>
<p>预处理器在一般看来，用得最多的还是宏，这里总结一下预处理器的用法。</p>
<pre><code><span class="id">#include</span> &lt;stdio.h&gt;
<span class="hexcolor">#def</span>ine MACRO_OF_MINE
<span class="id">#ifdef</span> MACRO_OF_MINE
<span class="id">#else</span>
#endif
</code></pre><p>上述五个预处理是最常看见的，第一个代表着包含一个头文件，可以理解为没有它很多功能都无法使用，例如C语言并没有把输入输入纳入标准当中，而是使用库函数来提供，所以只有包含了<code>stdio.h</code>这个头文件，我们才能使用那些输入输出函数。<br><code>#define</code>则是使用频率第二高的预处理机制，广泛用在常量的定义，只不过它和<code>const</code>声明的常量有所所区别:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MAR_VA 100</span>
<span class="keyword">const</span> <span class="keyword">int</span> Con_va = <span class="number">100</span>;
...
<span class="comment">/*定义两个数组*/</span>
...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
{
    mar_arr[i] = MAR_VA;
    con_arr[i] = Con_va;
}
</code></pre><ul>
<li>区别1,定义上<code>MAR_VA</code>可以用于数组维数，而<code>Con_va</code>则不行</li>
<li>区别2,在使用时，MAR_VA的原理是在文中找到所有使用本身的地方，用值替代，也就是说<code>Con_va</code>将只有一分真迹，而<code>MAR_VA</code>则会有<code>n</code>份真迹(n为使用的次数)<br>剩下三个则是在保护头文件中使用颇多。]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(2)---指针]]></title>
    <link href="//wushxin.top/2015/05/13/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(2)/"/>
    <id>//wushxin.top/2015/05/13/我为什么学C(2)/</id>
    <published>2015-05-13T04:17:12.000Z</published>
    <updated>2015-06-03T11:50:02.655Z</updated>
    <content type="html"><![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x05-C语言指针:(Volume-1)">0x05-C语言指针:(Volume-1)</h4><p>这似乎是一个很凝重的话题，但是它真的很有趣。</p>
<p><strong><em>1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的</em></strong></p>
<p><strong><em>2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及<code>sizeof</code></em></strong></p>
<p><strong><em>3. C语言最晦涩难明的就是它复杂的声明: `void (</em>signal(int sig, void (<em>func)(int)))(int)`,试试着把它改写成容易理解的形式</em></strong></p>
<p><strong><em>4. 对于指针，尽最大的限度使用<code>const</code>保护它，无论是传递给函数，还是自己使用</em></strong></p>
<p>先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: <code>NULL</code>，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):</p>
<pre><code><span class="hexcolor">#def</span>ine NULL <span class="number">0</span>
<span class="hexcolor">#def</span>ine NULL ((void*)<span class="number">0</span>)
</code></pre><p>有什么区别吗？看起来没什么区别都是<code>0</code>，只不过一个是常量，一个是地址为0的指针。</p>
<p>当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:</p>
<pre><code><span class="keyword">int</span>* temp_int_1 = <span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_2 = (<span class="keyword">void</span>*)<span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_3 = <span class="number">10</span>; <span class="comment">//出现警告</span>
</code></pre><p>为什么？为什么<code>0</code>可以赋值给指针，但是<code>10</code>却不行？他们都是常量。</p>
<p>因为C语言规定当处理上下文的编译器发现常量<code>0</code>出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。</p>
<p>回到最开始，对于<code>NULL</code>的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。</p>
<p>在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加<code>&#39;\0&#39;</code>，好这里又出现了一个0值。</p>
<p>对于某些人，在使用字符数组的时候总是分不清楚<code>NULL</code>与<code>&#39;\0&#39;</code>的区别而误用，在字符数组的末尾使用<code>NULL</code>是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。</p>
<h5 id="开胃菜已过">开胃菜已过</h5><p>对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参</p>
<pre><code>int <span class="function"><span class="keyword">function</span><span class="params">(int value)</span>
</span>{
        <span class="comment">/*...*/</span>
}
<span class="comment">//...</span>
<span class="function"><span class="keyword">function</span><span class="params">(11)</span></span>;
</code></pre><p>其中，<code>value</code>是形参，<code>11</code>是实参，我们知道场面上，C语言拥有两种传递方式:<strong>按值传递</strong>和<strong>按址传递</strong>，但是你是否有认真研究过？这里给出一个实质，其实C语言只有<strong>按值传递</strong>，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。<br><a id="more"></a></p>
<p>对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数</p>
<pre><code>void swap_v1(int<span class="keyword">*</span> val_1, int<span class="keyword">*</span> val_2)
{
    int temp = <span class="keyword">*</span>val_1;
    <span class="keyword">*</span>val_1 = <span class="keyword">*</span>val_2;
    <span class="keyword">*</span>val_2 = <span class="keyword">*</span>val_1;
}
</code></pre><p>这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参<code>val_1</code>与<code>val_2</code>，实际上我们使用:</p>
<pre><code><span class="title">#define SWAP_V2</span><span class="comment">(a, b)</span> <span class="comment">(a += b, b = a - b, a -= b)</span>
<span class="title">#define SWAP_V3</span><span class="comment">(x, y)</span> {x ^= y; y ^= x; x ^= y}
</code></pre><p>试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。</p>
<p>但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？</p>
<pre><code>...
int <span class="built_in">test</span>_1 = <span class="number">10</span>, <span class="built_in">test</span>_2 = <span class="number">100</span>;
SWAP_V2(&amp;<span class="built_in">test</span>_1, &amp;<span class="built_in">test</span>_2);                    
<span class="built_in">printf</span>(<span class="string">"Now the test_1 is %d, test_2 is %d\n"</span>, <span class="built_in">test</span>_1, <span class="built_in">test</span>_2);
.../*恢复原值*/
SWAP_V2(&amp;<span class="built_in">test</span>_1, &amp;<span class="built_in">test</span>_1);
<span class="built_in">printf</span>(<span class="string">"Now the test_1 is %d\n"</span>, <span class="built_in">test</span>_1);   
</code></pre><p>会输出什么？:</p>
<pre><code>$: <span class="built_in">Now</span> the test_1 <span class="keyword">is</span> <span class="number">100</span>, test_2 <span class="keyword">is</span> <span class="number">10</span>
$: <span class="built_in">Now</span> the test_1 <span class="keyword">is</span> <span class="number">0</span>
</code></pre><p>对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的<code>SWAP_V3</code>亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap_final</span><span class="params">(<span class="keyword">int</span>* val_1, <span class="keyword">int</span>* val_2)</span>
</span>{
    <span class="keyword">if</span>(val_1 == val_2)
        <span class="keyword">return</span>;
    *val_1 ^= *val_2;
    *val_2 ^= *val_1;
    *val_1 ^= *val_2;
}
</code></pre><p>这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。<br>提示：可用<code>void*</code></p>
<p>与上面的情况类似，偶尔的不经意就会造成严重的后果:</p>
<pre><code><span class="built_in">int</span> combine_1(<span class="built_in">int</span>* dest, <span class="built_in">int</span>* <span class="built_in">add</span>)
{
    *dest += *<span class="built_in">add</span>;
    *dest += *<span class="built_in">add</span>;
    <span class="keyword">return</span> *dest;
}
<span class="built_in">int</span> combine_2(<span class="built_in">int</span>* dest, <span class="built_in">int</span>* <span class="built_in">add</span>)
{
    *dest = <span class="number">2</span>* (*<span class="built_in">add</span>);<span class="comment">//在不确定优先级时用括号是一个明智的选择</span>
    <span class="keyword">return</span> *dest;
}
</code></pre><p>上述两个函数的功能一样吗？恩看起来是一昂的</p>
<pre><code>int <span class="built_in">test</span>_3 = <span class="number">10</span>, <span class="built_in">test</span>_4 = <span class="number">100</span>;

combine_1(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_4);
<span class="built_in">printf</span>(<span class="string">"After combine_1, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
.../*恢复原值*/
combine_2(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_4);
<span class="built_in">printf</span>(<span class="string">"After combine_2, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
</code></pre><p>输出<br><code>$: After combine_1, test_3 = 210</code><br><code>$: After combine_2, test_3 = 210</code></p>
<p>如果两数相等呢？</p>
<pre><code>... /*恢复<span class="built_in">test</span>_3原值*/
combine_1(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_3);
<span class="built_in">printf</span>(<span class="string">"After second times combine_1, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
...
combine_2(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_3);
<span class="built_in">printf</span>(<span class="string">"After second times combine_2, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
</code></pre><p>输出<br><code>$: After second times combine_1, test_3 = 30</code><br><code>$: After second times combine_2, test_3 = 20</code><br>知道真相总是令人吃惊，指针也是那么令人又爱又恨。</p>
<h5 id="关于数组的那些事">关于数组的那些事</h5><p>数组和指针一样吗？<br><br><strong>不一样</strong><br><br>要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？</p>
<pre><code><span class="keyword">int</span> arr[<span class="number">10</span>] = {<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>};
<span class="keyword">int</span>* parr  = arr;
</code></pre><p>我们还是那句话，结合上下文，编译器推出 ‘arr’处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用’arr’时也总是将其当成是指向该数组内存块首位的指针。</p>
<pre><code>//int <span class="keyword">function</span>2(const int <span class="built_in">test</span>_arr[<span class="number">10</span>]
//int <span class="keyword">function</span>2(const int <span class="built_in">test</span>_arr[]) 考虑这三种写法是否一样
int <span class="keyword">function</span>2(const int* <span class="built_in">test</span>_arr)
{
    <span class="built_in">return</span> sizeof(<span class="built_in">test</span>_arr);
}
...
int size_out = sizeof(arr);
int size_<span class="keyword">in</span>  = <span class="keyword">function</span>2(arr);

<span class="built_in">printf</span>(<span class="string">"size_out = %d, size_in = %d\n"</span>, size_out, size_<span class="keyword">in</span>);
</code></pre><p><code>输出: size_out = 40, size_in = 8</code></p>
<p>这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而<code>arr</code>代表的是一个<strong>指向10个int类型的数组</strong>的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写</p>
<pre><code><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;arr;
</code></pre><p>此时<code>p</code>的类型就是一个<strong>指向含有10个元素的数组的指针</strong>,此时<code>(*p)[0]</code>产生的效果是<code>arr[0]</code>，也就是<code>parr[0]</code>，但是<code>(*p)</code>呢？这里不记录，结果是会溢出，为什么？</p>
<p>这就是数组与指针的区别与联系，但是既然我们可以使用像<code>parr</code>这样的指针，又为什么要写成<code>int (*p)[10]</code>这样丑陋不堪的模式呢？原因如下:</p>
<ul>
<li><p>回到最开始说过的传递方式，按值传递在传递<code>arr</code>时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个<strong>指向数组的指针</strong><br>这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同</p>
<pre><code><span class="keyword">int</span> arr_2[<span class="number">5</span>];
<span class="keyword">int</span> (*p_2)[<span class="number">5</span>] = &amp;arr_2;
<span class="keyword">float</span> arr_3[<span class="number">5</span>];
<span class="keyword">float</span> (*p_3)[<span class="number">5</span>] = &amp;arr_3;
</code></pre><p>如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。</p>
</li>
<li><p>这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。</p>
<ul>
<li><p>就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:</p>
<p>  <code>int dou_arr[5][3];</code><br>就这个二维数组而言，将5个每个为3个<code>int</code>类型的数组组合在一起，要想指向这个数组该怎么做？</p>
<pre><code><span class="atom">int</span> (*<span class="atom">p</span>)[<span class="number">3</span>]        = &amp;<span class="atom">dou_arr</span>[<span class="number">0</span>];
<span class="atom">int</span> (*<span class="atom">dou_p</span>)[<span class="number">5</span>][<span class="number">3</span>] = &amp;<span class="atom">dou_arr</span>;
<span class="atom">int</span> (*<span class="atom">what_p</span>)[<span class="number">3</span>]  = <span class="atom">dou_arr</span>;
</code></pre><p>实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制<br>对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 <strong>指向该数组元素的类型</strong>，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。</p>
</li>
</ul>
</li>
</ul>
<p>对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:</p>
<pre><code><span class="keyword">int</span>* arr_3[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
<span class="keyword">int</span>* p_4      = arr_3;

<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> == <span class="variable">%d</span> == <span class="variable">%d</span> ?\n"</span>, arr_3[<span class="number">2</span>], *(p_4 + <span class="number">2</span>), *(arr_3 + <span class="number">2</span>));
</code></pre><p><code>输出: 3 == 3 == 3 ?</code><br>实际上对于数组与指针而言， <code>[]</code>操作在大多数情况下都能有相同的结果，对于指针而言<code>*(p_4 + 2)</code>相当于<code>p_4[2]</code>，也就是说<code>[]</code>便是指针运算的语法糖，有意思的是<code>2[p_4]</code>也相当于<code>p_4[2]</code>，<code>&quot;Iamastring&quot;[2] == &#39;m&#39;</code>，但这只是娱乐而已，实际中请不要这么做，除非是<strong>代码混乱大赛</strong>或者某些特殊用途。<br><strong>在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于<code>[]</code>运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道</strong></p>
<p>在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用<code>char*</code>指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。</p>
<p>实际上，最简单的安全研究之一，便是利用溢出进行攻击。</p>
<p><strong>Advance:</strong>对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。</p>
<h4 id="0x05-C语言指针(Volume-2)">0x05-C语言指针(Volume-2)</h4><h5 id="内存的使用的那些事儿">内存的使用的那些事儿</h5><p>你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以<strong>共享</strong>使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的<strong>硬盘</strong>上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:</p>
<pre><code>...
<span class="keyword">int</span>  stay_here;
<span class="keyword">char</span> tran_to_int[<span class="number">100</span>];
<span class="built_in">printf</span>(<span class="string">"Address: %p\n"</span>, &amp;stay_here);

fgets(tran_to_int, <span class="keyword">sizeof</span>(tran_to_int), stdin);
<span class="built_in">sscanf</span>(tran_to_int, <span class="string">"%d"</span>, &amp;stay_here);

<span class="keyword">for</span>(;;)
{
    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, stay_here);
    getchar();
    ++stay_here;
}
...
</code></pre><p>对此程序(引用<a href="http://kmaebashi.com" target="_blank" rel="external">前桥和弥</a>的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的<code>stay_here</code>都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:</p>
<ul>
<li><p>通俗地说，fgets将输入流中由调用起，<code>stdin</code>输入的东西存入起始地址为<code>tran_to_int</code>的地方，并且最多读取<code>sizeof(tran_to_int)</code>个，并在后方<code>sscanf</code>函数中将刚才读入的数据按照<code>%d</code>的格式存入<code>stay_here</code>，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于<code>scanf</code>的问题</p>
<pre><code>scanf<span class="list">(<span class="string">"%d"</span>, <span class="keyword">&amp;stay_here</span>)</span><span class="comment">;</span>
</code></pre><p>这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是<strong>回车</strong>会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。</p>
</li>
</ul>
<h5 id="函数与函数指针的那些事">函数与函数指针的那些事</h5><p>事实上，函数名出现在赋值符号右边就代表着函数的地址</p>
<pre><code><span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int argc)</span></span>{ /*...*/
}
...
<span class="built_in">int</span> (*p_fun)(<span class="built_in">int</span>) = <span class="function"><span class="keyword">function</span></span>;
<span class="built_in">int</span> (*p_fuc)(<span class="built_in">int</span>) = &amp;<span class="function"><span class="keyword">function</span></span>;//和上一句意义一致
</code></pre><p>上述代码即声明并初始化了函数指针，<code>p_fun</code>的类型是<strong>指向一个返回值是int类型，参数是int类型的函数的指针</strong></p>
<pre><code>p_fun<span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
<span class="list">(<span class="keyword">*p_fun</span>)</span><span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
function<span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
</code></pre><p>上述三个代码的意义也相同，同样我们也能使用<strong>函数指针数组</strong>这个概念</p>
<pre><code><span class="keyword">int</span> (*p_func_arr[])(<span class="keyword">int</span>) = {func1, func2,};
</code></pre><p>其中<code>func1,func2</code>都是返回值为<code>int</code>参数为<code>int</code>的函数，接着我们能像数组索引一样使用这个函数了。</p>
<h5 id="C语言中malloc的那些事儿">C语言中malloc的那些事儿</h5><p>我们常常见到这种写法:</p>
<pre><code>int* pointer = <span class="list">(<span class="keyword">int*</span>)</span>malloc<span class="list">(<span class="keyword">sizeof</span><span class="list">(<span class="keyword">int</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>这有什么奇怪的吗？看下面这个例子:</p>
<pre><code><span class="keyword">int</span>* pointer_2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
</code></pre><p>哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候，<code>void*</code>这个类型还没有出现的时候，<code>malloc</code>返回的是<code>char*</code>的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与<code>void*</code>互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。</p>
<p><em>题外话:</em>C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。</p>
<h5 id="指针与结构体">指针与结构体</h5><pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> tag{
        <span class="keyword">int</span>  value;
        <span class="keyword">long</span> vari_store[<span class="number">1</span>];
}vari_struct;
</code></pre><p>乍一看，似乎是一个很中规中矩的结构体</p>
<pre><code>...
vari_struct  vari_1;
vari_struct* vari_p_1 = &amp;vari_1;
vari_struct* vari_p_2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vari_struct))(
</code></pre><p>似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法</p>
<pre><code><span class="keyword">int</span>          what_spa_want = <span class="number">10</span>;
vari_struct* vari_p_3 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vari_struct) + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*what_spa_want);
</code></pre><p>这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。<code>what_spa_want</code>解释为<strong>你需要多大的空间</strong>，即在一个结构体大小之外还需要多少的空间，空间用来存储<code>long</code>类型，由于分配的内存是连续的，故可以直接使用数组<code>vari_store</code>直接索引。<br>而且由于C语言中，编译器并不对数组做越界检查，故对于一个有<code>N</code>个数的数组<code>arr</code>，表达式<code>&amp;arr[N]</code>是被标准允许的行为，但是要记住<code>arr[N]</code>却是非法的。<br>这种用法并非是娱乐，而是成为了标准(<strong>C99</strong>)的一部分，运用到了实际中</p>
<h5 id="对于内存的理解">对于内存的理解</h5><p>在内存分配的过程中，我们使用<code>malloc</code>进行分配，用<code>free</code>进行释放，但这是我们理解中的分配与释放吗？<br>在调用<code>malloc</code>时，该函数或使用<code>brk()</code>或使用<code>nmap()</code>向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是<code>free</code>，与我们硬盘删除东西一样，实际上:</p>
<pre><code><span class="keyword">int</span>* value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">5</span>);
...
<span class="built_in">free</span>(value);
<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, value[<span class="number">0</span>]);
</code></pre><p>代码中，为什么在<code>free</code>之后，我又继续使用这个内存呢？因为<code>free</code>只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。<br>这便引申出几个问题:</p>
<ul>
<li>Bug更加难以发现，让我们假设，如果我们有两个指针<code>p1</code>,<code>p2</code>指向同一个内存，如果我们对其中某一个指针使用了<code>free(p1);</code>操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。</li>
<li>有可能会让某些问题更加简化，例如释放一个条条相连的链表域。</li>
</ul>
<p>总的来说，还是那句话C语言是一把双刃剑。</p>
<h4 id="Create_By_WuShengXin_@_2015">Create By WuShengXin @ 2015</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x05-C语言指针:(Volume-1)">0x05-C语言指针:(Volume-1)</h4><p>这似乎是一个很凝重的话题，但是它真的很有趣。</p>
<p><strong><em>1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的</em></strong></p>
<p><strong><em>2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及<code>sizeof</code></em></strong></p>
<p><strong><em>3. C语言最晦涩难明的就是它复杂的声明: `void (</em>signal(int sig, void (<em>func)(int)))(int)`,试试着把它改写成容易理解的形式</em></strong></p>
<p><strong><em>4. 对于指针，尽最大的限度使用<code>const</code>保护它，无论是传递给函数，还是自己使用</em></strong></p>
<p>先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: <code>NULL</code>，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):</p>
<pre><code><span class="hexcolor">#def</span>ine NULL <span class="number">0</span>
<span class="hexcolor">#def</span>ine NULL ((void*)<span class="number">0</span>)
</code></pre><p>有什么区别吗？看起来没什么区别都是<code>0</code>，只不过一个是常量，一个是地址为0的指针。</p>
<p>当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:</p>
<pre><code><span class="keyword">int</span>* temp_int_1 = <span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_2 = (<span class="keyword">void</span>*)<span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_3 = <span class="number">10</span>; <span class="comment">//出现警告</span>
</code></pre><p>为什么？为什么<code>0</code>可以赋值给指针，但是<code>10</code>却不行？他们都是常量。</p>
<p>因为C语言规定当处理上下文的编译器发现常量<code>0</code>出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。</p>
<p>回到最开始，对于<code>NULL</code>的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。</p>
<p>在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加<code>&#39;\0&#39;</code>，好这里又出现了一个0值。</p>
<p>对于某些人，在使用字符数组的时候总是分不清楚<code>NULL</code>与<code>&#39;\0&#39;</code>的区别而误用，在字符数组的末尾使用<code>NULL</code>是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。</p>
<h5 id="开胃菜已过">开胃菜已过</h5><p>对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参</p>
<pre><code>int <span class="function"><span class="keyword">function</span><span class="params">(int value)</span>
</span>{
        <span class="comment">/*...*/</span>
}
<span class="comment">//...</span>
<span class="function"><span class="keyword">function</span><span class="params">(11)</span></span>;
</code></pre><p>其中，<code>value</code>是形参，<code>11</code>是实参，我们知道场面上，C语言拥有两种传递方式:<strong>按值传递</strong>和<strong>按址传递</strong>，但是你是否有认真研究过？这里给出一个实质，其实C语言只有<strong>按值传递</strong>，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。<br>]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(1)---开篇]]></title>
    <link href="//wushxin.top/2015/05/12/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(1)/"/>
    <id>//wushxin.top/2015/05/12/我为什么学C(1)/</id>
    <published>2015-05-12T14:22:23.000Z</published>
    <updated>2015-06-21T03:36:04.981Z</updated>
    <content type="html"><![CDATA[<h1 id="我的C语言">我的C语言</h1><h2 id="本章更新于_2015/6/21_11:36:01">本章更新于 2015/6/21 11:36:01</h2><p><strong>正式接触编程，大概是一年连六个月吧，这真是一个令人着迷的领域</strong></p>
<h4 id="0x00-C语言前续工作">0x00-C语言前续工作</h4><p>正所谓，工欲善其事，必先利其器，把握住当下最强大的工具，能让我们在学习的道路上少走许多弯路，多吸取前人的失败经验，能让自己快速成长，因为成长总是在消耗我们的耐心以及生命。</p>
<p>入门或者精通或者应用，不管哪一方面，对于一个编程语言而言，最方便的还是使用一个<strong>IDE</strong>作为你的有力助手，什么事<strong>IDE</strong>？通俗而专业的说叫做<strong>集成开发环境</strong>，这个通过字面就能理解到了，就是所有其他的事情都不需要程序员操心，你需要操心的就是写出代码，至于代码完成之后的一系列工作，都不需要你来管，IDE一键帮你搞定。</p>
<p>当然，会有许多前辈告诉你，如果你想理解C语言，那你一定要使用最基层的东西来写，比如XXX编辑器配上XXX编译器，晕头转向之后更加茫然，本来就支离破碎的小心肝，又被粉碎了一次，撇开那些与当下不符合的幻想，活在现实中，选择一个适合你的<strong>IDE</strong>，逐渐适应它。</p>
<ul>
<li><p>讲几个著名的<strong>IDE</strong>，并给出建议，利器第一步：</p>
<ol>
<li><p>宇宙级的<strong>IDE</strong>: Visual Studio(2010~2013)，之所以说宇宙级，因为这是市面上最强大的集成开发环境，由微软公司出品，但是放在开头不是为了推荐他，而是为了警示大家不要使用它作为C语言的集成开发环境，因为它使用的是微软公司自己定制的C++编译器，也就是说，你的C语言代码会在C++的标准下编译运行，这就是一个十分不好的现象，即便是C++我依旧不喜欢使用Visual Studio，因为它的C++编译器总是和普通的标准有所出入。</p>
<p> 原归正传，Visual Studio的确不是一个好的C语言开发IDE，所以请另外选择一个。</p>
</li>
<li><p>老牌<strong>IDE</strong>: DevC++，这又是一个大家耳熟能详，经常能在老师手里看见的C语言教学利器，但是，它是C++的IDE，记住C于C++完全是两个世界的人，虽然C++宣称能全面兼容C程序，但是有些东西依旧是有所区别，体现在语法的兼容性上，后文会有提及。那为什么大学老师喜欢使用它呢？因为一本由清华大学出版社出版的《数据结构》，让无数人为之折服，其中赫然写着由于性能我们不能拘泥于小细节，故对于C++的特性<code>&amp;</code>引用，我们可以将其使用在C语言的语法中，就是这句话，让无数无知的学子扑向其中，再也分不清C与C++，看成谭浩强之后的，清华大学出版社又一诲人不倦的力作。</p>
<p> 所以，真爱编程，远离清华大学出版社，也请大家注意，不要使用DevC++这个IDE进行C语言程序的开发以及练习。</p>
</li>
<li><p>知名<strong>IDE</strong>: Code::Blocks，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是首推的C语言开发环境选择。</p>
</li>
<li><p>知名<strong>IDE</strong>: CodeLite，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是次推的C语言开发环境选择，因为使用起来稍微也有些额外的工作要做。</p>
</li>
<li><p>著名<strong>IDE</strong>: Xcode，是一个苹果电脑上的史诗级集成开发环境，虽然脱胎于C语言，但是由于某些原因，并不太建议使用其作为C语言的开发环境。 </p>
</li>
</ol>
</li>
<li><p>IDE的基本配置<br>利器第二步是对所选的IDE进行一些基本的配置，以及小科普。</p>
<ol>
<li><p>对于一个练习C语言的开发环境来说，选择合适的标准和编译器是很重要的，在Windows以及Linux操作系统下，我们还是使用<code>GCC</code>这个家伙比较多，开源，免费，且极其强大。当然你也可以选择<code>clang</code>，当然整个计算机领域中支持C语言的编译器并不止这两个，只不过这两个是开源免费，而且功能强大，十分适合作为个人开发以及无特殊需求的企业开发的选择。</p>
<p> 选择了编译器，我们开始讲标准：</p>
<p> 对于<code>GCC 5.1</code>以下的所有版本，都默认对C语言使用<code>C89</code>标准，但是我建议使用<code>C99</code>两者的差距，有一个极其明显的地方，便是<code>for</code>循环的使用</p>
<pre><code><span class="comment">/*C89:*/</span>
<span class="keyword">int</span> i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
<span class="comment">/*...*/</span>
</code></pre><p>…</p>
<pre><code><span class="comment">/*C99*/</span>
for<span class="comment">(int i = 0;i &lt; 10;++i)</span>
<span class="comment">/*...*/</span>
</code></pre><p> 这只是其中的一种差别，但是C99需要人为手动的开启，但是很多人有疑问，为什么有时候没有配置什么也能使用后面的语法？吴老师告诉你，这是因为你用了C++的文件进行C语言的开发，就像挂羊皮卖狗肉的道理。</p>
</li>
<li><p>开启C99</p>
<p>一般IDE的顶部都是一系列的标签，找到<code>工具/设置</code>，因为不同的IDE可能有不同的标签，总之在其中找到一个叫<strong>(编译器)Compiler</strong>之后，在其中的<strong>other option</strong>中加入以下:<code>-std=c99</code>，这便是开启C99的选项代码，完事之后保存即可。虽然说我们是中国人，但是毕竟这东西的外国人发明的，我们能看英文就看英文吧。</p>
</li>
</ol>
<ul>
<li><p>至此，利器成功配置。</p>
</li>
<li><p>当然最重要的还是内在，所以加油吧，虽然是一门很古老的语言，但是存在既有其道理。</p>
</li>
</ul>
</li>
</ul>
<h4 id="0x01-C语言序言">0x01-C语言序言</h4><p> 倒是觉得写代码首先不是语法，而是格式，任何时候任何地点，要是自己的代码难以理解，要么你是故意的，要么你就是菜菜</p>
<p> 一个难以被人理解的代码在我看来是没有太多的潜力的，但不排除故意为之的情况,也许很多人说这是强迫症，但是无论打开哪一个开源代码，你看到的都将是一个拥有规范的代码文件</p>
<p>也许有人说人不应该被限制，不应该拘泥于小节，但是当一个工程超过一千行，也许不用只需要不到五百行，就能完全暴露出代码规范的重要性，包括缩进，变量命名，接口存放，接口参数的规范之类，听起来似乎很虚<a href="https://code.google.com/p/google-styleguide/" target="_blank" rel="external">谷歌代码规范(翻墙后查看)</a></p>
<p>在我看来C语言的内建语法真是无比简洁，几乎存在既有道理，简洁不代表着不强大，强大的某些地方在近来渐渐复苏的Lisp身上也有体现。</p>
<p><code>if, for, while, switch</code></p>
<p></p><p>组成了每个C程序的半壁江山<br><br><code> “ + “ “ - “ “ * “ “ / “ “ % “ “ = “</code></p>
<p></p><p>组成了各式各样的算法计数<br><br><code>“&gt;&gt;” “&lt;&lt;” “|” “&amp;” “^” “~” “!”</code></p>
<p></p><p>让C语言有了更高效的算法以及更奇妙的思路<br><br><code>struct enum union #define return</code><br></p>
<p></p><p>而这些则让C语言在这乱世纷争中站稳了脚跟，并且一枝独秀<br><br><code>“{}” “()”</code><br></p>
<p></p><p>让代码不再无序混乱<br><br><code>“type * “ “&amp;” “()” “-&gt;”</code><br></p>
<p></p><p>让C语言在这个世界无处不在<br><code>“ . “ “[ ]” “ &lt; “ “ &gt; “ “ == “</code><br></p>
<a id="more"></a>
<p><strong>还记得他们吗？我想这一辈子都忘不了了</strong></p>
<h4 id="0x02-编程带给我的">0x02-编程带给我的</h4><p>是快乐而不是痛苦，如果你觉得编程痛苦，请放下你手头的工作，找找自己真正想要的，无论从什么角度来看，你都应该放弃令你痛苦的事情，花上三杯茶的时间，看看自己的心到底喜欢什么。</p>
<p>C语言可谓是让一个程序员最难以感受到自己进步的编程语言，一个黑窗口就让无数程序员再也走不出来。或者迷失，或者停滞不前，或者放弃，一个人最恐惧无助，甚至彷徨的时候，就是在努力之后却感受不到自己在进步，努力的白费是所有人不愿意看到的，但是太多人就着所谓前途而奋不顾身的投入这个事业，他们也许对计算机完全没有喜爱之心，埋头苦干，世人皆称<strong>爱读书的好孩子</strong>，但是这意义又在何处？即使最后你领着你觉得高的工资，站在了同学，朋友的前方，依然发现自己并没有得到满足，在我看来，让自己开心的才是最好的，不适合你的永远是最差的，即便能带来利益？何不花三杯茶的时间，想想自己到底适合何处。</p>
<p>在C语言的道路上，囊括了许多道天堑，并不是说这门语言比其他语言难，相反它十分符合人类的思维逻辑，但就是因为它存在的时间太久远，普通的使用于它于世界已经无甚大用，在现在这个高级语言遍地走的时代里，有用的只是那些将C语言发挥到极限的工程，不再是小窗口中写一个数据结构，一个算法，也许你觉得徒手写出一棵<strong>红黑树</strong>很了不起了？那也就是做成一个字典树，在一个浩大的工程中，一个虽重要却不起眼的小部分罢了，学完所有语法，却不知所措接下去该怎么做？有心人在无尽的探索之后发觉，啊！标准库！啊算法！嗯对了，还有各种各样的第三方扩展，以后呢？啊！操作系统！然而自学的路上充满着坎坷，艰辛，无助，烦恼，那又如何？喜欢就好。</p>
<p>所谓师傅领进门，修行在个人，这句话在我看来有两个重要点，却是现在大学生几乎缺失的。<strong>师傅</strong>一词告诉我们，要不耻下问，要善于询问，而不是伸手即来思想，”提问的智慧”在我看来是一门很重要的课程，特别是在当今信息时代。而更重要的是，先入为主的思想是极其可怕的，在这两年的自学历程里，见过太多后来者居上的事迹，当你一直认为自己一定比后辈强时，你就注定输了，所以不耻下问才是最重要的。但是如果师傅是那么容易找到的，那就不会有学校了，<strong>个人</strong>指的并不是孤军奋战，而是要善于自己发现问题，努力解决问题，这个过程可能少不了请教他人</p>
<p>编程可以是一种信仰，至少在我认为是这样的，把它当作信仰的人，它就能给你快乐，给你充实，当然也不要忘了现实，虽然现实中总是少不了加班的羁绊，但是如果是真心喜爱编程，又怎么会被这些困难所打败？但是C语言真的不是一门容易精通的语言。</p>
<h4 id="0x03-C代码">0x03-C代码</h4><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"That is Right Style\n"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>在一个标准的C语言程序中，最特殊的莫过于main函数了，而说到底它就是一个函数而已，仅仅因为它地位特殊拥有第一执行权力，换句话说，难道因为一个人是省长它就不是人类了？所以函数该有的它都应该有，那么函数还有什么呢？</p>
<p>函数大体上分为<a href="http://www.greenend.org.uk/rjk/tech/inline.html" target="_blank" rel="external">内联函数(C99)</a><strong>(内联函数并非C++专属，C语言亦有，具体见前方链接)</strong>和非内联的普通函数，它们之间有一个很明显的特点(一般情况下)，那就是不写原型直接在main函数上方定义，即使不加’inline’关键字，也能被编译器默认为内联函数，但之后带来的某些并发问题就不是编译器考虑的了。</p>
<p>普通函数正确的形式应该为声明与定义分离，声明就是一个函数原型，函数原型应该有一个函数名字，一个参数列表，一个返回值类型和一个分号。定义就是函数的内在，花括号内的就是函数的定义:</p>
<pre><code><span class="comment">//...</span>
<span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">float</span> arg_2)</span></span>;
<span class="comment">//...</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>
</span>{
  <span class="keyword">int</span> output = function(<span class="number">11</span>, <span class="number">22.0</span>);
  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,output);
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">float</span> arg_2)</span>
</span>{
 <span class="keyword">int</span>    return_value  = arg_1;
 <span class="keyword">float</span>  temp_float    = arg_2;
 <span class="keyword">return</span> return_value;
}    
</code></pre><p>依上所述，当非必要时，在自己编写函数的时候请注意在开头(main函数之前)写上你的函数的原型，并且在末尾(<code>main</code>函数之后)写上你的函数定义，这是一个很好的习惯以及规范。所谓代码整洁之道，就是如此。</p>
<p>函数的另一种分类是，有返回值和无返回值，返回值的类型可以是内建<strong>(build-in)</strong>的也可以是自己定义的(<code>struct, union</code>之类)，无返回值则是<code>void</code>。</p>
<ol>
<li>为什么我们十分谴责<code>void main()</code>这种写法？因为这完全是中国式教育延伸出来的谭式写法，<strong>main函数</strong>的返回值看似无用，实际上是由操作系统接收，在Windows操作系统下也许无甚”大碍”(实际上有),当你使用Linux的过程中你会清晰的发现一个C语言程序的<strong>main返回值</strong>关系到一个系统是否能正常，高效的运行，这里稍微提一句，<code>0</code>在Linux程序管道通信间代表着无错可行的意思。所以请扔掉<code>void main</code>这种写法。</li>
<li><p>为什么我们对 <code>main()</code>这种省略返回值的写法置有微词？能发明这种写法的人，必定是了解了，在C语言中，如果一个函数不显式声明自己的返回值，那么会被缺省认为是<code>int</code>，但这一步是由编译器掌控，然而C语言设计之初便是让我们对一切尽可能的掌握，而一切不确定因子我们都不应该让它存在。其次有一个原则，能自己做的就不要让编译器做。</p>
</li>
<li><p>为什么我们对参数放空置有不满(int main())?在C语言中，一个函数的参数列表有三种合法形态:<br></p>
<pre><code><span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(void)</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int arg_n)</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int arg_n, ...)</span></span>;
</code></pre><p> 第一种代表拥有未知个参数,第二种代表没有参数，第三种代表有一个参数，第四种代表拥有未知个参数，并且第一个参数类型为int,未知参数在C语言中有一个解决方案就是，可变长的参数列表，具体参考C标准库，在此我们解释的依据就是，我们要将一切都掌控在自己的手中，我们不在括号内填写参数，代表着我们认为一开始的意思是它为空，正因此我们就应该明确说明它为void,而不该让它成为一个未知参数长度的函数，如此在你不小心传入参数的时候，编译器也无法发现错误。</p>
</li>
<li><p><code>int main(int argc, char* argv[])</code> 和 <code>int main(void)</code>才是我们该写的C语言标准形式<br><br>对于缩进，除了编译器提供的符号缩进之外，我们可以自己给自己一个规范(请少用或者不用Tab)，比如每一块代码相教上一个代码块有4格的缩进。<br><br>对于学习C语言，请使用.c文件以及C语言编译器练习以及编写C程序，请不要再使用C++的文件编写C语言程序，并且自圆其说为了效率而使用C++的特性在C语言中，我们是祖国的下一代，是祖国的未来，请不要让自己毁在当下，珍爱编程，远离清华大学出版社</p>
<p> 之所以如此叙述，并不是因为情绪，而是当真如此，下方代码:</p>
<pre><code><span class="comment">/*file: test.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> SIZES 5</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span>* c_pointer = <span class="built_in">malloc</span>(SIZES * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="comment">/*发生了一些事情*/</span>
    <span class="built_in">free</span>(c_pointer);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p> 这是一段标准的C语言程序，但是它能在C++个编译器下编译运行吗？换句话说当你将文件扩展名由<code>.c</code>改为<code>.cpp</code>之后，它能编译通过吗？答案是不能。</p>
<p> 为什么？答案是C++并不支持<code>void*</code>隐式转换为其他类型的指针，但是C语言允许。还有许许多多C于C++不相同的地方，兴许有人说C++是C的超集，但我并不这么认为，一门语言的出现便有它的意义所在，关键在于我们如何发挥它的最大优势，而不是通过混淆概念来增强实用性</p>
</li>
<li><p>程序式子的写法</p>
<p> 一个人活在世界上，时时刻刻都注意着自己的言行举止，而写程序也是如此，对于一个规范的能让别人读懂的程序而言，我们应该尽可能减少阻碍因子，例如:</p>
<pre><code><span class="keyword">int</span> main(void)
{<span class="keyword">int</span> complex_int=<span class="number">100</span>;
<span class="keyword">int</span> i,j,k,<span class="keyword">x</span>;
<span class="keyword">for</span>(<span class="keyword">int</span> temp=<span class="number">0</span>;temp&lt;complex_int;++temp){k=temp;
<span class="keyword">x</span>=k+complex_int;}
<span class="keyword">printf</span>(complex_int=<span class="string">"<span class="variable">%d</span> is k=<span class="variable">%d</span> x=<span class="variable">%d</span>\n"</span>,complex_int,k,<span class="keyword">x</span>);
<span class="keyword">return</span> <span class="number">0</span>;}
</code></pre><p>对于上述的代码，我总是在班级里的同学手下出现，但这段代码除了让别人困惑以外，自己在调试的时候也是十分不方便，每每遇到问题了，即便IDE提示了在某处错误，你也找不到问题所在，经常有人来问我哪里错了，大部分情况都是少了分号，括号，或者作用域超过，原因在哪？</p>
<p> 要是一开始将代码写清楚了，这种情况简直是凤毛麟角，想遇上都难。对于一个代码而言，我们应该注意让其变得清晰。</p>
<ul>
<li><p>等号两边使用空格：</p>
<pre><code><span class="keyword">int</span> complex_int = <span class="number">100</span>;
</code></pre></li>
<li><p>使用多个变量的声明定义，或者函数声明定义，函数使用时，注意用空格分开变量：</p>
<pre><code><span class="keyword">int</span> i, j, k, x;<span class="comment">//但是十分不建议这么声明难以理解意义的变量</span>
<span class="built_in">printf</span>(<span class="string">"complex_int = %d is k = %d x = %d\n"</span>, complex_int, k, x);
<span class="function"><span class="keyword">void</span> <span class="title">present</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">double</span> arg_2)</span></span>;
</code></pre></li>
<li><p>对于一个清晰的程序而言，我们要让每一个步骤清晰且有意义，这就要求我们在编写程序的时候尽量能让代码看起来结构化，或者整体化。尽量让每个程序式子为一行，如果有特别的需要让多个式子写在同一行，可以使用<code>,</code>操作符进行组合，但是会让程序更难理解，日后调试的时候也更难发现错误。</p>
<pre><code><span class="comment">/*Style 1*/</span>    
for(int <span class="variable">temp =</span> <span class="number">0</span>;temp &lt; complex_int;++temp)
{
    <span class="variable">k =</span> temp;
    <span class="variable">x =</span> k + complex_int;
}
<span class="comment">/*Style 2*/</span>
for(int <span class="variable">temp =</span> <span class="number">0</span>;temp &lt; complex_int;++temp){
    <span class="variable">k =</span> temp;
    <span class="variable">x =</span> k + complex_int;
}
</code></pre><p>对于上方的代码，是C语言代码花括号的两种风格，最好能选择其中一种作为自己的编程风格，这样能让你的程序看起来更加清晰，混合使用的利弊并不好说，关键还是看个人风格。</p>
</li>
<li><p>对于作用域而言，在C语言中有一个经常被使用的特例，当一个条件语句，或者循环只有一条语句的时候，我们常常省略了花括号<code>{}</code>，而是仅仅使用一个分号作为结尾，这在很多情况下让代码不再啰嗦：</p>
<pre><code><span class="keyword">if</span>(pointo_int == NULL)
    fprintf(stderr, <span class="string">"The pointer is NULL!\n"</span>);
<span class="keyword">else</span>
{
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>,*pointo_int);
    pointo_int = pointo_int-&gt;<span class="keyword">next</span>;
}
</code></pre><p>在这段代码中<code>if</code>语句下方的代码并没有使用<code>{}</code>运算符进行指明，但是根据语法，该语句的确是属于<code>if</code>语句的作用范围内，如果我们此时写上了<code>{}</code>反而会令代码看起来过于啰嗦。但是有的时候，这条特性并不是那么的有趣，当使用嵌套功能的时候，还是建议使用<code>{}</code>进行显式的范围规定，而不是使用默认的作用域：</p>
<pre><code>for<span class="comment">(int i = 0;i&lt; 10;++i)</span>
    for<span class="comment">(int k = 0;k &lt; 10;++k)</span>
        <span class="keyword">while</span><span class="comment">(flag != 1)</span>
            set_value<span class="comment">(arr[i][k])</span>;
</code></pre><p>这段代码，看起来十分简洁，但是确实是一个很大的隐患，当我们要调试这段代码的时候，总是需要修改它的构造，而这就带来了潜在的隐患。所以建议在使用嵌套的时候，无论什么情况，都能使用<code>{}</code>进行包装。</p>
</li>
</ul>
</li>
</ol>
<p><strong>综上所述，在开始编写一个标准C语言程序的时候，请先把下面这些东西写上:</strong><br></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>对于<code>main</code>的参数，有兴趣的可以查阅<a href="http://wrestlewsx.github.io/C++流操作(续)/" target="_blank" rel="external">我的文章</a>，或者自行谷歌，在此问题上百度也是可以的。</p>
<h4 id="0x04-C语言变量">0x04-C语言变量</h4><p>C语言在明面上将数的变量分为两类，<strong>整型变量</strong>以及<strong>浮点数</strong>，对应着现实世界的整数和小数。</p>
<ul>
<li><p>首先是整数，使用了这么多的C语言之后，每当在使用整数之时都会将其想象成二进制的存在，而不是十进制。原因在于，这是程序的本质所在，稍有研究编译器工作原理的都会发现，在编译器处理乘法乃至除法的时候，优秀的编译器总会想方设法的加快程序的速度，毫无疑问在所有运算中移位运算是最快速的”乘法”以及”除法”: <br><br><code>1&lt;&lt;2 == 4</code> ,<code>8&gt;&gt;2 == 2</code></p>
<p>  而正常一个乘法相当于十数次的加法运算的时间消耗，移位则不用<strong>(除法的消耗更大，但是随着CPU的进步，这些差距正在逐渐缩小，就目前来看依旧是有着不小的差距但无论如何优化，乘法时间都会大于加法)</strong>。正如前面所说，C语言设计之初便是给了程序员所有的权利，而程序员要做的就是掌控所有能掌控的，即便是数的计算亦是如此，比如在优秀的编译器看来:<br><br>  <code>2*7 ====&gt; (2&lt;&lt;3) - 2</code><br><br>  <code>5*31 ====&gt; (5&lt;&lt;5) - 5</code><br><br>  毫无疑问经过编译器优化后的代码此前者要快许多。这就是为什么我们要将一个数看作二进制，这不仅仅是表面，而是要在深层次的认为它是二进制，总体来说C语言的整型是非常简洁明了的总体分为 <em>有符号</em> 和 <em>无符号</em>，很好理解只需要注意不要让无符号数进行负数的运算，这里有一个原则，可以很好的规避这种无意之过，<strong>不把无符号类型变量和有符号类型变量放于同一运算中</strong>，时刻记得保持式子的类型一致是设计时的保障。</p>
</li>
<li><p>浮点数，由于实数域可以看作稠密的，故除了整数以外，还有无数的小数，而小数在计算机中如何表示？一种无限的状态是无法在计算机中被精确表示，所以有了浮点法，关于浮点法可以参考书籍<a href="http://www.amazon.cn/计算机科学丛书-深入理解计算机系统-布莱恩特/dp/B004BJ18KM" target="_blank" rel="external">《深入理解计算机系统》</a>。<br>这里介绍的是在C语言中我们应该如何正确使用浮点数？很多人(包括我)在初作之时总是想当然的以为计算机是无所不能的，连人类都无法完全表达出来的小数计算机一定可以，实际上并非如此，在这里我可以说，计算机只是近似表达，而最大的忌讳的便是将两个浮点数进行比较，此处介绍一种浮点数常用的比较方法，精确度法:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> DISTANCE 0.00000001</span>
...
<span class="keyword">float</span> f_x_1 = <span class="number">20.5</span>;
<span class="keyword">float</span> f_x_2 = <span class="number">19.5</span>;
<span class="keyword">if</span>(f_x_1 - f_x_2 &lt; DISTANCE)
    <span class="built_in">printf</span>(<span class="string">"They are Equal\n"</span>);
<span class="keyword">else</span>
    <span class="built_in">printf</span>(<span class="string">"Different\n"</span>);
</code></pre><p>所以说，在很大程度上，当你在程序中使用了浮点数，又直接使用浮点数进行比较，却发现始终无法达到预期效果，那么你可以检查一下，是否是这个原因，在这一点上，不得不说是C语言的一个缺憾。<br></p>
</li>
<li><p>指针变量，是一种比较特别的变量，以至于总是对它进行特别对待。这里有几个原则:</p>
<ul>
<li>两个不相关的指针进行加减操作是无意义的</li>
<li>始终确保自己能够找到分配的内存</li>
<li>无论何时何地何种情况，都要记住，不使用未初始化的指针，不让未使用的内存持续存在。</li>
</ul>
<p>指针在不同位的操作系统上的大小是不一样的，但是在同一个操作系统下，无论什么类型的指针都是相同大小，这涉及到指针的寻址问题，<strong>(题外话:C语言的寻址实际上使用了汇编语言的间接寻址，有兴趣的可以自行尝试，方法之一，使用gcc编译器的汇编选项，产生汇编代码，进行一一比对)</strong>，对于寻址一个笼统一些的说法便是<br><br><code>4Byte = 32bit</code><br><br><code>2^32 = 4G</code><br><br>所以32位的操作系统下C语言指针:</p>
<pre><code>...
size_t what = <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);
<span class="built_in">printf</span>(<span class="string">"%d"</span>, what);
...
</code></pre><p>输出:<code>$root@mine: 4</code><br><br>对于大部分使用者来说，指针主要用来降低内存消耗以及提高运算效率的，这里设计许多学问，我也无法一一展示，比较有意思也常用的两个东西便是递增以及语法糖:<code>++, -&gt;</code></p>
<pre><code>...
<span class="keyword">int</span> dupli_of_me[<span class="number">10</span>] = {<span class="number">0</span>};<span class="comment">//也可以使用库函数memset()进行置0</span>
<span class="keyword">int</span> *point_to_me = dupli_of_me;
<span class="keyword">int</span> me = <span class="number">100</span>;
<span class="keyword">while</span>(point_to_me &lt; (dupli_of_me + <span class="number">10</span>))
    *point_to_me++ = me;
</code></pre><p>其中<code>*point_to_me++ = me;</code>在C语言应用广泛它相当于是:</p>
<pre><code>*point_to_me = <span class="keyword">me</span>;
point_to_me++;
</code></pre><p>的语法糖，对于<code>++</code>，在非必要的情况下，请使用前缀递增，而非后缀递增，原因是消耗问题，仔细想想这两种递增的区别在何处？<br>前缀递增总是在原数上进行递增操作，然而后缀递增呢？它首先拷贝一份原数放于别处，并且递增这份拷贝，在原数进行的操作完毕后，将这份拷贝再拷贝进原数取代它，此中的操作涉及的更多，<strong>所以在非必要的情况下，请使用前缀递增而不是后缀递增(递减也是同样的道理)</strong><br><br><code>-&gt;</code>则是在结构体上使用的非常广泛:</p>
<pre><code>typedef struct <span class="built_in">data</span>{
    int test;
    struct <span class="built_in">data</span><span class="subst">*</span> next;
}my_struct;
<span class="attribute">...</span>
my_struct temp;
my_struct <span class="subst">*</span>ptemp <span class="subst">=</span> <span class="subst">&amp;</span>temp;
ptemp<span class="subst">-&gt;</span>test <span class="subst">=</span> <span class="number">100</span>;
ptemp<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
<span class="keyword">if</span>(temp<span class="built_in">.</span>test <span class="subst">==</span> <span class="number">100</span>)
    printf(<span class="string">"Correctly!\n"</span>);
<span class="keyword">else</span>
    printf(<span class="string">"That is impossible!\n"</span>);
<span class="attribute">...</span>
</code></pre><p>可以很清楚的看出其实<code>ptemp-&gt;test</code>便是<code>(*ptemp).test</code>的语法糖</p>
</li>
<li><p>变量限定</p>
<p>  <code>const</code> 是最常用的变量限定符，它的意思是告诉编译器，这个变量或者对象在初始化以后不能被改变，常用它来保护一些必要的返回值，参数以及常量的定义。</p>
<p>  <code>volatile</code> 这个关键字常常被C语言教材所忽略，它很神秘。实际上确实如此，他的作用的确很神秘：一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗的说就是，<strong>告诉编译器，不要把你的那一套优化策略用在我身上</strong>。</p>
<pre><code><span class="comment">/* 此时我们将编译器优化等级提高到 -O2 */</span>
<span class="keyword">int</span>          test_num   = <span class="number">100</span>; <span class="comment">//测试一个迭代加法</span>
<span class="keyword">int</span>          nor_result = <span class="number">0</span>;
<span class="keyword">volatile</span> <span class="keyword">int</span> vol_result = <span class="number">0</span>;
<span class="comment">/* 测试无volatile限定下，该程序的耗时 */</span>            
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;++i)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10000</span>;++j)
            nor_result += test_num;
</code></pre><p>接下来就是测试<code>volatile</code>限定下的代码</p>
<pre><code><span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>;<span class="built_in">i</span> &lt; <span class="number">10000</span>;++<span class="built_in">i</span>)
    <span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="number">0</span>;<span class="built_in">j</span> &lt; <span class="number">10000</span>;++<span class="built_in">j</span>)
            vol_result += test_num;
</code></pre><p>在使用一些手段后，得到运行时间，可以很清晰的看出差别，在我的机器上，<code>i5-4CPU</code>，得到的结果是后者比前者慢大概十五倍。<br>从某一些方向上证明了，volatile的一些作用，比如调试的时候，或者一些特殊用途。涉足不多，故不记录。</p>
</li>
<li><p>变量说明</p>
<p><code>extern</code> 用于将不同文件的，带有外部链接性的变量引用到本文件中。所谓外部链接性就是可以被除本文件外的其他文件<strong>“看见”</strong>的变量，如全局变量，使用方法：</p>
<pre><code><span class="comment">/* 以下为一个工程内可见 */</span>
<span class="comment">/*file1.c*/</span>
<span class="keyword">int</span> glo_show;<span class="comment">//对于该全局变量来说，它们在声明时无初始化，则默认初始为0</span>
<span class="keyword">int</span> glo_print = <span class="number">10</span>;<span class="comment">//声明定义完成后，自动分配内存以存储信息    </span>
...

<span class="comment">/* file2.c */</span>
<span class="keyword">extern</span> glo_print; <span class="comment">//仅仅是引用名字，并不会额外分配空间</span>
                  <span class="comment">//所以，只需要写正确变量名字即可，后方的初始化无须完全</span>
                  <span class="comment">//因为变量的初始化定义只能有一次。</span>

<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"The Globle Value is %d \n"</span>, glo_print);
}
</code></pre><p>  <code>auto</code> 可以姑且忽略，因为没有什么实际意义。</p>
<h4 id="Create_By_WuShengXin_@_2015">Create By WuShengXin @ 2015</h4></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="我的C语言">我的C语言</h1><h2 id="本章更新于_2015/6/21_11:36:01">本章更新于 2015/6/21 11:36:01</h2><p><strong>正式接触编程，大概是一年连六个月吧，这真是一个令人着迷的领域</strong></p>
<h4 id="0x00-C语言前续工作">0x00-C语言前续工作</h4><p>正所谓，工欲善其事，必先利其器，把握住当下最强大的工具，能让我们在学习的道路上少走许多弯路，多吸取前人的失败经验，能让自己快速成长，因为成长总是在消耗我们的耐心以及生命。</p>
<p>入门或者精通或者应用，不管哪一方面，对于一个编程语言而言，最方便的还是使用一个<strong>IDE</strong>作为你的有力助手，什么事<strong>IDE</strong>？通俗而专业的说叫做<strong>集成开发环境</strong>，这个通过字面就能理解到了，就是所有其他的事情都不需要程序员操心，你需要操心的就是写出代码，至于代码完成之后的一系列工作，都不需要你来管，IDE一键帮你搞定。</p>
<p>当然，会有许多前辈告诉你，如果你想理解C语言，那你一定要使用最基层的东西来写，比如XXX编辑器配上XXX编译器，晕头转向之后更加茫然，本来就支离破碎的小心肝，又被粉碎了一次，撇开那些与当下不符合的幻想，活在现实中，选择一个适合你的<strong>IDE</strong>，逐渐适应它。</p>
<ul>
<li><p>讲几个著名的<strong>IDE</strong>，并给出建议，利器第一步：</p>
<ol>
<li><p>宇宙级的<strong>IDE</strong>: Visual Studio(2010~2013)，之所以说宇宙级，因为这是市面上最强大的集成开发环境，由微软公司出品，但是放在开头不是为了推荐他，而是为了警示大家不要使用它作为C语言的集成开发环境，因为它使用的是微软公司自己定制的C++编译器，也就是说，你的C语言代码会在C++的标准下编译运行，这就是一个十分不好的现象，即便是C++我依旧不喜欢使用Visual Studio，因为它的C++编译器总是和普通的标准有所出入。</p>
<p> 原归正传，Visual Studio的确不是一个好的C语言开发IDE，所以请另外选择一个。</p>
</li>
<li><p>老牌<strong>IDE</strong>: DevC++，这又是一个大家耳熟能详，经常能在老师手里看见的C语言教学利器，但是，它是C++的IDE，记住C于C++完全是两个世界的人，虽然C++宣称能全面兼容C程序，但是有些东西依旧是有所区别，体现在语法的兼容性上，后文会有提及。那为什么大学老师喜欢使用它呢？因为一本由清华大学出版社出版的《数据结构》，让无数人为之折服，其中赫然写着由于性能我们不能拘泥于小细节，故对于C++的特性<code>&amp;</code>引用，我们可以将其使用在C语言的语法中，就是这句话，让无数无知的学子扑向其中，再也分不清C与C++，看成谭浩强之后的，清华大学出版社又一诲人不倦的力作。</p>
<p> 所以，真爱编程，远离清华大学出版社，也请大家注意，不要使用DevC++这个IDE进行C语言程序的开发以及练习。</p>
</li>
<li><p>知名<strong>IDE</strong>: Code::Blocks，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是首推的C语言开发环境选择。</p>
</li>
<li><p>知名<strong>IDE</strong>: CodeLite，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是次推的C语言开发环境选择，因为使用起来稍微也有些额外的工作要做。</p>
</li>
<li><p>著名<strong>IDE</strong>: Xcode，是一个苹果电脑上的史诗级集成开发环境，虽然脱胎于C语言，但是由于某些原因，并不太建议使用其作为C语言的开发环境。 </p>
</li>
</ol>
</li>
<li><p>IDE的基本配置<br>利器第二步是对所选的IDE进行一些基本的配置，以及小科普。</p>
<ol>
<li><p>对于一个练习C语言的开发环境来说，选择合适的标准和编译器是很重要的，在Windows以及Linux操作系统下，我们还是使用<code>GCC</code>这个家伙比较多，开源，免费，且极其强大。当然你也可以选择<code>clang</code>，当然整个计算机领域中支持C语言的编译器并不止这两个，只不过这两个是开源免费，而且功能强大，十分适合作为个人开发以及无特殊需求的企业开发的选择。</p>
<p> 选择了编译器，我们开始讲标准：</p>
<p> 对于<code>GCC 5.1</code>以下的所有版本，都默认对C语言使用<code>C89</code>标准，但是我建议使用<code>C99</code>两者的差距，有一个极其明显的地方，便是<code>for</code>循环的使用</p>
<pre><code><span class="comment">/*C89:*/</span>
<span class="keyword">int</span> i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
<span class="comment">/*...*/</span>
</code></pre><p>…</p>
<pre><code><span class="comment">/*C99*/</span>
for<span class="comment">(int i = 0;i &lt; 10;++i)</span>
<span class="comment">/*...*/</span>
</code></pre><p> 这只是其中的一种差别，但是C99需要人为手动的开启，但是很多人有疑问，为什么有时候没有配置什么也能使用后面的语法？吴老师告诉你，这是因为你用了C++的文件进行C语言的开发，就像挂羊皮卖狗肉的道理。</p>
</li>
<li><p>开启C99</p>
<p>一般IDE的顶部都是一系列的标签，找到<code>工具/设置</code>，因为不同的IDE可能有不同的标签，总之在其中找到一个叫<strong>(编译器)Compiler</strong>之后，在其中的<strong>other option</strong>中加入以下:<code>-std=c99</code>，这便是开启C99的选项代码，完事之后保存即可。虽然说我们是中国人，但是毕竟这东西的外国人发明的，我们能看英文就看英文吧。</p>
</li>
</ol>
<ul>
<li><p>至此，利器成功配置。</p>
</li>
<li><p>当然最重要的还是内在，所以加油吧，虽然是一门很古老的语言，但是存在既有其道理。</p>
</li>
</ul>
</li>
</ul>
<h4 id="0x01-C语言序言">0x01-C语言序言</h4><p> 倒是觉得写代码首先不是语法，而是格式，任何时候任何地点，要是自己的代码难以理解，要么你是故意的，要么你就是菜菜</p>
<p> 一个难以被人理解的代码在我看来是没有太多的潜力的，但不排除故意为之的情况,也许很多人说这是强迫症，但是无论打开哪一个开源代码，你看到的都将是一个拥有规范的代码文件</p>
<p>也许有人说人不应该被限制，不应该拘泥于小节，但是当一个工程超过一千行，也许不用只需要不到五百行，就能完全暴露出代码规范的重要性，包括缩进，变量命名，接口存放，接口参数的规范之类，听起来似乎很虚<a href="https://code.google.com/p/google-styleguide/">谷歌代码规范(翻墙后查看)</a></p>
<p>在我看来C语言的内建语法真是无比简洁，几乎存在既有道理，简洁不代表着不强大，强大的某些地方在近来渐渐复苏的Lisp身上也有体现。</p>
<p><code>if, for, while, switch</code></p>
<p><p>组成了每个C程序的半壁江山<br><br><code> “ + “ “ - “ “ * “ “ / “ “ % “ “ = “</code></p>
<p><p>组成了各式各样的算法计数<br><br><code>“&gt;&gt;” “&lt;&lt;” “|” “&amp;” “^” “~” “!”</code></p>
<p><p>让C语言有了更高效的算法以及更奇妙的思路<br><br><code>struct enum union #define return</code><br></p>
<p><p>而这些则让C语言在这乱世纷争中站稳了脚跟，并且一枝独秀<br><br><code>“{}” “()”</code><br></p>
<p><p>让代码不再无序混乱<br><br><code>“type * “ “&amp;” “()” “-&gt;”</code><br></p>
<p><p>让C语言在这个世界无处不在<br><code>“ . “ “[ ]” “ &lt; “ “ &gt; “ “ == “</code><br></p>]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下Qt5配置]]></title>
    <link href="//wushxin.top/2015/05/10/Linux%E4%B8%8BQt5%E9%85%8D%E7%BD%AE/"/>
    <id>//wushxin.top/2015/05/10/Linux下Qt5配置/</id>
    <published>2015-05-09T23:48:55.000Z</published>
    <updated>2015-05-09T23:53:42.972Z</updated>
    <content type="html"><![CDATA[<h2 id="Linux_of_Qt5">Linux of Qt5</h2><p></p><p>在Ubuntu编译Qt5工程时出现了<br><br><code>can not find -lGL</code><br></p>
<p></p><p>这是为什么?在Qt4时代并没有这种情况<br></p>
<p></p><p>经过查找,发现Qt5在这个版本自动加入了openGL的支持,而有的平台并没有默认拥有<br><br><strong>(Windows默认有openGL,Linux却没有完全)<strong></strong></strong></p>
<p></p><p>那么我们可以通过安装 <code>libglut-dev</code> 来进行修复<br><br><code>sudo apt-get install libglut-dev</code><br><br></p>
<p></p><p>稍微解读一下也能知道-lGL==&gt;-linkopenGL的意思</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linux_of_Qt5">Linux of Qt5</h2><p></p><p>在Ubuntu编译Qt5工程时出现了<br><br><code>can not find -lGL</code><br></p>
<p></p><p>这是为什么?在Qt4时代并没有这]]>
    </summary>
    
      <category term="Liunx" scheme="//wushxin.top/tags/Liunx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python-lib安装]]></title>
    <link href="//wushxin.top/2015/05/10/Python-lib%E5%AE%89%E8%A3%85/"/>
    <id>//wushxin.top/2015/05/10/Python-lib安装/</id>
    <published>2015-05-09T23:48:28.000Z</published>
    <updated>2015-05-10T14:22:44.480Z</updated>
    <content type="html"><![CDATA[<h1 id="Python">Python</h1><h2 id="安装第三方库(Linux::Ubuntu_14-04_LTS)">安装第三方库(Linux::Ubuntu 14.04 LTS)</h2><p>   关于一个gui的库 SimpleGUICS2Pygame <br><br>   所有的命令均在 root 权限下执行 <br></p>
<h3 id="安装前提:">安装前提:</h3><ol>
<li>使用easy_install 工具 <code>apt-get install easy_install</code></li>
<li>安装pip <code>easy_install pip</code></li>
</ol>
<h3 id="开始安装">开始安装</h3><ol>
<li>在 <a href="https://pypi.python.org/pypi/SimpleGUICS2Pygame" target="_blank" rel="external">https://pypi.python.org/pypi/SimpleGUICS2Pygame</a> 下载.egg格式的安装包 <br></li>
<li>使用命令 <code>easy_install name.egg #name.egg 为下载的第三方库的egg包名称</code></li>
<li>我们这里可以使用 <code>easy_install *.egg #代表安装所有的egg包,方便快捷,不用输入完整的名字</code></li>
<li>我们可以通过 <code>pip freeze</code> 查看所安装的包</li>
</ol>
<h3 id="使用错误">使用错误</h3><ul>
<li><p>当我们 <code>import simplegui</code>时,却出现 <code>...importError: No module named simplegui</code> <br><br>此时,我们应该使用这个语句块替换: <br></p>
<pre><code><span class="string">try:</span>
    <span class="keyword">import</span> simplegui 
<span class="string">except:</span>
    <span class="keyword">import</span> SimpleGUICS2Pygame.simpleGUICS2Pygame <span class="keyword">as</span> simplegui
</code></pre></li>
</ul>
<p>· 作者给出的解释是由于内部冲突所以会导致这种现象的产生</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Python">Python</h1><h2 id="安装第三方库(Linux::Ubuntu_14-04_LTS)">安装第三方库(Linux::Ubuntu 14.04 LTS)</h2><p>   关于一个gui的库 SimpleGUICS2Pygame <]]>
    </summary>
    
      <category term="Python" scheme="//wushxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <link href="//wushxin.top/2015/05/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>//wushxin.top/2015/05/10/Python学习笔记/</id>
    <published>2015-05-09T23:48:13.000Z</published>
    <updated>2015-05-10T14:17:51.926Z</updated>
    <content type="html"><![CDATA[<h2 id="Python学习笔记之基础">Python学习笔记之基础</h2><h3 id="Python缩进">Python缩进</h3><p>1. Python用相同缩进来代表同一个代码块，而某2些语言则是用花括号</p><br><p>2. 缩进最好使用四个空格，不要混用和使用Tab</p><br><p>3. 退出缩进多敲一个回车</p>

<h3 id="if语句">if语句</h3><pre><code><span class="keyword">if</span> statemen<span class="variable">t:</span>
    statement
elif statemen<span class="variable">t:</span>
    statement
<span class="keyword">else</span> statemen<span class="variable">t:</span>
    statement

<span class="keyword">print</span> <span class="string">'That is All'</span>
</code></pre> <a id="more"></a>
<h3 id="for语法">for语法</h3><p><pre><code><br>    for variable in list/tuple:<br>        statement<br></code></pre></p>
<p>则variable每次循环就会前进一个，代表一个元素</p><br><strong>for 和 in 是Python的关键字</strong><br><br><br>    int i = 0<br>    while i<2: statement="" <strong="">循环可以多层嵌套，判断条件也很灵活<br><br>    for x in [1, 2, 3]:<br>        for y in (1, 2, 3):<br>            print x+y<br>    #输出 2 4 6<br><p>同样while也可以嵌套，注意缩进即可</p><br><p>continue关键字的用法和C语言一样</p>

<h3 id="list有序表">list有序表</h3><p><code>[value, ...]</code> 创建语法，其内元素类型可不相同</p><br><p>1. <code>[index]</code> 索引，也可用来赋值</p><br><p>2. <code>append()</code> 将元素加入末尾</p><br><p>3. <code>insert()</code>将元素插入开头</p><br><p>4. <code>pop()</code>剔除最后一个元素,加上索引参数就剔除指定位置元素</p>

<h3 id="tuple有序表">tuple有序表</h3><p><code>(value, ...)</code> 创建语法，与list不同的是，创建后不可改变</p><br><p>1. <code>( )</code> 在创建tuple单元素的时候，记得加 , 以免造成语法歧义 &gt;&gt;&gt; t = (2,)</p><br><p>2. <code>t[1]</code>同样使用索引找到想要的值</p><br><p>“可变的”tuple 原理即在tuple中加入</p><br><pre><code><br>    list &gt;&gt;&gt; t = (1,2,[‘Kandle’, ‘Bankgh’])<br></code></pre><br><p>就可以使用tuple的索引到list进行增减</p>

<h3 id="dict无序表">dict无序表</h3><p><code>{&#39;Search_name&#39;: value, ... }</code>创建语法，就像是字典，通过”名称(专业术语叫key)”来查找值(value)，</p><br><p>原理是数据结构哈希表或者叫散列表(Hash Table)</p><br><pre><code><br>    &gt;&gt;&gt; d = {‘Leao’: 65, ‘Candy’: 89, ‘Saver’: 86}<br></code></pre><br><p>1. <code>d[&#39;Leao&#39;]</code> 同样使用索引找到对应的值</p><br><p>如果只是使用<code>[ ]</code>来索引，那么当key不存在时，程序将出错，可以使用dict所带的一种方法:</p><br><p>2. <code>get(&#39;Leao&#39;)</code> 同样返回对应的值，当key不存在时，将返回 None 而不是让程序报错</p><br><p>3. key是不可变的，不可重复的。value无限制</p><br><p>4. 高级应用:</p><br><p>    充分利用key的特性，由于Python中数字类型，字符串和tuple类型不可变，故可以用来做key</p><br><pre><code><br>    t1 = {‘string’: [1, 2, 3], 20: ‘string’, [1, 2]: True}<br></code></pre><br><p>5. <code>d[&#39;Newone&#39;] = 99</code> 向已有的dict中添加新成员</p>

<h3 id="set无序表">set无序表</h3><p><strong>与dict相似，只是少了value，只有key</strong></p>
<p>([‘A’, …]) 创建语法</p><br><p>1. 与list某些特性相似，打印时显示所有元素，但顺序不一定是加入的顺序</p><br><pre><code><br>    &gt;&gt;&gt; s = ([‘A’, ‘B’, ‘C’, ‘C’]<br></code></pre><br><p>print s 可能输出 set([‘A’, ‘C’, ‘B’])</p><br><p>2. set类型只有key没有value，那么访问它们时，返回的不再像dict那样是value，而是 True 或 False</p><br><p>3. set可以用关键字 in 访问 <code>&gt;&gt;&gt; &#39;A&#39; in s</code> 返回Ture</p><br><p>4. add() 添加元素</p><br><p>5. remove() 删除元素</p>

<h3 id="函数">函数</h3><p><strong>1. 内置函数可以使用 help(fun_name) 查看用法</strong></p>
<p>类型转换函数也是内置的，比如将字符串转为数字</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt; int(<span class="string">'123'</span>)
<span class="prompt">&gt;&gt;</span>&gt; <span class="number">123</span>
</code></pre><p>2. 编写函数</p><br><p>格式</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(args)</span>:</span>
    statement
    <span class="keyword">return</span>
</code></pre><p>其中def是定义函数的关键字，其后紧跟一个空格，函数名字，括号，括号中有传入的形式参数，冒号，</p><br><p>函数体(同样是缩进代表同一个代码块)，return也是关键字，后面可跟返回值，如果没有则默认返回None</p><br><p>3.Python的函数可以返回多个值，接收的时候可以用多个变量接受，用逗号隔开。</p><br><p>实际上Python<strong>只是返回一个tuple类型的值</strong>，并不是真的返回多个值，只不过多个变量可以接收同一个tuple类型的值，并按照相应位置赋值:</p>

<pre><code><span class="comment">#假设move_north函数接收一个距离，并返回下一个坐</span>
<span class="comment">#标的值</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y = move_north(<span class="number">200</span>)
<span class="prompt">&gt;&gt;</span>&gt; print x, y
<span class="prompt">&gt;&gt;</span>&gt; <span class="number">133.55</span> <span class="number">226.17</span>
<span class="prompt">&gt;&gt;</span>&gt; r = move_north(<span class="number">200</span>)
<span class="prompt">&gt;&gt;</span>&gt; print r
<span class="prompt">&gt;&gt;</span>&gt;(<span class="number">133.55</span>, <span class="number">226.17</span>)
</code></pre><p>4. 函数的默认参数</p><br><p>可以让某些函数的参数拥有默认值，来简化函数调用</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">my_function1</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span>
    <span class="keyword">return</span> x+y
<span class="function"><span class="keyword">def</span> <span class="title">my_function2</span><span class="params">(x, y)</span>:</span>
    <span class="keyword">return</span> x+y
&gt;&gt;&gt;<span class="keyword">print</span> my_function1(<span class="number">10</span>), my_function1(<span class="number">10</span>,<span class="number">10</span>)
&gt;&gt;&gt;<span class="number">20</span>, <span class="number">20</span>
&gt;&gt;&gt;<span class="keyword">print</span> my_function2(<span class="number">10</span>) <span class="comment">#报错</span>
&gt;&gt;&gt;<span class="keyword">print</span> my_function2(<span class="number">10</span>, <span class="number">10</span>)
&gt;&gt;&gt;<span class="number">20</span>
</code></pre><p>被设置默认值的参数后面不能有没有默认参数的参数。</p><br><p>5.可变参数的函数</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">averages</span><span class="params">(*args)</span>:</span>
    sum = <span class="number">0.0</span>
    count = <span class="number">0.0</span>
    <span class="keyword">for</span> val <span class="keyword">in</span> args:
        sum = sum + val
        count = count + <span class="number">1.0</span>
    <span class="keyword">return</span> sum/count
</code></pre><p>把args变量看作一个tuple即可</p>

<h3 id="list和tuple的_切片操作">list和tuple的 切片操作</h3><p>即取出其中部分的一种操作</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="number">0</span><span class="symbol">:</span><span class="number">3</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="symbol">:</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
<span class="comment">#接收第三个参数，用来增加条件</span>
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="symbol">:</span><span class="symbol">:</span><span class="number">2</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]
</code></pre><h4 id="切片操作的用法">切片操作的用法</h4><pre><code>list[start_index:end_index+<span class="number">1</span>:step]
<span class="preprocessor">#索引为end_index+1位置上的元素不会被取到</span>
<span class="preprocessor">#步长为-1，就说明要倒序取</span>
</code></pre><p><strong>tuple的切片操作与list一致</strong><br></p>
<p>字符串的切片操作</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;<span class="string">'ABCD'</span>[<span class="symbol">:</span><span class="number">2</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="string">'AB'</span>
</code></pre><h3 id="关于迭代">关于迭代</h3><p>1. for总是取出某个集合中的元素，而不是索引</p><br><p>如果我们想要索引，可以使用<strong>enumerate()</strong>函数</p>

<pre><code>#假设有L[<span class="string">'Linda'</span>, <span class="string">'Papara'</span>, <span class="string">'Gerada'</span>, <span class="string">'Bazinga'</span>]
<span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="function"><span class="title">enumerate</span><span class="params">(L)</span></span>:
    print index, <span class="string">'-'</span>, value
&gt;&gt;&gt;<span class="number">0</span> - Linda <span class="number">1</span> - Papara <span class="number">2</span> - Gerada <span class="number">3</span> - Bazinga
</code></pre><p>实际上enumerate自动把每个元素和其对应的索引组合成一个tuple类型，接下来就行了。</p><br><p>2. 迭代dict中的value</p><br><p>可以使用dict的values()方法或者intervalues()，两个方法效果一样，差别在于内存的消耗</p>

<pre><code><span class="keyword">for</span> val <span class="keyword">in</span> dictionary.value()<span class="symbol">:</span>
    print val
<span class="prompt">&gt;&gt;</span>&gt;<span class="comment">#打印出dict 中的所有值而不是key</span>
</code></pre><p><strong>同时输出key和value的方法:</strong></p>
<p>使用dict的items()和iteritems()方法</p>

<pre><code><span class="keyword">for</span> key, <span class="built_in">value</span> <span class="operator">in</span> dictionary.<span class="keyword">items</span>():
    print key, <span class="string">'-'</span>, <span class="built_in">value</span>
&gt;&gt;&gt;<span class="string">'Linda'</span> - <span class="number">65</span> ...<span class="comment">#打印出所有的key value</span>
</code></pre><h3 id="*生成列表">*生成列表</h3><p>1. <strong>range()</strong>函数可以生成既定步长的列表</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;range(<span class="number">1</span>,<span class="number">10</span>)
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]
</code></pre><p>2. 有一种Python自带的列表语法</p>

<pre><code>&gt;&gt;&gt;[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>)</span></span>]
&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]
</code></pre><p>语法是，先写一个元素的表达式(你的元素要满足的条件，这里是x*x)，其次跟一个for迭代式子。放在一个list生成式里</p>

<pre><code>#range同样是一个有默认参数的内置函数
<span class="function"><span class="title">range</span><span class="params">(start_index, end_index+<span class="number">1</span>, step)</span></span>
</code></pre><p>3. 复杂表达式</p><br><p>在列表生成中，不仅可以使用for迭代，我们还能让if剔除迭代中不想要的元素</p>

<pre><code>&gt;&gt;&gt;[x*<span class="function">x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="title">range</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>)</span> <span class="keyword">if</span> x % 2 </span>== <span class="number">0</span>]
&gt;&gt;&gt;[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]
<span class="preprocessor">#只有<span class="keyword">if</span>语句是真时，才会出现在生成的list中</span>
</code></pre><p>4. 列表生成中，同样可以嵌套循环</p><br><p>5.高级应用，使用列表生成来制作网页中的部件，如生成表格</p>
</2:>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Python学习笔记之基础">Python学习笔记之基础</h2><h3 id="Python缩进">Python缩进</h3><p>1. Python用相同缩进来代表同一个代码块，而某2些语言则是用花括号</p><br><p>2. 缩进最好使用四个空格，不要混用和使用Tab</p><br><p>3. 退出缩进多敲一个回车</p>

<h3 id="if语句">if语句</h3><pre><code><span class="keyword">if</span> statemen<span class="variable">t:</span>
    statement
elif statemen<span class="variable">t:</span>
    statement
<span class="keyword">else</span> statemen<span class="variable">t:</span>
    statement

<span class="keyword">print</span> <span class="string">'That is All'</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Python" scheme="//wushxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++流操作(续)]]></title>
    <link href="//wushxin.top/2015/05/10/C-%E6%B5%81%E6%93%8D%E4%BD%9C-%E7%BB%AD/"/>
    <id>//wushxin.top/2015/05/10/C-流操作-续/</id>
    <published>2015-05-09T23:47:59.000Z</published>
    <updated>2015-05-25T02:45:41.840Z</updated>
    <content type="html"><![CDATA[<h3 id="Ｃ++流的使用(续)">Ｃ++流的使用(续)</h3><h2 id="文件I/O">文件I/O</h2>   <p> 常用的基本方法是 <code>open()</code>,<code>c_str()</code>,<code>is_open()</code> 分别时连接文件,转为Ｃ风格字符串,是否连接文件成功 </p>

<pre><code><span class="variable">#include</span> <span class="string">`&lt;fstream&gt;`</span> <span class="comment">//此头文件已经包含了iostream</span>
<span class="attribute">...</span>
<span class="built_in">string</span> cppstr1 <span class="subst">=</span> <span class="string">"input.txt"</span>, cppstr2 <span class="subst">=</span> <span class="string">"output.txt"</span>;
<span class="attribute">...</span>
ifstream fin;      <span class="comment">//任意命名</span>
ofstream fout;
fin<span class="built_in">.</span>open(cppstr1<span class="built_in">.</span><span class="string">`c_str()`</span>);
<span class="keyword">if</span>(<span class="subst">!</span>fin<span class="built_in">.</span><span class="string">`is_open()`</span>)
{
cerr <span class="subst">&lt;&lt;</span> <span class="string">"..."</span>;
<span class="keyword">return</span> <span class="subst">-</span><span class="number">1</span>;
}
fout<span class="built_in">.</span>open();
<span class="attribute">...</span>
</code></pre>   <p> 使用命令行参数的使用 </p> <a id="more"></a><br>   <p><code>int main(int argc, char* argv[])</code> 式中的参数很多人既熟悉又陌生,第一个参数代表参数个数(包括自身)</p><br>   <p> 第二个参数argv的意义在于使用某个参数的名字,以字符串的形式,举个栗子 </p>

<pre><code>#<span class="keyword">include</span> ...
<span class="comment">//...</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="keyword">file</span> = <span class="number">1</span>;<span class="keyword">file</span> &lt; argc;++<span class="keyword">file</span>) <span class="comment">//file为 0 时输出的是该命令或者可执行文件的名称</span>
      cout &lt;&lt; argv[<span class="keyword">file</span>];              <span class="comment">//argv[file]的类型为char*, 即为一个字符串,内容</span>
                                       <span class="comment">//为参数的名字,argc代表总参数个数+1</span>
}
</code></pre>   <p> 假设上面的程序经过编译,在Liunx下实验则为(Windows下请打开命令提示符模式(Win+R,输入cmd,回车后打开),后续操作相同) </p><br>   <code>~$ a.out file1 file2</code><br><br>   <strong> 其中 argv[1] == “file1”, argv[2] == “file2” argv[0] == “a.out” </strong><br><br>   <p> 文件I/O的模式 mode </p><br>   <pre><code><br>   //接上上个程序<br>   fin.open(cppstr1.<code>c_str()</code>,mode);//mode代表模式,后面介绍<br>   ifstream fin2(cppstr2.<code>c_str()</code>,mode);//也可以使用构造函数的方式<br>   ofstream fout2(…);//ofstream的模式多于ifstream<br>   </code></pre><br>   <p><br>   <strong>下面模式可以与Ｃ中的I/O模式对应</strong><br><br>   <code>ios_base::in</code>   //此mode适用于ifstream类型,用于打开并读取文件<br><br>   <code>ios_base::out</code>  //打开文件,并写入<br><br>   <code>ios_base::trunc</code>//如果文件存在则,截断文件,ofstream的构造函数默认使用 <code>ios_base::out|ios_base::turnc</code><br><br>   <code>ios_base::app</code>  //打开文件,追加到文件尾写入<br><br>   <code>ios_base::ate</code>  //打开文件,并移动到文件尾<br><br>   <code>ios_base::binary</code> //使用二进制文件模式.对于数字十分迅捷,但也有不足,即兼容性.<br><br>   <strong> 符号<code>|</code>,代表或,该运算符两端的操作都使用 </strong><br>   </p><br>## 文件I/O之二进制文件<br>   <p> 此后的代码都必须建立在同一种类型的系统甚至同一种类型的编译器中,即产生或使用的文件的使用的范围. </p>

<pre><code><span class="preprocessor">#include `&lt;fstream&gt;`</span>
<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">"test.txt"</span>;
<span class="keyword">struct</span> test{
      <span class="keyword">char</span>   name[<span class="number">10</span>];
      <span class="keyword">double</span> popu;
      <span class="keyword">double</span> g;
};<span class="comment">//定义一个结构体,用来展示二进制的读以及写</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
...<span class="comment">//创建一个test类型的结构体对象,并填入值,对象名为 bintest</span>
<span class="function">ofstream <span class="title">fout</span><span class="params">(filename, `ios_base::<span class="keyword">in</span>`|`ios_base::binary`)</span></span>;
...<span class="comment">//检查是否打开成功</span>
fout.write((`<span class="keyword">char</span>*`)&amp;bintest, <span class="keyword">sizeof</span> bintest); 
`<span class="comment">//使用write函数来写入,char*代表逐个字符的从内存写入到文件,而不考虑存储类型`</span>
<span class="function">ofstream <span class="title">fin</span><span class="params">(filename, `ios_base::<span class="keyword">in</span>`|`ios_base::binary`)</span></span>;
...<span class="comment">//检查是否打开成功</span>
fin.read((<span class="keyword">char</span>*)&amp;bintest, <span class="keyword">sizeof</span> bintest);<span class="comment">//使用read函数来恢复使用write函数写入的二进制数据</span>
...<span class="comment">//验证是否操作有误</span>
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>   <strong>科普:由于三大类操作系统对于换行有不同定义,导致了第一句话:</strong><br><br>   </p><p>Windows使用换行加回车表示 换行符</p><br>   <p>Unix/Liunx使用换行来表示  换行符</p><br>   <p>Macintosh使用回车来表示   换行符(即苹果电脑)</p><p></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Ｃ++流的使用(续)">Ｃ++流的使用(续)</h3><h2 id="文件I/O">文件I/O</h2>   <P> 常用的基本方法是 <code>open()</code>,<code>c_str()</code>,<code>is_open()</code> 分别时连接文件,转为Ｃ风格字符串,是否连接文件成功 </P>

<pre><code><span class="variable">#include</span> <span class="string">`&lt;fstream&gt;`</span> <span class="comment">//此头文件已经包含了iostream</span>
<span class="attribute">...</span>
<span class="built_in">string</span> cppstr1 <span class="subst">=</span> <span class="string">"input.txt"</span>, cppstr2 <span class="subst">=</span> <span class="string">"output.txt"</span>;
<span class="attribute">...</span>
ifstream fin;      <span class="comment">//任意命名</span>
ofstream fout;
fin<span class="built_in">.</span>open(cppstr1<span class="built_in">.</span><span class="string">`c_str()`</span>);
<span class="keyword">if</span>(<span class="subst">!</span>fin<span class="built_in">.</span><span class="string">`is_open()`</span>)
{
cerr <span class="subst">&lt;&lt;</span> <span class="string">"..."</span>;
<span class="keyword">return</span> <span class="subst">-</span><span class="number">1</span>;
}
fout<span class="built_in">.</span>open();
<span class="attribute">...</span>
</code></pre>   <p> 使用命令行参数的使用 </p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++流操作]]></title>
    <link href="//wushxin.top/2015/05/10/C-%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <id>//wushxin.top/2015/05/10/C-流操作/</id>
    <published>2015-05-09T23:47:37.000Z</published>
    <updated>2015-05-25T02:45:34.540Z</updated>
    <content type="html"><![CDATA[<h1 id="C++流的使用">C++流的使用</h1><h2 id="每次使用完流,记得要关闭,虽然有时候并不是必须的-">每次使用完流,记得要关闭,虽然有时候并不是必须的.</h2><p><code>streamname.close();</code></p>
<h2 id="重定向">重定向</h2><p>   在Linux终端或者Windows命令提示符模式下,使用重定向可以改变输入源和输出源 <br><br>   <pre><code><br>   ~$ program ‘&lt;’input.filetype &gt;output.filetype #去掉多余的’’<br>   </code></pre><br>   <br> 在Linux和Unix下,’&gt;’ ‘&lt;’默认是标准输出和标准输入,’2&gt;’则是标准错误(即std::cerr)</p>
<h2 id="输出流">输出流</h2><p>   <br>1. ostream类提供了 put() 和 write() 方法用来输出 <br></p>
<pre><code><span class="built_in">cout</span>.put(<span class="string">'W'</span>); <span class="comment">//输出字符Ｗ,可以拼接使用就像重载之后的 '&lt;&lt;'</span>
<span class="built_in">cout</span>.write(<span class="string">"Candy Bob"</span>,<span class="number">5</span>); <span class="comment">//输出第一个参数的第二个参数个长度</span>
</code></pre><p>   <br>2. 刷新输出缓冲区可以有两种方法,原理都是重载 ‘&lt;&lt;’ <br><br>   <br>   前者与后者的差别就在与后者刷新缓冲区后多了一个换行操作 <br></p>
<pre><code><span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; flush; <span class="comment">//相当于flush(cout);</span>
<span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; endl;  
</code></pre><p>   <br>3. 可以通过流操作修改现实的进制, 默认十进制,十六进制,八进制 <br><br><a id="more"></a><br>      int n = 100;<br>      cout &lt;&lt; n &lt;&lt; endl;<br>      //八进制<br>      cout &lt;&lt; oct &lt;&lt; n &lt;&lt; endl;<br>      //十六进制<br>      cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl;<br>      //这种作用是持久的,在不用的时候记得转换回来<br>      dec(cout); //代表转换为十进制 cout &lt;&lt; dec;同样适用  </p>
<p>   <br>4. 我们可以调整字段宽度来达到美观,但Ｃ++有一种数据完整大于美观的理念,所以即使你设置了字段宽度,一旦超过还是会<br>        打乱阵型,以保证数据的完整性.<br>   <br></p>
<pre><code><span class="built_in">cout</span>.fill(<span class="string">'*'</span>);<span class="comment">//使用'*'填充空白,注意此为持久的.</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i*=<span class="number">10</span>)
{
  <span class="built_in">cout</span>.width(<span class="number">5</span>);
  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;
  <span class="built_in">cout</span>.width(<span class="number">8</span>);
  <span class="built_in">cout</span> &lt;&lt; i * i &lt;&lt; endl;
}<span class="comment">//注意，width()方法并不是持久的,也就是说每次排版都需要使用一次该方法.</span>
</code></pre><p>   <br>5. 浮点数的使用 <br></p>
<pre><code><span class="built_in">cout</span>.precision(<span class="number">2</span>);<span class="comment">//设置浮点数的精度为2,Ｃ++默认六位精度,但不显示末尾的0.</span>
<span class="built_in">cout</span>.setf(ios_base::showpoint);<span class="comment">//显示末尾的零</span>
</code></pre><h2 id="输入流">输入流</h2><p>   <br> cin检查输入: 当读取到的流和指定的类型不符合的时候,不符合的流中的数据被保留,留待下一次读取.并返回flase<br>       可以使用while语句进行判断 <br></p>
<pre><code>int <span class="keyword">input</span>, <span class="keyword">sum</span>;
<span class="keyword">while</span>(cin &gt;&gt; <span class="keyword">input</span>)
<span class="keyword">sum</span> += <span class="keyword">input</span>;
</code></pre><p>   <br> 当流由于输入不匹配失败时,发生的问题十分复杂,简述为位设置问题,使用下列代码恢复 <br></p>
<pre><code><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; input)
   sum += input;
<span class="keyword">if</span>(<span class="built_in">cin</span>.fail() &amp;&amp; !<span class="built_in">cin</span>.eof())
{
   <span class="built_in">cin</span>.clear();              <span class="comment">//重置流状态,但此时还是有残余留在流中</span>
   <span class="keyword">while</span>(!<span class="built_in">isspace</span>(<span class="built_in">cin</span>.get()))<span class="comment">//丢弃那些残留在流中妨碍下一次输入的不符合的输入</span>
         <span class="keyword">continue</span>;           <span class="comment">//头文件 cctype</span>
}
<span class="built_in">cin</span> &gt;&gt; input; <span class="comment">//现在可以继续输入了</span>
</code></pre><p>   <br> 字符串的输入:<code>get(char*, int)</code> 和 <code>getline(char*, int)</code> <br><br>   <br> get读取少于第二个参数减1个或遇见换行符,并将换行符留在流中,getline则将换行符抽取并丢弃<br><br>   <br> <code>get(char*, int, char)</code> 和 <code>getline(char*, int, char)</code> <br><br>   <br> 第三个参数则是分界符,读取到分界符号时停止读取. <br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="C++流的使用">C++流的使用</h1><h2 id="每次使用完流,记得要关闭,虽然有时候并不是必须的-">每次使用完流,记得要关闭,虽然有时候并不是必须的.</h2><p><code>streamname.close();</code></p>
<h2 id="重定向">重定向</h2><p>   在Linux终端或者Windows命令提示符模式下,使用重定向可以改变输入源和输出源 </br><br>   <pre><code><br>   ~$ program ‘&lt;’input.filetype &gt;output.filetype #去掉多余的’’<br>   </code></pre><br>   <br> 在Linux和Unix下,’&gt;’ ‘&lt;’默认是标准输出和标准输入,’2&gt;’则是标准错误(即std::cerr)</p>
<h2 id="输出流">输出流</h2><p>   <br>1. ostream类提供了 put() 和 write() 方法用来输出 </br></p>
<pre><code><span class="built_in">cout</span>.put(<span class="string">'W'</span>); <span class="comment">//输出字符Ｗ,可以拼接使用就像重载之后的 '&lt;&lt;'</span>
<span class="built_in">cout</span>.write(<span class="string">"Candy Bob"</span>,<span class="number">5</span>); <span class="comment">//输出第一个参数的第二个参数个长度</span>
</code></pre><p>   <br>2. 刷新输出缓冲区可以有两种方法,原理都是重载 ‘&lt;&lt;’ </br><br>   <br>   前者与后者的差别就在与后者刷新缓冲区后多了一个换行操作 </br></p>
<pre><code><span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; flush; <span class="comment">//相当于flush(cout);</span>
<span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; endl;  
</code></pre><p>   <br>3. 可以通过流操作修改现实的进制, 默认十进制,十六进制,八进制 </br><br>]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo网站布置错误解决]]></title>
    <link href="//wushxin.top/2015/05/09/Hexo%E7%BD%91%E7%AB%99%E5%B8%83%E7%BD%AE%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <id>//wushxin.top/2015/05/09/Hexo网站布置错误解决/</id>
    <published>2015-05-09T12:10:30.000Z</published>
    <updated>2015-06-12T01:27:05.988Z</updated>
    <content type="html"><![CDATA[<h2 id="布置Hexo博客">布置Hexo博客</h2><h4 id="发布于Github_pages时的错误总结">发布于Github pages时的错误总结</h4><p>在布置一个个人博客的时候，我们总会遇到各种各样的错误，这里来总结一下，不记录那些常规步骤，因为网上特别多，搜集常见错误。</p>
<ul>
<li>本人布置建设并布置该网站在2015.5.9日，Hexo的版本已经到3了，并且在这个版本出现了一个和以前不同的配置，所以导致许多后来者按照前人的脚步跳进了深坑，当然你降至版本2也是可以使用前人的设置的。<br>首先是在你配置好本地之后，验证可行了，那么你就可以选择发布到Github Pages上了，这个时候，在<strong>_config.yml</strong>文件中修改末尾项为:<pre><code><span class="attribute">deploy</span>:
    <span class="attribute">type</span>: git #此处在版本<span class="number">2</span>时为github
    <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/......</span>
    ...
</code></pre>在这个地方容易出错的是<strong>type:</strong>后方容易被误导，版本2请填写github，版本3除了填写git以外，还需要在外头<strong>Git bash</strong>里使用命令:<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span>
</code></pre>有了这个命令就能分分钟解决你的问题。<a id="more"></a></li>
<li><p>还有一个问题，在我们使用命令:</p>
<pre><code><span class="title">hexo</span> init <span class="string">"Blog_name"</span>
</code></pre><p>初始化建立一个博客之后，我们需要使用命令:</p>
<pre><code>npm <span class="keyword">install</span>
</code></pre><p>来下载依赖包，可是这个命令中需要下载的某些东西是从Google下载的，所以很多人在搭建的时候卡在这一步一动不动，原因是中国屏蔽了谷歌，然后就没有然后了，我建议使用VPN直接连接外网后重新使用该命令，而不要像网上那样自行下载某些部分。</p>
</li>
<li><p>偶尔在最后一步使用:</p>
<pre><code><span class="title">hexo</span> deploy
</code></pre><p>进行上传布局的时候，会在输入完用户名密码以后出现错误，请你按照这个格式进行(_config.yml中):</p>
<pre><code><span class="string">repository:</span> <span class="string">https:</span><span class="comment">//github.com/yourname/yourname.github.io.git</span>
</code></pre><p>如此就行了</p>
</li>
<li><p>有时候会遇到，标签失效，或者说两个标签指向了同一个路径，那么你可以看看自己的标签是否有符号例如<code>C</code>和<code>C++</code>，那么就会导致两个都指向同一个路径，这时候只需要把<code>C++</code>改成<code>Cpp</code>即可。</p>
</li>
</ul>
<h4 id="这就是我今天遇到的所有问题，建设虽难，可不要放弃啊。">这就是我今天遇到的所有问题，建设虽难，可不要放弃啊。</h4><h3 id="技巧">技巧</h3><ul>
<li><p>对于那些使用googleapi站点的链接来说，由于国内把谷歌墙了，所以可改用百度静态CDN库，在目录文件：</p>
<pre><code><span class="command">\themes</span><span class="command">\landscape</span><span class="command">\layout</span><span class="command">\_</span>partial<span class="command">\after</span>-footer.ejs
</code></pre><p>  中修改jQuery的引用网址为百度cdn的地址即可。</p>
</li>
<li><p>对于<strong>RSS</strong>功能，请使用如下命令：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span>
</code></pre><p>  亲测，如果不加<strong>- -save</strong>参数有的环境下这个插件无法正常的工作。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="布置Hexo博客">布置Hexo博客</h2><h4 id="发布于Github_pages时的错误总结">发布于Github pages时的错误总结</h4><p>在布置一个个人博客的时候，我们总会遇到各种各样的错误，这里来总结一下，不记录那些常规步骤，因为网上特别多，搜集常见错误。</p>
<ul>
<li>本人布置建设并布置该网站在2015.5.9日，Hexo的版本已经到3了，并且在这个版本出现了一个和以前不同的配置，所以导致许多后来者按照前人的脚步跳进了深坑，当然你降至版本2也是可以使用前人的设置的。<br>首先是在你配置好本地之后，验证可行了，那么你就可以选择发布到Github Pages上了，这个时候，在<strong>_config.yml</strong>文件中修改末尾项为:<pre><code><span class="attribute">deploy</span>:
    <span class="attribute">type</span>: git #此处在版本<span class="number">2</span>时为github
    <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/......</span>
    ...
</code></pre>在这个地方容易出错的是<strong>type:</strong>后方容易被误导，版本2请填写github，版本3除了填写git以外，还需要在外头<strong>Git bash</strong>里使用命令:<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span>
</code></pre>有了这个命令就能分分钟解决你的问题。]]>
    
    </summary>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
      <category term="网站" scheme="//wushxin.top/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>