<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[WuShXin's fox]]></title>
  <subtitle><![CDATA[喜欢编程带来的快感]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="//wushxin.top//"/>
  <updated>2015-12-03T13:01:25.142Z</updated>
  <id>//wushxin.top//</id>
  
  <author>
    <name><![CDATA[WuShengXin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[现代TCP/IP网络编程]]></title>
    <link href="//wushxin.top/2015/10/30/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>//wushxin.top/2015/10/30/TCP-IP网络编程.html</id>
    <published>2015-10-30T10:16:53.000Z</published>
    <updated>2015-12-03T13:01:25.142Z</updated>
    <content type="html"><![CDATA[<h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的，实际上还有一个但这里不记录。</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code><a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>概念模糊的 <strong>DNS</strong><ul>
<li>其实很简单，它的作用就是用来找到域名所对应的 <strong>IP地址</strong></li>
<li>为什么？因为 <strong>IP地址</strong> 太难记了！如果你觉得 <strong>IPv4</strong> 地址还难不倒你，那请你试试 <strong>IPv6</strong></li>
<li>怎么查看域名对应的 <strong>IP地址</strong>，当然先不考虑 <strong>CDN</strong><ul>
<li><code>*nix</code> 和 <code>Windows</code> 都可以通过 <code>ping &lt;domain name&gt;</code> 命令进行查询</li>
</ul>
</li>
</ul>
</li>
<li><strong>MAC地址</strong> 和 <strong>端口号</strong><ul>
<li>对于前者，实际上应该是最熟悉不过的，对于网络上的主机而言，每一台主机就有一个专属的 <strong>MAC地址</strong></li>
<li>后者则是相当于一个房子的门，这个比喻在各大教材中广泛引用，但也的确贴切，假设 <strong>IP地址</strong> 是房子的地址，那么到了别人家要知道门在哪才行。</li>
</ul>
</li>
</ul>
<p>一个完整的应用程序传输数据时候 <strong>封装</strong> 的过程(<strong>从右二向左依次封装</strong>)：</p>
<table>
<thead>
<tr>
<th>以太网首部</th>
<th>IP</th>
<th>TCP/UDP</th>
<th>真实数据</th>
<th>尾部</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC地址</td>
<td>IP地址</td>
<td>TCP或者UDP协议</td>
<td>应用程序数据</td>
<td>效验码</td>
</tr>
<tr>
<td>源和目的MAC地址以及</td>
<td>及前层协议类型</td>
<td>源和目的端口号及前层应用程序首部信息</td>
<td>应用软件信息和真正的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中端口号实际上就是 <strong>应用程序的信息</strong></p>
<p>接收数据时的 <strong>拆解</strong> 顺序与 <strong>封装</strong> 正好相反。</p>
<ul>
<li><p>其中在传输过程中，作为接收方最开始使用的是 <strong>网络接口层/数据链路层</strong> 的驱动程序(即操作系统自带或另行安装，总之不用使用的程序员写就对了)，来判断这个包是否属于我，判断的依据就是 <strong>MAC地址</strong>，如果是再判断什么协议</p>
<ul>
<li>在此处的协议可不止 <strong>IP协议</strong>， 也可能是 <strong>ARP协议</strong> 等。之后就是就事论事交给相应的处理软件去处理(拆解)就行</li>
<li>科普： MAC地址是 <code>48bit</code> 的， 前<code>24bit</code>由 <strong>IEEE</strong> 分配， 后<code>24bit</code> 由厂商分配。原则上是唯一的。</li>
</ul>
</li>
<li><p><strong>MAC地址</strong> 和 <strong>IP地址</strong></p>
<ul>
<li>既然前方说到 <strong>MAC地址</strong> 和 <strong>IP地址</strong> 都能够作为识别另一个主机的唯一标识，但是为什么需要有两个相同功能的东西？</li>
<li>是，在一开始，网络很小的情况下，例如我们在同一个局域网中，我们之间需要<strong>通信</strong>的时候，只需要使用ARP协议，进行<strong>广播</strong>，向在一个网络中的所有主机发送消息就行，剩下的就让其他主机去判断(通过<strong>MAC地址</strong>)这个数据是不是发给我的。<ul>
<li><strong>ARP协议</strong> 的作用就是在同一个网络中，通过 <strong>广播</strong> 找出符合自己要求的主机的 <strong>MAC地址</strong> ，如果不在同一个网络中，又想知道对方的 <strong>MAC地址</strong>， 那只能借助把每个网络链接在一起的 <strong>网关</strong> 来帮助你发送 。 总之进行网络通信时必须知道对方的 <strong>IP地址 和 MAC地址</strong></li>
</ul>
</li>
<li>但是如果是现在整个互联网呢？不算 <strong>IPv6</strong> ，就算 <strong>IPv4</strong> 也是几十亿的存在，如果我从中国向国外发送信息，广播整个互联网的所有主机，那就炸了！</li>
<li>所以我们需要对世界网络进行分区，让大区域包含小区域，就像<strong>国家-省-市区…</strong> ， 很遗憾的是 <strong>MAC地址</strong> 是跟计算机相关而不是和位置相关的。所以我们有了 <strong>IP协议</strong></li>
<li><strong>IP协议</strong> 所附带的产品 <strong>IP地址</strong> 的作用就在帮助计算机识别自己是否在同一个网络中( <strong>这里省略了子网掩码的作用</strong> )。</li>
</ul>
</li>
<li><p>实际上，在进行网络编程的时候，以上细节几乎都被隐藏起来，留给我们的只是可供使用的接口。</p>
</li>
</ul>
<blockquote>
<p>也许，许多大学计算机基础课程，会讲到 IP地址 有种类，分为 A,B,C…类，老师还介绍了各种类型的地址范围。</p>
<p>但是在现代，这种分类早已经失效，或者说正在逐渐消失，因为当下的 IP 地址的 子网掩码 可以是任意位，并以反斜杠跟在 IP地址后方。</p>
<p>现代的 IP地址 形式一般如此 1.185.223.1/24 代表着子网掩码是由 24个 从左至右连续的的二进制1 组合而成，其余位为0。</p>
</blockquote>
<h2 id="夹在中间">夹在中间</h2><blockquote>
<p>事实上有一些实用且挺炫酷的函数，可以先提一下</p>
</blockquote>
<ul>
<li>域名 和 IP地址 的互查<ul>
<li><code>gethostbyname</code> 用于域名查找 IP信息及各类信息<ul>
<li><code>struct hostent * gethostbyname(const char * hostname)</code></li>
<li><code>struct hostent</code> 是存储查找到的各类型信息，后方会有介绍</li>
<li><code>hostname</code> 即要查询的域名</li>
</ul>
</li>
<li><code>gethostbyaddr</code> 用于IP地址查找 域名及各类信息<ul>
<li><code>struct hostent * gethostbyaddr(const char * addr, socklen_t len, int family)</code><ul>
<li><code>addr</code> 是要查询的 IP地址，之所以是 <code>const char *</code> 是因为C语言历史遗留的原因，实际上其类型应为 <code>struct in_addr *</code>(IPv4)</li>
<li><code>len</code> 地址的长度，即 <strong>IPv4</strong> 为4， <strong>IPv6</strong> 为16</li>
<li><code>family</code> 即协议的种类， <strong>IPv4</strong> 为 <code>AF_INET</code>, <strong>IPv6</strong> 为 <code>AF_INET6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>struct hostent 的成员</th>
<th>.</th>
<th>类型</th>
<th>.</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>h_name</td>
<td></td>
<td>char *</td>
<td></td>
<td>官方名称</td>
</tr>
<tr>
<td>h_aliases</td>
<td></td>
<td>char **</td>
<td></td>
<td>域名集合，以NULL结尾</td>
</tr>
<tr>
<td>h_addrtype</td>
<td></td>
<td>int</td>
<td></td>
<td>地址族的类型 AF_INET 或 AF_INET6</td>
</tr>
<tr>
<td>h_length</td>
<td></td>
<td>int</td>
<td></td>
<td>地址的长度 4 或 16</td>
</tr>
<tr>
<td>h_addr_list</td>
<td></td>
<td>char **</td>
<td></td>
<td>IP的集合，以NULL结尾, 实际上每个元素的类型为 struct in_addr*</td>
</tr>
</tbody>
</table>
<ul>
<li>其中第二和最后一个是关注的重点所在，可以在调用函数之后，输出信息<blockquote>
<p>实际上，这并不是一个好的方法，在后方将记录 现代人的我们 该如何做到这些事情，以上只是以前的TCP/IP 编程<br>只适用于 IPv4</p>
</blockquote>
</li>
</ul>
<h2 id="套接字网络编程初始">套接字网络编程初始</h2><blockquote>
<p>选择使用 C 语言进行编程</p>
</blockquote>
<ul>
<li>在网络编程中，最常实用的两种连接方式 <code>TCP</code> 和 <code>UDP</code></li>
<li>最常编程的平台 <code>POSIX 标准-&gt;*nix平台标准</code> 和 <code>Windows 平台标准</code><ul>
<li>实际上，后者也是参考前者进行一些细微的改变(<strong>指的是接口</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比两种不同连接方式的不同地位的创建，使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP服务器</th>
<th>TCP客户端</th>
<th>UDP服务器</th>
<th>UDP客户端</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>socket()</td>
<td>创建套接字</td>
</tr>
<tr>
<td>bind()</td>
<td></td>
<td>bind()</td>
<td>bind()</td>
<td>绑定所分配IP地址和端口号</td>
</tr>
<tr>
<td>listen()</td>
<td>connect()</td>
<td></td>
<td></td>
<td>客户端则绑定IP地址和端口号，并等待连接；服务器则是等待连接</td>
</tr>
<tr>
<td>accept()</td>
<td></td>
<td></td>
<td></td>
<td>服务器接受连接</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>sendto/recvfrom()</td>
<td>sendto/recvfrom()</td>
<td>对于UDP即是连接也是操作</td>
</tr>
<tr>
<td>close()</td>
<td>close()</td>
<td>close()</td>
<td>close</td>
<td>双向直接关闭连接</td>
</tr>
<tr>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>shutdown()</td>
<td>可选择方向的关闭连接,即更加灵活</td>
</tr>
</tbody>
</table>
<p>如此对比虽然有一些小瑕疵，但是能够大体上反映出真个网络编程上不同方式的区别</p>
<blockquote>
<p>注： 实际上 UDP 没有所谓的 服务器和和护短，因为本来就是单纯的互相发来发去。<strong>客户端端口</strong> 一般是随机的</p>
<p>以上是 *nix平台下的标准， Windows下的操作方式和 API有细微不同，但大部分是一致的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Windows</th>
<th>*nix</th>
</tr>
</thead>
<tbody>
<tr>
<td>socket()</td>
<td>socket()</td>
</tr>
<tr>
<td>bind()</td>
<td>bind()</td>
</tr>
<tr>
<td>connect()</td>
<td>connect()</td>
</tr>
<tr>
<td>listen()</td>
<td>listen()</td>
</tr>
<tr>
<td>accept()</td>
<td>accept()</td>
</tr>
<tr>
<td>closesocket()</td>
<td>close()</td>
</tr>
<tr>
<td>send()</td>
<td>send()</td>
</tr>
<tr>
<td>read()</td>
<td>read()</td>
</tr>
<tr>
<td>sendto()</td>
<td>sendto()</td>
</tr>
<tr>
<td>recvfrom()</td>
<td>recvfrom()</td>
</tr>
</tbody>
</table>
<p>不仅仅是接口名字相同，参数个数以及功能也是一致，即使有一个例外，其参数以及使用方法也相同。</p>
<blockquote>
<p>那岂不是可以直接移植了？</p>
<p>并不！</p>
</blockquote>
<p>在 <strong> Windows 套接字编程时</strong> ， 由于 <code>Windows</code> 将其实现为动态库，所以在使用时需要将其加载进程序。</p>
<p>故而多加了加载操作。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(
  WORD      wVersionRequested,
  LPWSADATA lpWSAData  <span class="comment">/* 这是一个结构体， 传入类型为WSADATA*  */</span>
)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>每当在 <strong>Windows</strong> 上进行套接字编程时，总要指定某个版本的套接字库：</p>
<pre><code>WSADATA wsaData;
int err_code;
/<span class="keyword">*</span>
<span class="keyword">*</span> MAKEWORD()的作用在于将版本号转为指定格式传入
<span class="keyword">*</span> 当下(2015-10)套接字库的版本号最高是 2.2
<span class="keyword">*</span>/
err_code = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
/<span class="keyword">*</span> TODO Something <span class="keyword">*</span>/
WSACleanup();
</code></pre><p>这是最基本的在 <strong>Windows</strong> 上使用 <strong>套接字</strong> 编程的流程，但是如果本平台的套接字库最高版本并不符合当前要求呢？</p>
<p>那么首先会将套接字版本库尽可能设置到平台的 <strong>最高版本</strong> ，可以通过结构体 <code>WSADATA</code> 进行查询</p>
<pre><code><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)
{
  <span class="built_in">printf</span>(<span class="string">"Could not find a usable version of Winsock.dll\n"</span>);
  WSACleanup();
  <span class="built_in">return</span> <span class="number">1</span>;
}
</code></pre><blockquote>
<p>总体而言， <code>Windows平台</code> 和 <code>*uix平台</code> 的区别在于，前者使用时需要 加载和清除 套接字库<br>其余逻辑流程一致，毕竟只有统一才能越利于编程世界的发展。</p>
</blockquote>
<h2 id="套接字编程">套接字编程</h2><ul>
<li>两种协议 <code>TCP</code> 和 <code>UDP</code><ul>
<li>前者可以理解为有保证的连接，后者是追求快速的连接</li>
<li>当然最后一点有些 <strong>太过绝对</strong> ，但是现在不需熬考虑太多，因为初入套接字编程，一切从简</li>
<li>稍微试想便能够大致理解， <code>TCP</code> 追求的是可靠的传输数据， <code>UDP</code> 追求的则是快速的传输数据</li>
<li>前者有繁琐的连接过程，后者则是根本不建立可靠连接(不是绝对)，只是将数据发送而不考虑是否到达。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下例子以 <code>*nix</code> 平台的便准为例，因为 <code>Windows</code>平台需要考虑额外的加载问题，稍作添加就能在 Windows 平台上运行</p>
</blockquote>
<h3 id="UDP">UDP</h3><ul>
<li><p><code>UDP</code></p>
<ul>
<li>这是一个十分简洁的连接方式，假设有两台主机进行通信，一台只发送，一台只接收。</li>
<li><p>接收端：</p>
<pre><code>int sock; /<span class="keyword">*</span> 套接字 <span class="keyword">*</span>/
socklen_t addr_len; /<span class="keyword">*</span> 发送端的地址长度，用于 recvfrom <span class="keyword">*</span>/
char mess[15];
char get_mess[GET_MAX]; /<span class="keyword">*</span> 后续版本使用 <span class="keyword">*</span>/
struct sockaddr_in recv_host, send_host;

/<span class="keyword">*</span> 创建套接字 <span class="keyword">*</span>/
sock = socket(PF_INET, SOCK_DGRAM, 0);

/<span class="keyword">*</span> 把IP 和 端口号信息绑定在套接字上 <span class="keyword">*</span>/
memset(&amp;recv_host, 0, sizeof(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = htonl(INADDR_ANY);/<span class="keyword">*</span> 接收任意的IP <span class="keyword">*</span>/
recv_host.sin_port = htons(6000); /<span class="keyword">*</span> 使用6000 端口号 <span class="keyword">*</span>/
bind(sock, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));

/<span class="keyword">*</span> 进入接收信息的状态 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len);

/<span class="keyword">*</span> 接收完成，关闭套接字 <span class="keyword">*</span>/
close(sock);
</code></pre><p>上述代码省略了许多必要的 <strong>错误检查</strong> ，在实际编写时要添加</p>
</li>
<li>代码解释：<ol>
<li><strong>PF_INET</strong> 代表协议的类型，此处代表 <strong>IPv4</strong> 网络协议族， 同样 <strong>PF_INET6</strong> 代表 <strong>IPv6</strong> 网络协议族，这个范围在后方单独记录，不与IPv4混在一起(并不意味着更复杂，实际上更简便)。</li>
<li><strong>AF_INET</strong> 代表地址的类型，此处代表 <strong>IPv4</strong> 网络协议使用的地址族， 同样有 <strong>AF_INET6</strong> (在操作系统实现中 PF_INET 和 AF_INET 的值一样，<strong>但是还是要写宏更好，而不应该直接用数字或者，混淆使用</strong>)</li>
<li><code>htonl</code> 和 <code>htons</code> 两个函数的使用涉及到 <strong>大端小端问题</strong>， 这里不叙述，需要记住的是在网络编程时一定要使用这种函数将必要信息转为 <strong>大端表示法</strong> 。</li>
<li><code>(struct sockaddr *)</code> 这个强制转换是为了参数的必须，但不会出错，因为 <code>sizeof(struct sockaddr_in) == sizeof(struct sockaddr)</code> 具体可以查询相关信息，之所以这么做是为了方便编写套接字程序的程序员。</li>
</ol>
</li>
<li>发送端：<pre><code><span class="keyword">int</span> sock;
<span class="keyword">const</span> <span class="keyword">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="keyword">char</span> get_mess[GET_MAX]; <span class="comment">/* 后续版本使用 */</span>
<span class="keyword">struct</span> sockaddr_in recv_host;
socklen_t addr_len;
<span class="comment">/* 创建套接字 */</span>
sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);
<span class="comment">/* 绑定 */</span>
<span class="built_in">memset</span>(&amp;recv_host, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_host));
recv_host.sin_family = AF_INET;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
<span class="comment">/* 发送信息 */</span>
<span class="comment">/* 在此处，发送端的IP地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */</span>
sendto(sock, mess, <span class="built_in">strlen</span>(mess), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host));
<span class="comment">/* 完成，关闭 */</span>
close(sock);
</code></pre>上述代码是发送端。</li>
<li>代码解释：<ol>
<li><code>inet_addr</code> 函数是用于将字符串格式的 <strong>IP地址</strong> 转换为 大端表示法的 地址类型，即 <code>s_addr</code> 的类型 <code>in_addr_t</code></li>
<li>与之相反，同样也有功能相反的函数 <code>inet_ntoa</code> 用于将 <code>in_addr_t</code> 类型转为字符串，但是使用时一定要记住及时拷贝返回值<pre><code><span class="type">char</span> <span class="keyword">addr</span>[<span class="number">16</span>];
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
strcpy(<span class="keyword">addr</span>, inet_ntoa(recv_host.sin_addr.s_addr));
</code></pre></li>
</ol>
</li>
<li>从上述代码看出， <code>UDP</code> 协议的使用十分简洁，几乎就是 <strong>创建套接字-&gt;准备数据-&gt;装备套接字-&gt;发送/接收-&gt;结束</strong></li>
<li>其中，都没有连接的操作，但是实际上这是为了方便 <code>UDP</code> 随时和 <strong>不同的主机</strong> 进行通信所默认的设置，如果需要和相同主机一直通信呢？</li>
<li>此中的原由暂时不需要知道，记录方法，即长时间使用 <code>UDP</code> 和同一主机通信时，可以使用 <code>connect</code> 函数来进行优化自身。此时 <strong>假设两台主机的实际功能一致，既接收也发送</strong></li>
<li>发送端：<pre><code><span class="comment">/* 前方高度一致，将 bind函数替换为 */</span>
connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;recv_host, <span class="keyword">sizeof</span>(recv_host); <span class="comment">// 将对方的 IP地址和 端口号信息 注册进UDP的套接字中)</span>
<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 循环的发送和接收信息 */</span>
{
  size_t read_len = <span class="number">0</span>;
  <span class="comment">/* 原先使用的 sendto 函数，先择改为使用 write 函数， Windows平台为 send 函数 */</span>
  write(sock, mess, <span class="built_in">strlen</span>(mess));            <span class="comment">/* send(sock, mess, strlen(mess), 0) FOR Windows Platform */</span>
  read_len = read(sock, get_mess, GET_MAX-<span class="number">1</span>); <span class="comment">/* recv(sock, mess, strlen(mess)-1, 0) FOR Windows Platform */</span>
  get_mess[read_len-<span class="number">1</span>] = <span class="string">'\0'</span>;
  <span class="built_in">printf</span>(<span class="string">"In Client like Host Recvive From Other Host : %s\n"</span>, get_mess);
}
<span class="comment">/* 后方高度一致 */</span>
</code></pre></li>
<li>接收端：<pre><code>/<span class="keyword">*</span> 前方一致， 添加额外的 struct sockaddr_in send_host; 并添加循环，构造收发的现象<span class="keyword">*</span>/
while(1)
{
  size_t read_len = 0;
  char sent_mess[15] = <span class="string">"Hello Sender!"</span>; /<span class="keyword">*</span> 用于发送的信息 <span class="keyword">*</span>/
  sendto(sock, mess, strlen(sent_mess), 0, (struct sockaddr <span class="keyword">*</span>)&amp;recv_host, sizeof(recv_host));
  read_len = recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;send_host, &amp;addr_len)
  mess[read_len-1] = '\0';
  printf(<span class="string">"In Sever like Host Recvive From other Host : %s\n"</span>, mess);
}
/<span class="keyword">*</span> 后方高度一致 <span class="keyword">*</span>/
/<span class="keyword">*</span>
<span class="keyword">*</span> 之所以只在接收端使用 connect 的原因，便在于我们模拟的是 客户端-服务器 的模型，而服务器的各项信息是不会随意变更的
<span class="keyword">*</span> 但是 客户端就不同了，可能由于 ISP(Internet Server Provider) 的原因，你的IP地址不可能总是固定的，所以只能
<span class="keyword">*</span> 保证 在客户端 部分注册了 服务器 的各类信息，而不能在 服务器端 注册 客户端 的信息。
<span class="keyword">*</span> 当然也有例外，例如你就想这个软件作为私密软件，仅供两个人使用， 且你有固定的 IP地址，那么你可以两边都connect，但是
<span class="keyword">*</span> 一定要注意，只要有一点信息变动，这个软件就可能无法正常的收发信息了。
<span class="keyword">*</span>/
</code></pre></li>
<li>代码解释<ul>
<li>故而实际上，虽然前方的表格显示，<code>UDP</code> 似乎并没有 <code>connect</code> 的使用必要，但是实际上还是有用到的地方。</li>
<li>就 <code>*nix</code> 的 <strong>API</strong> 来说，<code>sendto</code> 和  <code>write</code> 的区别十分明显，便是一个需要在参数中提供目标主机的各类信息，而后者则不需要提供。同样的道理<code>recvfrom</code>和<code>read</code>也是如此。</li>
<li>这个代码只是做演示而已，所以将代码置于无限循环当中，现实中可以自行定义出口条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上是 UDP 的一些简单说明，入门足矣，并未详细叙述某些 函数 的具体用法，而是用实际例子来体现。<br>在 记录 TCP 之前，还是需要讲一个函数 shutdown</p>
</blockquote>
<ul>
<li><code>shutdown</code> 与 <code>close(closesocket)</code><ul>
<li>首先要知道，网络通信一般而言是双方的共同进行的，换而言之就是双向的，一个方向只用来发送消息，一个方向只用来读取消息。</li>
<li>这就导致了，在结束套接字通信的时候，需要关闭两个方向的通道(暂时叫它们通道)，那同时关闭不行吗？可以啊<ul>
<li><code>close(sock); // closesocket(sock); FOR Windows PlatForm</code> 就是这么干的，同时断开两个方向的连接。</li>
<li>简单的通信程序或者单向通信程序这么做的确无甚大碍，但是万一在结束通信的时候需要接收最后一个信息那该怎么办？<ul>
<li>假设通信结束，客户端向服务器发送 “Thank you”</li>
<li>服务器需要接收这个信息，之后才能关闭通信</li>
<li>问题就在这之间，服务器并不知道客户端会在通信结束后的什么时刻传来信息</li>
<li>所以我们选择在通信完成后先关闭 服务器的 发送通道(写流)，等待客户端发来消息后，关闭剩下的 接收通道(读流)</li>
</ul>
</li>
</ul>
</li>
<li>发送端：<pre><code><span class="comment">/* 假设有一个 TCP 的连接，此为客户端 */</span>
write<span class="comment">(sock, "Thank you", 10)</span>;
close<span class="comment">(sock)</span>; <span class="comment">// 写完直接关闭通信</span>
</code></pre></li>
<li>接收端：<pre><code><span class="comment">/* 此为服务器 */</span>
<span class="comment">/* 首先关闭写流 */</span>
shutdown(sock_c, SHUT_WR);
<span class="keyword">read</span>(sock_c, get_mess, GET_MAX);
printf(<span class="string">"Message : %s\n"</span>, get_mess);
<span class="keyword">close</span>(sock_c);
<span class="keyword">close</span>(sock_s); <span class="comment">// 关闭两个套接字是因为 TCP 服务器端的需要，后续会记录</span>
</code></pre></li>
<li>代码解释<ul>
<li><code>shutdown</code> 函数的作用就是 可选择的关闭那个方向的输出<ul>
<li><code>int shutdown(int sock, int howto);</code></li>
<li><code>sock</code> 代表要操作的套接字</li>
<li><code>howto</code>有几个选择  <ul>
<li><strong> *nix </strong> : <code>SHUT_RD</code> <code>SHUT_WR</code> <code>SHUT_RDWR</code></li>
<li><strong> Windows </strong> : <code>SD_RECEIVE</code> <code>SD_SEND</code> <code>SD_BOTH</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="停下来">停下来</h3><ol>
<li>程序员应该越来越来，做的事情应该越来越少，但是能达到的成就应该越来越多</li>
<li>在 IPv6 出现的今天，网络编程已经开始向简洁和强大靠近，即便是身为底层语言的 C语言</li>
<li>实际上由于 C语言 并没有自己的<strong>网络库</strong>， 故为了能进行网络编程，不得不依赖于系统函数，这就是所谓的<strong>系统编程</strong>， 你已经是一个系统程序员了。</li>
<li>而 系统函数 随着时代的变化，正在不断完善，增加(几乎没有废除的先例，所以不用担心之前的程序无法运行)。</li>
<li>相应的，由于以前的网络编程只适合于 IPv4 的地址，自从出现了 IPv6, 我们需要一套全新的方式，正好他来了。</li>
</ol>
<h3 id="新时代的_套接字网络编程">新时代的 套接字网络编程</h3><ol>
<li>首先有几个结构体，以及一个接口十分重要及常用：<ul>
<li><code>struct sockaddr_in6</code> ： 代表的是 IPv6 的地址信息</li>
<li><code>struct addrinfo</code> : 这是一个通用的结构体，里面可以存储 IPv4 或 IPv6 类型地址的信息</li>
<li><code>getaddrinfo</code> ： 这是一个十分方便的接口，在上述 UDP 程序中许多<strong>手动填写</strong>的部分，都能够省去，有该函数替我们完成</li>
</ul>
</li>
<li><p>改写一下上方的例子：</p>
<ul>
<li><p>接收端：</p>
<pre><code><span class="type">int</span> sock; /* 套接字 */
socklen_t addr_len; /* 发送端的地址长度，用于 recvfrom */
<span class="type">char</span> mess[<span class="number">15</span>];
<span class="type">char</span> get_mess[<span class="type">GET_MAX</span>]; /* 后续版本使用 */
struct sockaddr_in host_v4; /* <span class="type">IPv4</span> 地址 */
struct sockaddr_in6 host_v6; /* <span class="type">IPv6</span> 地址 */
struct addrinfo easy_to_use; /* 用于设定要获取的信息以及如何获取信息 */
struct addrinfo *<span class="literal">result</span>;    /* 用于存储得到的信息(需要注意内存泄露) */

/* 准备信息 */
memset(&amp;easy_to_use, <span class="number">0</span>, sizeof easy_to_use);
easy_to_use.ai_family = <span class="type">AF_UNSPEC</span>; /* 告诉接口，我现在还不知道地址类型 */
easy_to_use.ai_flags = <span class="type">AI_PASSIVE</span>; /* 告诉接口，稍后“你”帮我填写我没明确指定的信息 */
easy_to_use.ai_socktype = <span class="type">SOCK_DGRAM</span>; /* <span class="type">UDP</span> 的套接字 */
/* 其余位都为 <span class="number">0</span> */

/* 使用 getaddrinfo 接口 */
getaddrinfo(<span class="type">NULL</span>, argv[<span class="number">1</span>], &amp;easy_to_use, &amp;<span class="literal">result</span>); /* argv[<span class="number">1</span>] 中存放字符串形式的 端口号 */

/* 创建套接字，此处会产生两种写法，但更保险，可靠的写法是如此 */
/* 旧式方法
*  sock = socket(<span class="type">PF_INET</span>, <span class="type">SOCK_DGRAM</span>, <span class="number">0</span>);
*/
/* 把<span class="type">IP</span> 和 端口号信息绑定在套接字上 */
/* 旧式方法
*  memset(&amp;recv_host, <span class="number">0</span>, sizeof(recv_host));
*  recv_host.sin_family = <span class="type">AF_INET</span>;
*  recv_host.sin_addr.s_addr = htonl(<span class="type">INADDR_ANY</span>);/* 接收任意的<span class="type">IP</span> */
*  recv_host.sin_port = htons(<span class="number">6000</span>); /* 使用<span class="number">6000</span> 端口号 */
*  <span class="keyword">bind</span>(sock, (struct sockaddr *)&amp;recv_host, sizeof(recv_host));
*/

<span class="keyword">for</span>(struct addrinfo * p = <span class="literal">result</span>; p != <span class="type">NULL</span>; p = p-&gt;ai_next) /* 该语法需要开启 -std=gnu99 标准*/
{
  sock = socket(<span class="literal">result</span>-&gt;ai_family, <span class="literal">result</span>-&gt;ai_socktype, <span class="literal">result</span>-&gt;ai_protocol);
  <span class="keyword">if</span>(sock == -<span class="number">1</span>)
    <span class="keyword">continue</span>;
  <span class="keyword">if</span>(<span class="keyword">bind</span>(sock, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="number">1</span>)
  {
    close(sock);
    <span class="keyword">continue</span>;
  }
  <span class="keyword">break</span>; /* 如果能执行到此，证明建立套接字成功，套接字绑定成功，故不必再尝试。 */
}

/* 进入接收信息的状态 */
//recvfrom(sock, mess, <span class="number">15</span>, <span class="number">0</span>, (struct sockaddr *)&amp;send_host, &amp;addr_len);
switch(<span class="literal">result</span>-&gt;ai_socktype)
{
  <span class="keyword">case</span> <span class="type">AF_INET</span> :
    addr_len = sizeof host_v4;
    recvfrom(sock, mess, <span class="number">15</span>, <span class="number">0</span>, (struct sockaddr *)&amp;host_v4, &amp;addr_len);
    <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="type">AF_INET6</span>:
    addr_len = sizeof host_v6
    recvfrom(sock, mess, <span class="number">15</span>, <span class="number">0</span>, (struct sockaddr *)&amp;host_v6, &amp;addr_len);
    <span class="keyword">break</span>;
  default:
    <span class="keyword">break</span>;
}
freeaddrinfo(<span class="literal">result</span>); /* 释放这个空间，由getaddrinfo分配的 */
/* 接收完成，关闭套接字 */
close(sock);
</code></pre><ul>
<li><p>代码解释：</p>
<ul>
<li><p>首先解释几个新的结构体</p>
<ol>
<li><p><code>struct addrinfo</code> 这个结构体的内部顺序对于 <code>*nix</code> 和 <code>Windows</code> 稍有不同，以 <code>*nix</code> 为例</p>
<pre><code><span class="keyword">struct</span> addrinfo{
  <span class="keyword">int</span> ai_flags;
  <span class="keyword">int</span> ai_family;
  <span class="keyword">int</span> ai_socktype;
  <span class="keyword">int</span> ai_protocol;
  socklen_t ai_addrlen;
  <span class="keyword">struct</span> sockaddr * ai_addr; <span class="comment">/* 存放结果地址的地方 */</span>
  <span class="keyword">char</span> * ai_canonname; <span class="comment">/* 忽略它吧，很长一段时间你无须关注它 */</span>
  <span class="keyword">struct</span> addrinfo * ai_next; <span class="comment">/* 一个域名/IP地址可能解析出多个不同的 IP */</span>
};
</code></pre></li>
<li><code>ai_family</code> 如果设定为 <code>AF_UNSPEC</code> 那么在调用 <code>getaddrinfo</code> 时，会自动帮你确定，传入的地址是什么类型的</li>
<li><code>ai_flags</code>  如果设定为 <code>AI_PASSIVE</code> 那么调用 <code>getaddrinfo</code> 且向其第一个参数传入 <code>NULL</code> 时会自动绑定自身 IP，相当于设定 <code>INADDR_ANY</code></li>
<li><code>ai_socktype</code> 就是要创建的套接字类型，这个必须明确声明，系统没法预判(日后人工智能说不定呢?)</li>
<li><code>ai_protocol</code> 一般情况下我们设置为 <code>0</code>，含义可以自行查找，例如 <code>MSDN</code> 或者 <code>UNP</code></li>
<li><code>ai_addr</code>    这里保存着结果，可以通过 调用<code>getaddrinfo</code><strong>之后</strong> 的<strong>第四个参数</strong>获得。</li>
<li><code>ai_addrlen</code> 同上</li>
<li><code>ai_next</code>    同上</li>
<li><p><code>getaddrinfo</code> 强大的接口函数</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * node, <span class="keyword">const</span> <span class="keyword">char</span> * service,
                  <span class="keyword">const</span> <span class="keyword">struct</span> addrinfo * hints, <span class="keyword">struct</span> addrinfo ** res)</span></span>;
</code></pre></li>
<li>通俗的说这几个参数的作用</li>
<li><code>node</code> 便是待获取或者待绑定的 <strong>域名</strong> 或是 <strong>IP</strong>，也就是说，这里可以直接填写域名，由操作系统来转换成 <strong>IP</strong> 信息，或者直接填写<strong>IP</strong>亦可，是以字符串的形式</li>
<li><code>service</code> 便是端口号的意思，也是字符串形式</li>
<li><code>hints</code> 通俗的来说就是告诉接口，我需要你反馈哪些信息给我(第四个参数)，并将这些信息填写到第四个参数里。</li>
<li><code>res</code> 便是保存结果的地方，需要注意的是，这个结果在API内部是动态分配内存了，所以使用完之后需要调用另一个接口(<code>freeaddrinfo</code>)将其释放</li>
<li><p>实际上对于现代的　套接字编程 而言，多了几个新的存储 IP 信息的结构体，例如 <code>struct sockaddr_in6</code> 和 <code>struct sockaddr_storage</code> 等。</p>
<ul>
<li><p>其中，前者是后者的大小上的子集，即一个 <code>struct storage</code> 一定能够装下一个 <code>struct sockaddr_in6</code>,具体(实际上根本看不到有意义的实现)</p>
<pre><code><span class="keyword">struct</span> sockaddr_in6{
  u_int16_t sin6_family;
  u_int16_t sin6_port;
  u_int32_t sin6_flowinfo; <span class="comment">/* 暂时忽略它 */</span>
  <span class="keyword">struct</span> in6_addr sin6_addr; <span class="comment">/* IPv6 的地址存放在此结构体中 */</span>
  u_int32_t sin_scope_id;  <span class="comment">/* 暂时忽略它 */</span>
};
<span class="keyword">struct</span> in6_addr{
  <span class="keyword">unsigned</span> <span class="keyword">char</span> s6_addr[<span class="number">16</span>];
}
------------------------------------------------------------
<span class="keyword">struct</span> sockaddr_storage{
  sa_family_t ss_family; <span class="comment">/* 地址的种类 */</span>
  <span class="keyword">char</span> __ss_pad1[_SS_PAD1SIZE]; <span class="comment">/* 从此处开始，不是实现者几乎是没办法理解 */</span>
  <span class="keyword">int64_t</span> __ss_align;           <span class="comment">/* 从名字上可以看出大概是为了兼容两个不同 IP 类型而做出的妥协 */</span>
  <span class="keyword">char</span> __ss_pad2[_SS_PAD2SIZE]; <span class="comment">/* 隐藏了实际内容，除了 IP 的种类以外，无法直接获取其他的任何信息。 */</span>
  <span class="comment">/* 在各个*nix 的具体实现中， 可能有不同的实现，例如 `__ss_pad1` ， `__ss_pad2` , 可能合并成一个 `pad` 。 */</span>
};
</code></pre><p>在实际中，我们往往不需要为不同的IP类型声明不同的存储类型，直接使用 <code>struct sockaddr_storage</code> 就可以，使用时直接<strong>强制转换类型</strong>即可</p>
</li>
</ul>
</li>
<li><p>改写上方  <strong>接收端</strong> 例子中，进入接收信息的状态部分</p>
<pre><code>/<span class="keyword">*</span> 首先将多于的变量化简 <span class="keyword">*</span>/
// - struct sockaddr_in host_v4; /<span class="keyword">*</span> IPv4 地址 <span class="keyword">*</span>/
// - struct sockaddr_in6 host_v6; /<span class="keyword">*</span> IPv6 地址
struct sockaddr_storage host_ver_any; /<span class="keyword">*</span> + 任意类型的 IP 地址 <span class="keyword">*</span>/
...
/<span class="keyword">*</span> 进入接收信息的状态部分 <span class="keyword">*</span>/
recvfrom(sock, mess, 15, 0, (struct sockaddr <span class="keyword">*</span>)&amp;host_ver_any, &amp;addr_len); /<span class="keyword">*</span> 像是又回到了只有 IPv4 的年代<span class="keyword">*</span>/
</code></pre></li>
<li><p>补充完整上方对应的 <strong>发送端</strong> 代码</p>
<pre><code><span class="type">int</span> sock;
<span class="keyword">const</span> <span class="type">char</span>* mess = <span class="string">"Hello Server!"</span>;
<span class="type">char</span> get_mess[<span class="type">GET_MAX</span>]; /* 后续版本使用 */
struct sockaddr_storage recv_host; /* - struct sockaddr_in recv_host; */
struct addrinfo tmp, *<span class="literal">result</span>;
struct addrinfo *p;
socklen_t addr_len;

/* 获取对端的信息 */
memset(&amp;tmp, <span class="number">0</span>, sizeof tmp);
tmp.ai_family = <span class="type">AF_UNSPEC</span>;
tmp.ai_flags = <span class="type">AI_PASSIVE</span>;
tmp.ai_socktype = <span class="type">SOCK_DGRAM</span>;
getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;tmp, &amp;<span class="literal">result</span>); /* argv[<span class="number">1</span>] 代表对端的 <span class="type">IP</span>地址， argv[<span class="number">2</span>] 代表对端的 端口号 */

/* 创建套接字 加 绑定*/
<span class="keyword">for</span>(p = <span class="literal">result</span>; p != <span class="type">NULL</span>; p = p-&gt;ai_next)
{
  sock = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);  /* - sock = socket(<span class="type">PF_INET</span>, <span class="type">SOCK_DGRAM</span>, <span class="number">0</span>); */
  <span class="keyword">if</span>(sock == -<span class="number">1</span>)
    <span class="keyword">continue</span>;
  /* 此处少了绑定 <span class="keyword">bind</span> 函数，因为作为发送端不需要讲对端的信息 绑定 到创建的套接字上。 */  
  <span class="keyword">break</span>; /* 找到就可以退出了，当然也有可能没找到，那么此时 p 的值一定是 <span class="type">NULL</span> */
}
<span class="keyword">if</span>(p == <span class="type">NULL</span>)
{
  /* 错误处理 */
}
/* -// 绑定  
memset(&amp;recv_host, <span class="number">0</span>, sizeof(recv_host));
recv_host.sin_family = <span class="type">AF_INET</span>;
recv_host.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);
recv_host.sin_port = htons(<span class="number">6000</span>);
*/

/* 发送信息 */
/* 在此处，发送端的<span class="type">IP</span>地址和端口号等各类信息，随着这个函数的调用，自动绑定在了套接字上 */
sendto(sock, mess, strlen(mess), <span class="number">0</span>, p-&gt;ai_addr, p-&gt;ai_addrlen);
/* 完成，关闭 */
freeaddrinfo(<span class="literal">result</span>); /* 实际上这个函数应该在使用完 <span class="literal">result</span> 的地方就予以调用 */
close(sock);                
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概念">概念</h2><ul>
<li>最具误导性的当属于 <code>TCP/IP</code> 协议了<ul>
<li>所谓 <code>TCP/IP</code> 协议指的并不是一个协议，往往在生活中听见的术语如：<strong>IP地址</strong>， <strong>TCP连接</strong> 等，总会被误导，以为就是一个东西</li>
<li>实际上它们都是彼此独立的 <strong>协议</strong> ，只不过会相互合作罢了</li>
<li><code>TCP/IP</code>说的是一个 <strong>协议族</strong> ，也就是说是一堆协议的统称</li>
</ul>
</li>
<li>对比 <strong>OSI</strong> 和 <strong>TCP/IP</strong> 参考模型：</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层 表示层 会话层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层 物理层</td>
<td>网络接口层</td>
</tr>
</tbody>
</table>
<ul>
<li>其中最常接触的<ul>
<li>位于 <strong>网络层</strong> 的 <strong>IP</strong> 协议，大家所熟知的 <code>IP地址</code> 就是由它进行封装并传往下一层</li>
<li>位于 <strong>传输层</strong> 的 <strong>TCP/UDP</strong> 两个协议， 一个是面向连接(STREAM), 一个是面向数据(DGRAM)的，实际上还有一个但这里不记录。</li>
<li>查看自身 网络信息的办法<ul>
<li><code>*nix</code>: 在 <strong>Terminal</strong> 中输入 <code>ifconfig -a</code></li>
<li><code>Windows</code>: 在 <strong>PowerShell</strong> 中输入 <code>ipconfig</code>]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
      <category term="网络编程" scheme="//wushxin.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux记录]]></title>
    <link href="//wushxin.top/2015/09/20/Linux%E8%AE%B0%E5%BD%95.html"/>
    <id>//wushxin.top/2015/09/20/Linux记录.html</id>
    <published>2015-09-20T00:33:33.000Z</published>
    <updated>2015-09-20T01:23:19.132Z</updated>
    <content type="html"><![CDATA[<h2 id="源">源</h2><ul>
<li>因为国内的原因，没有办法直接使用官方的源，速度有时候会过慢，在高校内部的人可以回比外边更好一些</li>
<li>而经常出现是根据网上搜索(百度)，出来的结果，大都是直接换源，导致很多错误例如 <code>Some Index fail to ...</code> 之类的错误，这是由于每个版本的 Linux 的源都有细微的差别。以最有名的基于 <strong>Debian</strong> 的 <code>Ubuntu</code> 为例子</li>
<li><p>例如<strong>Ubuntu 14.04</strong> 的163源应该是：</p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
</code></pre></li>
<li><p><strong>Ubuntu 15.04</strong> 的163源应该是：<a id="more"></a></p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiverse</span>
eb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiverse</span>
</code></pre><p>区别就在于源中的 <strong>vivid 和 trusty</strong><br>相应的其他版本亦有自己的代号，详情<a href="http://wiki.ubuntu.org.cn/Qref/Source" target="_blank" rel="external">请见此处</a></p>
</li>
<li><p>根据中文 <a href="http://wiki.ubuntu.org.cn" target="_blank" rel="external">Ubuntu官网</a> 提供的信息，有些源已经无法被公众使用。(本文此处更新于2015/09/20)</p>
<ul>
<li><p>完全失效的服务器：      </p>
<ul>
<li>青岛大学更新服务器（教育网/山东青岛移动专线双线服务器），由 OSQDU维护，位于青岛大学。包含开源镜像和Opera、马克思主义文库等其他镜像。<ul>
<li>Geekbone.org更新服务器（上海电信服务器，由 SHLUG /上海Linux用户群维护）,现跳转至搜狐服务器。</li>
<li>由Love4Taylor维护的开源镜像站，位于香港新世界电讯有限公司CDN节点上，包含Deepin 镜像，可能包含其它开源镜像。 </li>
<li>上述服务器部分可能改为校内/地区访问。 </li>
</ul>
</li>
</ul>
<ul>
<li>部分失效的服务器</li>
<li>西南大学开源社区维护的西南大学镜像中已经取消了主要发行版镜像，但有一些学习资源。</li>
<li>由电子科技大学Linux 用户组维护的UESTC LUG软件源中包含其它发行版的镜像。</li>
<li>由电子科技大学学生之家维护的电子科大星辰工作室镜像中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。</li>
<li>由We·Cloud云技术小组维护的大连东软信息学院的We - 开源镜像站中已经取消了 Ubuntu 镜像，但有Ubuntu 光盘镜像和其它发行版。</li>
<li>由西南林业大学计信学院维护的西南林大镜像中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。</li>
<li>由LUPA开源社区维护的LupaWorld更新服务器（浙江杭州电信/联通双线服务器）中已经取消了 Ubuntu 镜像，但有其它发行版的镜像。 <h2 id="update_&amp;&amp;_upgrade">update &amp;&amp; upgrade</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>这大概是最熟悉的两个参数之一，但是经常看见类似如此错误：<br><code>0 upgraded, 0 newly installed, 0 to remove and 3 not upgraded</code></p>
</li>
<li><p><code>not upgraded</code> 的解决办法是: ·<br><code>$ sudo apt-get -u dist-upgrade</code></p>
</li>
</ul>
<h2 id="Linux_of_Qt5">Linux of Qt5</h2><p>在Ubuntu编译Qt5工程时出现了 </p>
<p><code>can not find -lGL</code></p>
<p>这是为什么?在Qt4时代并没有这种情况</p>
<p>经过查找,发现<strong>Qt5在这个版本自动加入了openGL的支持</strong>,而有的平台并没有默认拥有</p>
<p><strong>(Windows默认有openGL,Linux却没有完全)</strong></p>
<p>可以通过安装 <code>libglut-dev</code> 来进行修复</p>
<p><code>sudo apt-get install libglut-dev</code></p>
<p>稍微解读一下也能知道<code>-lGL==&gt;-linkopenGL</code>的意思</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="源">源</h2><ul>
<li>因为国内的原因，没有办法直接使用官方的源，速度有时候会过慢，在高校内部的人可以回比外边更好一些</li>
<li>而经常出现是根据网上搜索(百度)，出来的结果，大都是直接换源，导致很多错误例如 <code>Some Index fail to ...</code> 之类的错误，这是由于每个版本的 Linux 的源都有细微的差别。以最有名的基于 <strong>Debian</strong> 的 <code>Ubuntu</code> 为例子</li>
<li><p>例如<strong>Ubuntu 14.04</strong> 的163源应该是：</p>
<pre><code>deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span>
deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span>
</code></pre></li>
<li><p><strong>Ubuntu 15.04</strong> 的163源应该是：]]>
    
    </summary>
    
      <category term="Linux" scheme="//wushxin.top/tags/Linux/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《我为什么学C》]]></title>
    <link href="//wushxin.top/2015/08/31/%E3%80%8A%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C%E3%80%8B.html"/>
    <id>//wushxin.top/2015/08/31/《我为什么学C》.html</id>
    <published>2015-08-31T13:56:34.000Z</published>
    <updated>2015-10-07T02:07:15.018Z</updated>
    <content type="html"><![CDATA[<h4 id="集结成电子书_《Real_C》">集结成电子书 《<a href="http://wrestle.gitbooks.io/whyilearnc/" target="_blank" rel="external">Real C</a>》</h4><h4 id="目录">目录</h4><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/" target="_blank" rel="external">介绍</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/Seperate-0.html" target="_blank" rel="external">第一部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/00.html" target="_blank" rel="external">前序</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/01.html" target="_blank" rel="external">序</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/02.html" target="_blank" rel="external">C代码风格</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/04.html" target="_blank" rel="external">C代码规范</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-0/03.html" target="_blank" rel="external">变量</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/Seperate-1.html" target="_blank" rel="external">第二部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/10.html" target="_blank" rel="external">指针(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/11.html" target="_blank" rel="external">指针(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/12.html" target="_blank" rel="external">预处理器</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/13.html" target="_blank" rel="external">效率至上(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/14.html" target="_blank" rel="external">效率至上(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/15.html" target="_blank" rel="external">未曾领略的风景</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-1/16.html" target="_blank" rel="external">C线程和Glib的视角</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/Seperate-2.html" target="_blank" rel="external">第三部分</a><ul>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/20.html" target="_blank" rel="external">错误处理</a> </li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/21.html" target="_blank" rel="external">开始行动</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/22.html" target="_blank" rel="external">单线程备份(上)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/23.html" target="_blank" rel="external">单线程备份(下)</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/24.html" target="_blank" rel="external">多线程备份</a></li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-2/25.html" target="_blank" rel="external">总结</a></li>
</ul>
</li>
<li><a href="http://wrestle.gitbooks.io/whyilearnc/content/book/chapter-3/Seperate-3.html" target="_blank" rel="external">第四部分</a> </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="集结成电子书_《Real_C》">集结成电子书 《<a href="http://wrestle.gitbooks.io/whyilearnc/" target="_blank" rel="external">Real C</a>》</h4><h4 id="目录"]]>
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Practical cpp]]></title>
    <link href="//wushxin.top/2015/07/21/Practical-cpp.html"/>
    <id>//wushxin.top/2015/07/21/Practical-cpp.html</id>
    <published>2015-07-21T03:08:13.000Z</published>
    <updated>2015-07-25T07:01:01.609Z</updated>
    <content type="html"><![CDATA[<h4 id="try-throw-catch_三段式">try-throw-catch 三段式</h4><p>这是异常抛出的方式，简单的用法便是在外部使用的try-catch形式：</p>
<pre><code><span class="comment">//Code-1</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> get_num;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; get_num;
    <span class="keyword">try</span>
    {
        <span class="keyword">if</span>(get_num &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> get_num
        <span class="comment">//Something happen</span>
    }
    <span class="keyword">catch</span>(<span class="keyword">int</span> e) <span class="comment">//此处括号内的参数的类型和抛出的类型需要一致</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number "</span> &lt;&lt; get_num &lt;&lt; <span class="string">" is negative"</span>
                  &lt;<span class="built_in">std</span>::endl;
    }
    <span class="comment">//...</span>
}
</code></pre><ul>
<li><p>这是最简单的使用，在三段式中，<code>try</code>充当的是正常代码块，而<code>catch</code>则是对于抛出异常的处理。<code>catch</code> 可以不止一个，但一定要合理，实际来说，三段式能少用尽量少用，我们一般是这么使用三段式的： <a id="more"></a></p>
<ul>
<li>在函数中使用三段式，例如函数调用里<code>throw</code>一个异常</li>
<li>在调用函数的地方的附近使用三段式获取一个异常</li>
<li><p>异常被抛出后一定要有接收的<code>catch</code>，否则会默认调用<code>unexcept()</code>，从而紧接着默认调用<code>terminate()</code>终止程序。</p>
<pre><code><span class="comment">//Code-2</span>
<span class="comment">//head.h</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;...&gt; <span class="comment">//各种必要的头文件 </span></span>
<span class="keyword">class</span> ExceptionText{
<span class="keyword">public</span>:
        ExceptionTest(){}
        ExceptionTest(<span class="built_in">std</span>::<span class="built_in">string</span> err_mes): message(err_mes)    {}
        <span class="comment">//调用接口</span>
        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">show_message</span><span class="params">()</span></span>{
            <span class="keyword">return</span> message;
        }
<span class="keyword">private</span>:
        <span class="built_in">std</span>::<span class="built_in">string</span> message;
};

<span class="keyword">class</span> ExceptionNumber{
};
</code></pre><p>这个类的作用在于抛出异常的时候，使用该类作为抛出对象的类型，<code>throw</code>可以抛出任意类型的异常。</p>
<pre><code><span class="comment">//Code-3</span>
<span class="comment">//run.cpp</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;...&gt;</span>
<span class="function"><span class="keyword">void</span> <span class="title">AddFunction</span><span class="params">()</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">TheMainFunction</span><span class="params">(<span class="keyword">double</span> args)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> SomeThingYouWant = <span class="number">0</span>;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; SomeThingYouWant; 
    <span class="keyword">try</span>
    {
        TheMainFunction(SomeThingYouWant);
    }
    <span class="keyword">catch</span>(ExceptionText t)
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.show_message();
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;
    }
    <span class="keyword">catch</span>(ExceptionNumber n) <span class="comment">// 抛出类型可以只定义类型，而不加任何具体实现</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number is not match the logic"</span>
              &lt;&lt; <span class="built_in">std</span>::endl;
    }
    <span class="keyword">catch</span>(...) <span class="comment">//这是默认的catch，...并不代表无限的参数，而是默认的意思，就像switch中的default.</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There has some thing bad happen to us"</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
</ul>
</li>
<li><p>在三段式中，可以有很多个<code>catch</code>，并且可以拥有一个默认的<code>catch</code>，在上述代码中，只要抛出类型不是<code>ExceptionText</code>和<code>ExceptionNumber</code>,抛出就会被默认<code>catch</code>所获取。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">4</span>
<span class="type">void</span> <span class="type">TheMainFunction</span>(double args)
{
    double <span class="literal">result</span>;
    <span class="keyword">if</span>(args &lt; <span class="number">0</span>)
        throw <span class="type">ExceptionText</span>(<span class="string">"The number is negative"</span>);
    <span class="keyword">else</span> <span class="keyword">if</span>(args == <span class="number">0</span>)
        throw <span class="type">ExceptionText</span>(<span class="string">"The number is Zero"</span>);
    <span class="literal">result</span> = (args-<span class="number">1</span>) / args;

    <span class="keyword">while</span>(<span class="literal">result</span> &gt; <span class="number">0</span>)
        <span class="literal">result</span> -= <span class="number">0</span>.<span class="number">01</span>;
    <span class="keyword">if</span>(<span class="literal">result</span> &lt; <span class="number">0</span>)
        throw <span class="type">ExceptionNumber</span>;
    <span class="keyword">else</span>
        throw <span class="number">0</span>; //只要是<span class="type">ExceptionText</span>和<span class="type">ExceptionNumber</span>之外的任意类型都可以。    
}
</code></pre><p>  在TheMainFunction的定义里，可以添加一些限制条件，来限制抛出的类型：</p>
<pre><code>void <span class="function"><span class="title">TheMainFunction</span><span class="params">(double)</span></span> <span class="function"><span class="title">throw</span><span class="params">(ExceptionText, ExceptionNumber)</span></span>
<span class="comment">//...</span>
</code></pre><p>这样抛出类型就只有<code>ExceptionText</code>和<code>ExceptionNumber</code>两种了。</p>
</li>
<li><p>函数的级别的 <code>try-catch</code></p>
<ul>
<li><p>所谓函数级别就是，使用在函数身上的 <code>try</code></p>
<pre><code><span class="comment">//Code-5</span>
<span class="keyword">class</span> BaseText{
    <span class="built_in">string</span> plantText;
<span class="keyword">public</span>:
    <span class="keyword">class</span> BaseException{}; <span class="comment">//定义一个空类，来定义抛出类型</span>
                           <span class="comment">//类似Java里的 nested 语法</span>
    BaseTest(<span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="keyword">nullptr</span>): plantText(msg){}
<span class="comment">//...</span>
<span class="keyword">class</span> ExceptionText : <span class="keyword">public</span> BaseText{
<span class="keyword">public</span>:
    ExceptionText(<span class="keyword">const</span> <span class="keyword">char</span>* msgError = <span class="keyword">nullptr</span>) 
    <span class="keyword">throw</span>(BaseException) <span class="comment">//限定抛出类型只能是BaseException</span>
    <span class="keyword">try</span> : BaseText(msgError)
    {
        <span class="comment">//这里是正常的构造函数的函数体</span>
    }<span class="keyword">catch</span>(BaseException&amp;)
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In the catch body!"</span> &lt;&lt; <span class="built_in">std</span>::endl;
    }
<span class="comment">//...</span>
</code></pre></li>
<li><p>语法上， <code>try</code> 关键字紧跟在函数参数列表之后，如果是构造函数，则在初始化列表之前， <code>try</code> 的 <strong>block</strong> 中就是正常的函数体。</p>
</li>
</ul>
</li>
<li><p>对于抛出类型的限定，尽量使用它。并且在获取异常的时候，使用引用接收它。这不仅考虑到效率，而且是因为考虑到了继承类的上切问题(例如一个继承了 logic_error 的异常类对象，使用 logic_error 进行按值传递，会导致信息丢失)。</p>
</li>
<li>可以在构造函数中抛出异常(<strong>移动构造函数</strong>不要)，并额外设置一个标志去检查它，但不要再析构函数中抛出异常！</li>
<li><p>但是在 <strong>C++11</strong>之后，一个函数如果要限定其没有抛出，则不再使用 <code>throw()</code>，而使用新关键字 <code>noexcept</code></p>
<pre><code><span class="comment">//Code-6</span>
<span class="comment">//void noException() throw() { //C++98以前</span>
<span class="function"><span class="keyword">void</span> <span class="title">noException</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">true</span>)</span></span>{ <span class="comment">//C++11以后</span>
                                   <span class="comment">//此时 noexcept作为一个操作符存在</span>
    <span class="keyword">for</span>(<span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)
        <span class="keyword">if</span>(i == <span class="number">2</span>)
            <span class="keyword">throw</span> <span class="string">"Thorw!But You will Never See those"</span>;
}
</code></pre><p>可以将该操作符用于模板，以此来决定一个函数是否为一个可抛出异常 的函数</p>
</li>
</ul>
<p>虽然三段式看起来十分实用，但是我们依然应该尽可能的减少他们的使用频率。</p>
<h4 id="标准_C++_异常">标准 C++ 异常</h4><ul>
<li>比起自己定义的异常处理，标准库自带的要更加快速</li>
<li>头文件 <code>&lt;exception&gt;</code> <code>&lt;stdexcept&gt;</code>,后者 <strong>include</strong> 前者</li>
<li>异常类 <code>exception</code> &lt;- <code>logic_error</code>，<code>runtime_error</code><ul>
<li>后两者继承自前者，通常用法是构造后两者的对象，设置错误信息，并调用其接口 <code>what()</code>，其中 <strong>what()</strong> 接口继承自类 <code>exception</code>， 但是由于 <code>exception</code> 的构造函数并没有提供接口让用户设置错误信息，故总是用其两个继承类</li>
<li>具体用法有两种：<ol>
<li>继承法，通过让自己的类继承类 <code>logic_error</code> 或者 <code>runtime_error</code>(或者其派生类) 来实现使用它们的目的</li>
<li>成员法，通过让自己的类拥有一个嵌套类，专门用来抛出错误信息，类中拥有 <code>logic_error</code> 或者 <code>runtime_error</code>(或者其派生类)的成员，并在必要时设置构造这个类对象</li>
</ol>
</li>
<li><a href="http://zh.cppreference.com/w/cpp/error" target="_blank" rel="external">异常处理参考网址，维基百科(无须翻墙)</a></li>
<li>补充上述 <code>logic_error</code> 的 派生类<ol>
<li><code>bad_cast</code> 是 <strong>dynamic_cast</strong> 失败之后，抛出的异常，与(RTTI机制有关) -&gt; <code>#include &lt;typeinfo&gt;</code></li>
<li><code>bad_typeid</code> 也与 RTTI 机制有关 -&gt; <code>#include &lt;typeinfo&gt;</code></li>
</ol>
</li>
<li>补充 <code>runtime_error</code> 的 派生类<ol>
<li><code>bad_alloc</code> 如果 <strong>new</strong> 分配内存失败，则会抛出这个异常 -&gt; <code>#include &lt;new&gt;</code></li>
</ol>
</li>
<li><a href="http://zh.cppreference.com/w/cpp/error/exception" target="_blank" rel="external">其余补充</a></li>
<li>补充的继承类不再 <code>&lt;stdexcept&gt;</code> 中声明定义而在各自的头文件中声明定义。</li>
<li><strong>C++11</strong> 之后的标准弃用了许多异常类，也重新有了许多的类。</li>
</ul>
</li>
</ul>
<h4 id="模板">模板</h4><ul>
<li><p>模板的三种用法：</p>
<ol>
<li>用于待定类型的占位：</li>
<li>用于定义维数</li>
<li><p>将模板类当成模板参数进行传递</p>
<pre><code><span class="comment">//Code-7</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> tpOfPara, <span class="comment">//通常的用法</span>
         <span class="keyword">typename</span>&lt;<span class="keyword">typename</span> secT, 
                  <span class="keyword">typename</span> = <span class="built_in">std</span>::allocator&lt;secT&gt;&gt; <span class="keyword">class</span> tpClName, <span class="comment">//传递模板类作为模板参数</span>
         <span class="built_in">std</span>::size_t consDim = <span class="number">100</span>&gt; <span class="comment">//使用无类型的模板参数，且使用了默认参数</span>
    <span class="keyword">class</span> ClDefByMe{
        tpClName&lt;tpOfPara&gt; priMem_1;
        tpOfPara            priMem_2;
        <span class="keyword">int</span>                testMem[consDim];
    pubic:
        <span class="function">explict <span class="title">ClDefByMe</span><span class="params">(<span class="keyword">const</span> tpClName&lt;tpOfPara&gt;&amp;, 
                          <span class="keyword">const</span> tpOfPara&amp;)</span></span>;
<span class="comment">//...</span>
ClDefByMe&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&gt; tmp1;
</code></pre></li>
</ol>
<ul>
<li>用于类的时候，模板可以使用默认参数，但是用在函数的时候却不行。</li>
<li>在第二句中，为了传递特定的模板容器 <strong>vector</strong>，其声明中包含了一个默认模板参数，在此处需要显式的写出，否则无法编译通过，<strong>allocator</strong> 在 <code>&lt;memory&gt;</code> 中声明定义</li>
</ul>
</li>
<li><p>关键字 <strong>typename</strong></p>
<ul>
<li>在 <strong>C++11</strong>之后， <strong>typename</strong> 也可以用在模板参数中，之前只能使用 <strong>class</strong> 关键字，这两个关键字的效果一致</li>
<li><p>在模板类的定义中，我们可以使用 <code>typename</code> 关键字来获取模板参数中的<strong>内嵌类型</strong></p>
<pre><code><span class="comment">//Code-8</span>
<span class="keyword">class</span> clFirst{
    <span class="keyword">int</span> mem1;
<span class="keyword">public</span>:
    <span class="keyword">class</span> nestcl{
        <span class="keyword">int</span> mem2;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">void</span> <span class="title">showMem</span><span class="params">()</span> </span>{<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mem2 = "</span> &lt;&lt; <span class="built_in">std</span>::endl;}
    };
}; <span class="comment">//用于传递的类</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">class</span> ClDefByMe{
        <span class="keyword">typename</span> T::nestcl tmpMem;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{ tmpMem.showMem(); }
    };
<span class="comment">//...</span>
ClDefByMe&lt;clFirst&gt; tmp;
tmp.show();
</code></pre><ul>
<li>此时如果引用过来的不是内嵌类型，而是别名(typedef)的话，亦是可以。</li>
<li>如果<code>T::nestcl</code>是类型 T的静态类型成员 就无需添加关键字 <code>typename</code></li>
<li>对于 模板函数 而言,这一性质同样起作用,常用来声明定义某种类型(STL容器)的 <strong>迭代器(Iterator)</strong>,方便使用.    </li>
</ul>
</li>
</ul>
</li>
<li><p><code>template</code> 关键字的另类用处    </p>
<ul>
<li><p>当在模板函数中调用一个模板类的成员函数，且该成员函数亦是模板的时候，需要使用<code>template</code> 关键字消除编译器的判定错误(将模板参数的左尖括号 &lt; 当成小于运算符)。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">9</span>
//引用<span class="type">Thinking</span> <span class="keyword">in</span> C++ 例子
//bitset例子
<span class="keyword">template</span>&lt;typename charT, size_t N&gt;
    basic_string&lt;charT&gt; bitsetToString(<span class="keyword">const</span> bitset&lt;N&gt;&amp; bs)
    {    
        <span class="keyword">return</span> bs. <span class="keyword">template</span> to_string&lt;charT, 
                                      char_traits&lt;charT&gt;,
                                      allocator&lt;charT&gt;&gt;();
    }
//此时<span class="keyword">template</span>关键字必不可少， -&gt; 操作符也是如此
//bitset
</code></pre></li>
<li><code>template</code> 关键字不可少的原因在于，当模板函数被解析(parsed)之后，编译器会认为 <code>to_string</code> 右边的尖括号 <code>&lt;</code> 是小于运算符，我们需要这个关键字来告诉编译器这是模板的语法。</li>
</ul>
</li>
<li><p>模板成员函数</p>
<ul>
<li><p>在模板类中声明定义模板成员函数，相当于嵌套。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">10</span>
<span class="keyword">template</span>&lt;typename typOne&gt;
    class <span class="type">ClDefByMe</span>{
    //...
    public:
        <span class="keyword">template</span>&lt;typename typTwo&gt; 
            <span class="type">ClDefByMe</span>(<span class="keyword">const</span> <span class="type">ClDefByMe</span>&lt;typTwo&gt; &amp;);
    ...
//如果类外定义
<span class="keyword">template</span> &lt;typename typOne&gt;
    <span class="keyword">template</span>&lt;typename typTwo&gt;
        <span class="type">ClDefByMe</span>&lt;typOne&gt;::<span class="type">ClDefByMe</span>(<span class="keyword">const</span> <span class="type">ClDefByMe</span>&lt;typTwo&gt; &amp;)
        {
            //...定义
        }
</code></pre></li>
<li>模板类中的模板成员函数的模板参数不必和类一样。</li>
<li><p>模板成员可以用在嵌套类上。</p>
<pre><code>//<span class="type">Code</span>-<span class="number">11</span>
<span class="keyword">template</span>&lt;typename typOne&gt;
    class <span class="type">ClDefByMe</span>{
    //...
    public:
        <span class="keyword">template</span>&lt;typename typThr&gt;
            class inner{
            //...
            public:
                <span class="type">void</span> lookFunc();
            };
    ...
<span class="keyword">template</span>&lt;typename typOne&gt; //定义 lookFunc
    <span class="keyword">template</span>&lt;typename typThr&gt;
        <span class="type">ClDefByMe</span>&lt;typOne&gt;::inner&lt;typThr&gt;::lookFunc()
        {
            //...函数体
        }
...
<span class="type">int</span> main()
{
    clDefByMe&lt;<span class="type">int</span>&gt;::inner&lt;long&gt; tmpObj;
    tmpObj.lookFunc();
    <span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre></li>
</ul>
</li>
<li><p>但是，模板成员函数不可是 <strong>虚函数</strong> <strong>(virtual)</strong> ，不过能够重载，重载的时候，可以让常规函数和模板函数混搭(即不一定需要模板重载模板，普通重载普通)。</p>
<ul>
<li>在选择哪个版本的函数方面，优先选择非模板函数，可以显式地强制调用模板函数版本通过在调用函数名后面，括号的前面，添加空参数的模板尖括号。</li>
</ul>
</li>
<li><p>模板函数常常可以省略模板参数，而交由编译器来推断所使用的参数类型，也可以自己显式传递。 </p>
<ul>
<li>例如上方的 <strong>Code-9</strong> 中的模板函数 <code>bitsetToString</code> 的定义可以改成： <code>return bs.to_string();</code> 产生的效果与此前代码一致。</li>
<li>这种有编译器干的事情里，如果出现了需要类型转换的情况，则会失败。 </li>
<li>在操作数组的时候，不妨使用 <strong>数组的引用</strong> 来代替单一指针，因为这样可以让编译器帮我们推断数组的维数，而不自自己显式传递，例如( <code>arrType (&amp;arr)[9][10]</code> ) </li>
<li><p>如果需要传递一个模板函数的地址，也可以借助编译器自动推断来省略显式的模板参数传递：</p>
<pre><code>//<span class="type">Code</span>-<span class="number">12</span>
<span class="type">void</span> knowType(<span class="type">void</span> (*innerFunp)(<span class="type">int</span> *)) {}
<span class="keyword">template</span>&lt;typename T&gt;
    <span class="type">void</span> unkwType(T *) {} //一个返回值类型为 <span class="type">void</span>, 参数为 T* 的函数
//使用
knowType(&amp;unkwType&lt;<span class="type">int</span>&gt;); //显式
knowType(&amp;unkwType); //编译器推断
</code></pre><p>但是这种情况下在使用模板推断的时候,需要注意,如果该函数有重载版本的情况下,需要显式的指明需要哪个函数,否则会发生 <strong>推断错误</strong> ,因为编译器没办法知道需要选择哪个版本的函数,即使明显是需要选择某个版本.</p>
<p>  解决方法可以是,类型转换(<code>static_cast</code>),或者重新写一个函数将某个特定的重载版本包裹起来.</p>
</li>
</ul>
</li>
<li><p>对于一个模板而言，它能够为不同类型生成不同的代码，同样，也可以人为先预设一些样板，就像一个建设网页的框架，总有人做好了模板，你可以使用别人的模板，也可以选择使用自己做模板</p>
<ul>
<li>比如 <strong>STL容器 vector</strong> 有一个生成好的特殊的版本 <code>vector&lt;bool&gt;</code>，优化了其的空间利用率。</li>
<li><p>生成显式特殊化(<strong>Explicit Specialization</strong>)的方法是，在定义好基本模板之后</p>
<pre><code>//<span class="type">Code</span>-<span class="number">13</span>
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass{
        T memOne;
        U memTwo;
    public:
        T getFstMem() <span class="keyword">const</span> { <span class="keyword">return</span> memOne; }
    };
<span class="keyword">template</span>&lt;&gt; //完全特殊化的语法
    class tmplClass&lt;<span class="type">int</span>, long&gt;{ //显式的定义了一个 &lt;<span class="type">int</span>, long&gt; 的版本
        <span class="type">int</span> memOne;
        long memTwo;
    public:
        <span class="type">int</span> getFstMem() <span class="keyword">const</span> { <span class="keyword">return</span> memOne; }
    };
</code></pre><p>  同样也支持有局部特殊化</p>
<pre><code>//<span class="type">Code</span>-<span class="number">14</span>
<span class="keyword">template</span>&lt;typename U&gt; // 部分特殊化的语法
    class tmplClass&lt;<span class="type">float</span>, U&gt;{ //只给了第一个参数的类型
    ...                           //给的参数可以随意调整顺序。
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass&lt;T, U*&gt; { //这也是局部特殊化
</code></pre><p>  此时，如果是在类外定义接口函数，那么需要注意的是，完全特殊化情况下，如果已经完全特殊化一个模板类，则在实现其特殊化类的接口函数时，不需要重新再写一遍 <code>template&lt;&gt;</code> 但是情况就需要：</p>
<pre><code>//<span class="type">Code</span>-<span class="number">15</span>
//假设只有普通模板类
<span class="keyword">template</span>&lt;typename T, typename U&gt;
    class tmplClass{
        T memOne;
        U memTwo;
    public:
        T getFstMem() <span class="keyword">const</span>; //想要类外实现一个特殊化的这个接口函数
    };
//实现：
<span class="keyword">template</span>&lt;&gt;
    <span class="type">int</span> tmplClass&lt;<span class="type">int</span>, long&gt;::getFstMem() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> memOne;
    }
</code></pre><p>  如果此时已经存在一个完全特殊化的模板类的时候：</p>
<pre><code><span class="comment">//Code-16</span>
<span class="comment">//这个假设在已有一个普通的模板类为前提之上。</span>
<span class="keyword">template</span>&lt;&gt; <span class="comment">//完全特殊化的语法</span>
    <span class="keyword">class</span> tmplClass&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt;{ <span class="comment">//显式的定义了一个 &lt;int, long&gt; 的版本</span>
        <span class="keyword">int</span> memOne;
        <span class="keyword">long</span> memTwo;
    <span class="keyword">public</span>:
        <span class="function"><span class="keyword">int</span> <span class="title">getFstMem</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//定义它，只需要和普通类一样即可</span>
    };
<span class="comment">//实现：</span>
<span class="keyword">int</span> tmplClass&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt;::getFstMem() <span class="keyword">const</span>
{
    <span class="keyword">return</span> memOne;
}
</code></pre></li>
</ul>
</li>
<li><p>使用模板会导致一个问题，就是 <strong>代码膨胀</strong>，对于每一个具体类型的实现都会有一段新的代码产生，而编译器对此的措施就是，只有用到的才会生成对应的代码，否则就不生成。</p>
<ul>
<li>例如，对于一个模板类而言，其成员函数只有被使用了，才会产生相应的代码，否则就当成摆设。</li>
<li>其次，可以人为的避免过大的代码膨胀，例如使用之前提到的，完全/部分特殊化的方法。<ol>
<li>当拥有一个基本的模板类时，我们可以在考虑后续使用的基础上，为其生成一个 <strong>完全特殊化</strong> 的类</li>
<li>使用这个类作为一个基类，产生一个继承体系，继承体系中的各个派生类便是我们真正会生成的类，派生类使用 部分特殊化 实现，继承之前的 完全特殊化 生的类</li>
<li>如此能够利用已经生成的代码，而不需要反复生成同样的代码。</li>
<li>继承 完全特殊化 类的 部分特殊化 类，需要对每一个接口函数重新定义（可以直接调用基类定义好的函数，通过域解析作用符<code>::</code>），因为继承的时候采用的是 <code>private</code> 继承。</li>
<li>最明显的用处便是当不同的类型是指针的时候，用 <code>void*</code> 生成完全特殊化基类，其他类型指针做派生类的对象。</li>
</ol>
</li>
</ul>
</li>
<li><p>模板中的友元</p>
<ul>
<li><p>在模板类中使用友元函数</p>
<ol>
<li>最简洁的写法便是将友元函数作为类内(in-class)函数声明且定义</li>
<li><p>否则，对于需要在类外进行定义的友元函数，只有将其声明为模板，且需要声明两次，定义一次，才能生效：顺序（1.模板类声明，2.模板友元函数声明，3.模板类定义，4.类定义的同时使用友元修饰符<code>friend</code> 重新声明该函数，5.类外定义该友元函数）</p>
<pre><code>//<span class="type">Code</span>-<span class="number">17</span>
//非类内(<span class="keyword">in</span>-class)写法
<span class="keyword">template</span>&lt;typename T&gt; class templClass;// <span class="number">1</span>.
<span class="keyword">template</span>&lt;typename T&gt; <span class="type">void</span> show(<span class="keyword">const</span> templClass&lt;T&gt;&amp;);// <span class="number">2</span>.

<span class="keyword">template</span>&lt;typename T&gt; // <span class="number">3</span>。
    class templClass{
         T x;
      public:
        templClass&lt;T&gt;(<span class="keyword">const</span> T&amp; para):x(para){}
        friend <span class="type">void</span> show&lt;&gt;(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo); //<span class="number">4</span>.
    };
//类外定义友元函数
<span class="keyword">template</span>&lt;typename T&gt; // <span class="number">5</span>.
    <span class="type">void</span> show(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo)
    {
        cout &lt;&lt; fo.x &lt;&lt; endl;
    }
</code></pre><p> .</p>
<pre><code>//<span class="type">Code</span>-<span class="number">18</span>
//类内(<span class="keyword">in</span>-class)写法
<span class="keyword">template</span>&lt;typename T&gt; 
    class templClass{
         T x;
      public:
        templClass&lt;T&gt;(<span class="keyword">const</span> T&amp; para):x(para){}
        friend <span class="type">void</span> show&lt;&gt;(<span class="keyword">const</span> templClass&lt;T&gt; &amp; fo)
        {
            cout &lt;&lt; fo.x &lt;&lt; endl;
        }
    };
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="try-throw-catch_三段式">try-throw-catch 三段式</h4><p>这是异常抛出的方式，简单的用法便是在外部使用的try-catch形式：</p>
<pre><code><span class="comment">//Code-1</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> get_num;
    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; get_num;
    <span class="keyword">try</span>
    {
        <span class="keyword">if</span>(get_num &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> get_num
        <span class="comment">//Something happen</span>
    }
    <span class="keyword">catch</span>(<span class="keyword">int</span> e) <span class="comment">//此处括号内的参数的类型和抛出的类型需要一致</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number "</span> &lt;&lt; get_num &lt;&lt; <span class="string">" is negative"</span>
                  &lt;<span class="built_in">std</span>::endl;
    }
    <span class="comment">//...</span>
}
</code></pre><ul>
<li><p>这是最简单的使用，在三段式中，<code>try</code>充当的是正常代码块，而<code>catch</code>则是对于抛出异常的处理。<code>catch</code> 可以不止一个，但一定要合理，实际来说，三段式能少用尽量少用，我们一般是这么使用三段式的：]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp记录10.1k]]></title>
    <link href="//wushxin.top/2015/07/09/Cpp%E8%AE%B0%E5%BD%9510.1k.html"/>
    <id>//wushxin.top/2015/07/09/Cpp记录10.1k.html</id>
    <published>2015-07-09T02:03:28.000Z</published>
    <updated>2015-07-21T03:07:14.481Z</updated>
    <content type="html"><![CDATA[<h3 id="更新于_2015/7/14_21:14:21">更新于 2015/7/14 21:14:21</h3><h4 id="再记录_operator=_重载">再记录 operator= 重载</h4><ul>
<li>因为在类的设计中 重载 <code>=</code> 可能是在所难免的，如果你的类设计比较复杂。</li>
<li>之所以需要重载它是为了当类中包含了复杂的关系的时候，提供了一个人为的保证，最典型的莫过于对象的拷贝：<ol>
<li>假设 类中有一个成员是指针，指向一个对象，这个对象可以是数组，也可以是其他类或者容器。</li>
<li>当我们执行赋值操作符的时候，假定这里规范的使用赋值运算符，让其一定能调用<strong>赋值拷贝构造函数</strong> <code>=</code> ，此时对于这个指针成员，就有两种情形： <strong>拷贝指针</strong> 或者 <strong>拷贝对象</strong> 。</li>
</ol>
</li>
<li><strong>拷贝指针</strong>，即便不重载运算符 <code>=</code> 编译器也会帮你自动实现，这在国内大概就叫做 <strong>浅拷贝</strong> ，如果仅仅拷贝指针，这就引发了一个问题，多个对象共享一个实际内存，当执行析构函数的时候，会造成多次析构同一个内存块。</li>
<li><strong>拷贝对象</strong>，这是普遍的解决方法，在拷贝的同时，将指针所指向的对象同样做一份拷贝，似乎也不错，但是如果对象太大，似乎并不是什么很喜人的事 情，但也不失为一种好的解决方案 <a id="more"></a> </li>
<li>当使用拷贝对象这个方案的时候，发现内存使用超过自己所能承受的范围，我们就应该重新考虑一下拷贝指针这个方法，即我们勀使用一个 <strong>计数器</strong>，用来记录有多少个指针指向这个共享的内存块(即对象)，这很像 <strong>C++11</strong> 中智能指针 <code>shared_ptr</code> 的做法，实际上的确可以使用 它来作为解决方法，当然也可以自己实现。</li>
<li>实现的方法就是增加一个计数成员(不是在本类中，而是在指针指向的对象的类中，当然容器和数组另找方法实现，可以考虑用静态成员)，用来记录是否还有指针指向这个内存，对象每次析构的时候，减少计数器。如果还有指针指向它那么在析构函数执行时就不释放那块内存。</li>
<li>总之，总是重载赋值拷贝构造函数 <code>=</code> 总是一个好的习惯。</li>
</ul>
<h4 id="自动类型转换">自动类型转换</h4><ul>
<li><p>对于内建类型，类型转换自然由语言来定义，而自己的类，自然也是可以有的</p>
<ol>
<li><p>加上一个特殊的构造函数即可：</p>
<pre><code>ClDefByMe<span class="list">(<span class="keyword">const</span> otherClass&amp;)</span><span class="comment">;</span>
</code></pre><p>只需要如此定义了构造函数，我们就能实现自动类型转换，但是。</p>
</li>
</ol>
<ul>
<li><p>往往自动类型转换不是什么好事，因为我们如果定义了这么一个构造函数，当我们传递<code>otherClass</code>类型的对象给某个需要 <code>ClDefByMe</code>作为参数的函数的时候，编译器甚至不会警告你，一个更好的办法就是告诉编译器，别偷偷的做自动类型转换，即使我的确有类型转换的意思：</p>
<pre><code><span class="function"><span class="keyword">explicit</span> <span class="title">ClDefByMe</span><span class="params">(<span class="keyword">const</span> otherClass&amp;)</span></span>;
</code></pre><p>只要加了关键字 <code>explicit</code> 我们就只能通过显式的类型转换才能成功通过编译</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> ClDefByMe &amp; other)</span>
</span>{
<span class="comment">//..Do Something</span>
}
otherClass tmp1 = <span class="keyword">new</span> otherClass;
<span class="comment">//调用</span>
testFunc(tmp1);<span class="comment">// 添加关键字 explicit 后报错，需要显式的转换</span>
testFunc(ClDefByMe(tmp)); <span class="comment">//编译通过</span>
</code></pre><p><strong>同样的理由，尽量给自己的构造函数加上关键字 <code>explicit</code> 防止发生自己不知道的默认类型转换，或者隐式调用构造函数。</strong></p>
</li>
<li>隐式调用构造函数的情况是，当某个构造函数只有一个参数(有多个参数，但只有一个参数无默认值，其他都有默认值的也属于这个范围)，那么也会达成触发隐式调用构造函数的条件。</li>
<li><p>例如<code>ClDefByMe</code>有一个构造函数，需要一个<code>int</code>类型的参数，那么：</p>
<pre><code><span class="comment">//testFunc(1);  //是合法的</span>
<span class="comment">//testFunc(1.0) //是合法的</span>
<span class="function">testFunc</span>(<span class="function">ClDefByMe</span>(1));   <span class="comment">//合法</span>
<span class="function">testFunc</span>(<span class="function">ClDefByMe</span>(1<span class="class">.0</span>)); <span class="comment">//合法</span>
</code></pre></li>
</ul>
<ol>
<li><p>在类中重载一个特殊的运算符：</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
...
    <span class="function"><span class="keyword">operator</span> <span class="title">otherClass</span><span class="params">()</span><span class="keyword">const</span> </span>{
        <span class="keyword">return</span> otherClass();<span class="comment">//某个otherClass的构造函数</span>
    }
</code></pre></li>
<li>然而并不是自动类型转换一无是处，它能够让类很好的适应由C语言带过来的库函数，最大的体现便是，C形式的字符串 <code>const char*</code>。只要我们在类中提过了如实现2这种形式的运算符重载，就能让自己的类在C语言的库函数中畅通无阻。</li>
</ol>
</li>
</ul>
<h4 id="重载_new_和_delete">重载 new 和 delete</h4><ul>
<li>全局重载 和 类内重载</li>
<li>全局重载也就是让每个地方用到的 <code>new/delete</code> 都是你重载过的效果</li>
<li>类内重载就像重载运算符一样，只对特别的类有效 </li>
<li><p>可以分为两种:</p>
<pre><code><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(site_t sizes)</span></span>;
<span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* dele_p)</span></span>;
</code></pre><ul>
<li>在重载的实现中，如果想分配的内存要在堆上，那么就使用 <strong>C语言</strong> 提供的内存管理机制<code>malloc, calloc, realloc, free</code>，并且如果这是重载全局的 <code>new/delete</code>，就不能使用 <code>istream</code> 之类的流对象进行输入输出，因为这些流会调用原来的 <code>new/delete</code> 去分配内存空间创建对戏那个，但是实际上此时已经不存在原来的 <code>new/delete</code> 了。</li>
<li>如果重载发生在了某个特定的类中，那么依旧可以调用全局的 <code>new/delete</code> 帮自己完成重载的工作，调用方法便是通过，域解析作用符 <code>::</code></li>
<li>在重载的实现中，如果想分配的内存要在栈上，那么就需要在类设计的时候，预先定义好一个 <strong>内存池</strong>，这个 <strong>内存池</strong> 的大小是固定的，无法改变，但是我们可以使用它来实现一个内存分配的效果，即将这个内存池看作一个系统内存，而我们重载的   <code>new/delete</code> 负责从里面分配和归还内存，这能达到一个目的，可以精确操控内存，让任意一个对象落在我们想要让他们出现的内存里。</li>
</ul>
</li>
<li><p>实现的时候，若是类内重载，则可以使用全局的 <code>new/delete</code>，进行辅助设计：</p>
<pre><code><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(site_t sizes)</span>
</span>{
    <span class="keyword">return</span> ::<span class="keyword">new</span> <span class="keyword">char</span>[sizes];
}
</code></pre><p>其中 <code>sizes</code> 是经过编译器计算得到的，并不需类设计这操心，在实现完之后，只需要正常使用即可</p>
</li>
<li>对于<code>new/delete</code>的重载，我们仅仅只能改变内存分配的位置而已。</li>
<li><code>new</code>所分配的内存会比原先所要求的内存要大一些，多出来的内存是用来存储一些有用的信息，即本次分配了多少个内存，(每个内存是对象的大小)，以便<code>delete</code>的操作。</li>
<li><p>相应的，我们也可以传递别的参数给<code>new</code>，以此来调用不同的构造函数来初始化：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t sizes, <span class="keyword">void</span>* arg1)</span>
</span>{
    <span class="keyword">return</span> arg1; ...
<span class="comment">//..调用</span>
<span class="keyword">int</span> arr_[<span class="number">11</span>] = {<span class="number">0</span>};
<span class="comment">//假设有一个构造函数，将唯一的成员初始化为括号内传递的参数的值</span>
ClDefByMe* tmp = <span class="keyword">new</span>(arr_) ClDefByMe(<span class="number">22</span>);<span class="comment">//在这个数组里创建对象。</span>
                                         <span class="comment">//每个对象大小为 int</span>
<span class="comment">//销毁的时候无法使用delete否则会造成程序错误，只能显式调用析构函数</span>
<span class="comment">//这相当于另一种内存池的实现。</span>
</code></pre><p>使用的方式：</p>
<pre><code><span class="comment">//下一个对象可以是</span>
ClDefByMe* tmp2 = <span class="keyword">new</span>(arr_+<span class="number">1</span>) ClDefByMe(<span class="number">33</span>); <span class="comment">//此处+1 代表下一个对象的位置</span>
</code></pre><p>但是因为没有内存检测，所以需要很小心的使用，不能让其越界，因为<code>C++</code>和 <code>C</code> 语言一样，是不提供越界检查的。</p>
<pre><code><span class="comment">//此时的内存示意|22|33|0|0|0|0|0|0|0|0|0| &lt;&lt;代表arr_的内存示意图</span>
ClDefByMe<span class="subst">*</span> tmp3 <span class="subst">=</span> <span class="literal">new</span>(arr_<span class="subst">+</span><span class="number">3</span>) ClDefByMe(<span class="number">44</span>);
<span class="comment">//此时的内存示意|22|33|0|44|0|0|0|0|0|0|0|</span>
tmp3<span class="subst">-&gt;</span>~ClDefByMe(); <span class="comment">//只能显式调用析构函数，而不能使用 delete</span>
                     <span class="comment">//调用完析构函数，发现内存中的值依旧存在，但实际上已经</span>
                    <span class="comment">//被“销毁”了，涉及到计算机的删除的实现。</span>
</code></pre></li>
</ul>
<h4 id="类设计中的关键字_public,_private,_protected">类设计中的关键字 public, private, protected</h4><ul>
<li>在类声明定义中，可以设定外部对象对本身成员的访问权限<ul>
<li><code>public:</code> 代表任何权限的对象都能访问</li>
<li><code>private:</code> 代表只有该类设计者本身和友元(类/函数)能够访问，继承类也无法直接访问</li>
<li><code>protected:</code> 代表只有 类设计者本身 和 友元 还有 继承类 能访问</li>
</ul>
</li>
<li><p>在类继承中</p>
<ul>
<li><code>public</code> 继承 代表将基类的公有，私有，保护关系，原封不动的继承</li>
<li><p>不写或者 <code>private</code> 继承 代表 所有成员都作为继承类的私有成员。</p>
<ul>
<li><p>当所有继承来的成员都成为是 <code>pirvate</code> 时，可以使用 <code>using</code> 关键字使得其权限改变。例如：</p>
<pre><code><span class="keyword">class</span> Deri : ClDefByMe{
<span class="keyword">public</span>:
    <span class="keyword">using</span> ClDefByMe::counts; <span class="comment">//使得counts由private变为public</span>
    <span class="keyword">using</span> ClDefByMe::address; <span class="comment">//使得接口函数address()成为public</span>
...
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="继承中的重定义">继承中的重定义</h4><ul>
<li><p>在继承的时候，继承类对于基类的成员都照搬继承，但是当基类中的成员函数，在继承类中被重写，被改变返回值或者参数列表，那么基类所继承过来的同名函数将被 <strong>隐藏</strong> </p>
<pre><code><span class="keyword">class</span> ClDefByMe{
    <span class="keyword">int</span> counts;
<span class="keyword">public</span>:
    <span class="comment">//...</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>{ 
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is ClDefByMe -- "</span> &lt;&lt; counts &lt;&lt; endl;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> args)</span></span>{
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is ClDefByMe -- "</span> &lt;&lt; args &lt;&lt; <span class="string">"of"</span> &lt;&lt; counts &lt;&lt; endl;
    }
<span class="comment">//...</span>
};
<span class="keyword">class</span> Deri : <span class="keyword">public</span> ClDefByMe{
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>{
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is Deri --"</span> &lt;&lt; endl;
    }
<span class="comment">//...</span>
};
Deri tmp;
</code></pre><p>使用 <code>tmp.output();</code> 调用的是 <strong>Deri</strong> 中的 <code>output()</code>，当选择编译 <code>tmp.output(11);</code> 时，编译器会提示你 </p>
<blockquote>
<p><strong>no matching function for call to ‘Deri::output(int)’</strong></p>
</blockquote>
<p>  这便是继承类隐藏了基类的实现，如果要调用基类的 <code>output</code>函数，只能显式调用，依旧是采用域解析操作符 <code>::</code> 实现： <code>tmp.ClDefByMe::output();</code></p>
</li>
<li>如果在继承类中出现了和基类一致的函数名，无论修改其返回值或者参数列表与否，都会 将基类中的同名函数隐藏，如果没有出现，那么继承类可以正常的调用基类的接口函数。</li>
</ul>
<h4 id="继承的函数">继承的函数</h4><ul>
<li><p>并不是所有公有函数都会被继承</p>
<ul>
<li>构造函数，并不会被继承，虽然看起来像是继承(即基类中可以调用)</li>
<li>重载或者自动生成的 <code>operator=</code> 不会被继承，因为它表现的十分类似一个构造函数干的事情</li>
</ul>
</li>
<li><p>当我们试图去创建一个对象的时候，构造函数会按照既定的顺序(基类到继承类)依次调用</p>
</li>
<li>其中 拷贝构造函数在被调用的时候，会默认去调用其上一级基类的 <strong>默认构造函数</strong> 而非 上一级基类的 <strong>拷贝构造函数</strong>，如果要调用上一级的 <strong>拷贝构造函数</strong>， 就需要<strong>显式</strong>地在 初始化列表 中调用，否则可能会导致拷贝失败。<ul>
<li>出现 <strong>拷贝构造函数</strong> 调用上一级基类的 <strong>默认构造函数</strong> 的情况，只有当类设计者自行编写 <strong>拷贝构造函数</strong> 且未显式调用上一级基类的 <strong>拷贝构造函数</strong> 才会发生</li>
<li>故设计类时：<ol>
<li>如果决定让 <strong>拷贝构造函数</strong> 由编译器自动生成，那么就证明新类(即当前类)中没有 <strong>复杂类型</strong> 成员(或复杂类型够健全)，那么编译器自动生成的拷贝构造函数会自动调用基类的拷贝构造函数，以及类成员的拷贝构造函数。</li>
<li>如果决定自己实现 <strong>拷贝构造函数</strong> 那么久需要记住，一定要显式的调用基类的拷贝构造函数，否则将会出错(编译器会默认调用基类的<strong>默认构造函数</strong>)</li>
</ol>
</li>
</ul>
</li>
<li><code>operator=</code> 也是如此。</li>
</ul>
<h3 id="虚函数_和_多态">虚函数 和 多态</h3><ul>
<li><p><code>virtual</code>关键字修饰的函数(虚函数)的重定义叫做 <strong>重写</strong>, 在 <strong>C++11</strong> 中可以使用 <code>override</code> 来防止不小心写成重载</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="comment">//...</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span>{ 
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"counts = "</span> &lt;&lt; counts &lt;&lt; endl;
    }
<span class="comment">//...</span>
<span class="keyword">class</span> Deri : <span class="keyword">public</span> ClDefByMe{
<span class="comment">//...</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> override</span>{ <span class="comment">//如果不小心写成重载，编译器就会提醒你。</span>
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"counts of Deri = "</span> &lt;&lt; counts &lt;&lt; endl;
    }
</code></pre><p>无论是传递参数的形式，或者数组(容器也一样)的存储，只要是 <strong>指针/引用</strong> 的形式，都能触发多态效果。</p>
</li>
<li>虚函数的一个最关键的性质就是 <strong>延后绑定</strong> ，用来实现 <strong>多态</strong></li>
<li>对于虚函数而言，在类设计的继承体系中，<strong>要么不用，要么就到处都用</strong>。</li>
<li><p>绑定(提前绑定 和 延后绑定)</p>
<ol>
<li>提前绑定 这是 C 与 C++ 共有的特性</li>
<li>延后绑定，当运行时(runtime)才进行绑定，只对 <strong>引用</strong> 以及 <strong>指针</strong> 有效，也就是说对实际的对象是不起作用的。绑定的内容就是决定调用继承体系中某个类的某个函数。</li>
<li>如果使用的是 <strong>完整的类对象</strong> 调用虚函数，编译器会将其自动处理(<strong>可能</strong>)为 提前绑定(因为即使此时时候延后绑定也是同样的结果，只是耗时而已，但更简单)，因为这时候所有的信息都是完整的，足以判断调用哪个版本的函数。而指针和引用则不同，某个类型的 <strong>指针/引用</strong> 也可以指向其继承类的对象，所以需要延后绑定来判断。</li>
</ol>
</li>
<li><p>虚函数是如何被调用的，实现的机制就是指针</p>
<ul>
<li>首先一个类中有至少一个的虚函数。</li>
<li>编译器隐式地创建了一张表，整个继承体系的每个类都拥有一张这种表，称之为<strong>虚函数表</strong>(<strong>VTABLE</strong>)，表中存放着类中的所有虚函数</li>
<li>在每个类(继承类和基类)中，自行添加一个成员 <strong>vpointer</strong>(简写为<strong>VPTR</strong>)，类型是指针的指针，指向这张虚函数表(虚函数表中保存着函数的地址)。</li>
<li>每次通过父类的指针或引用调用虚函数的时候，编译器就会迅速地通过<strong>VTPR</strong>去虚函数表中查找正确的函数地址，并调用它。 </li>
<li>无论有多少虚函数，都只有每个类都只有一个 <strong>VPTR</strong>，原因很明显。</li>
</ul>
</li>
<li><p>关系呈现</p>
<pre><code> <span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">_           _</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>_
| ClDefByMe |      ----&gt;|  ClDefByMe::output      |
|<span class="strong">_____</span><span class="emphasis">_vptr_</span>| <span class="strong">____|    |__</span><span class="strong">____其他虚函数__</span><span class="strong">_____</span><span class="emphasis">___</span>|
<span class="strong">_____</span><span class="strong">_____</span><span class="strong">___          __</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>
| Deri      |     ----&gt;|     Deri::output        |    
|<span class="strong">_____</span><span class="emphasis">_vptr_</span>| <span class="strong">____|    |__</span><span class="strong">____其他虚函数__</span><span class="strong">_____</span><span class="emphasis">___</span>|
</code></pre><ul>
<li>虚函数表中的函数指针，顺序是一定的，由编译器决定如何排序。可以保证的是所有表的顺序是一致的，和类设计这按什么顺序重写无关。</li>
<li>也就是说，表中相同位置的函数指向的是同名函数，如果没有在继承类中<strong>重写</strong>某个虚函数，则继承类会延用基类的版本。这些工作都在一个类对象创建的时候完成，也就是构造函数的工作(初始化VPTR)。</li>
</ul>
</li>
<li><p>纯虚函数 与 抽象基类</p>
<ul>
<li>抽象就是将所有相关物体具有的共性提取出来，抽象程度越高代表的特性也就越多，也越难以理解，<strong>C++</strong>中抽象基类无法创建实际对象，只是一个承载接口的平台，用以被继承。</li>
<li><p>纯虚函数是抽象基类的特点，其可以只有声明而，没有定义。但是抽象基类的继承类必须重写该虚函数(这个只对最近一级的继承类有效)。</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数，无函数体</span>
<span class="comment">//...</span>
<span class="keyword">class</span> <span class="title">Deri</span> : <span class="title">public</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>{
    <span class="comment">//Do something</span>
}
</code></pre></li>
<li>这也是为什么抽象基类无法创建对象的原因，由于抽象基类含有纯虚函数，而编译器依然会为其生成一张<strong>VTABLE</strong>表,一个<strong>VPTR</strong>指针，但是仅仅只是预留了位置给出纯虚函数，表中并没有有用的实际信息，而一个包含不完整信息的类是无法创建对象的，所以只要一个类拥有了纯虚函数，其就无法创建实际对象。</li>
<li>这也能及时发现是否误写为按值传递，导致动态绑定没有成功，因为抽象基类没有办法创建对象，也就无法按值传递了。</li>
</ul>
</li>
<li><p>由于在继承类中重定义(重写)一个在基类中存在重载的函数，会隐藏所有的重载版本，对于虚函数来说，其无法改变返回值和参数：</p>
<ul>
<li>返回值，在不改变参数的条件下，改变返回值，会无法通过编译，因为如果在继承类中重定义了一个在基类中重载的函数，那么基类的所有重载函数都将在继承类中被隐藏，导致如果基类的这个 <strong>重写的函数</strong> 如果不与继承类的虚函数一致的话，将会导致 <strong>多态失效</strong> ，这将会导致某些后续的问题，所以编译器阻止了修改返回值的行为。</li>
<li>参数，如果修改了参数，就相当于重载了这个函数，那么将隐藏基类继承来的虚函数及其重载函数，此时如果将其上切(upcasting)，可以恢复被隐藏的函数。    </li>
<li><p>当虚函数的返回值是 <strong>继承体系中类的指针或者引用</strong> 的时候，在继承类中可以修改返回值的类型，类型可以是继承体系中的任意的类，只要在继承之中即可。</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    <span class="keyword">virtual</span> ClDefByMe* output(){
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
<span class="comment">//...</span>
<span class="keyword">class</span> <span class="title">Deri</span> : <span class="title">public</span> <span class="title">ClDefByMe</span>{
<span class="comment">//..</span>
    Deri* output() <span class="keyword">override</span>{
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
</code></pre><p>编译通过，由于添加了 <code>override</code> 关键字，我们可以确保这的确是虚函数的重写 </p>
</li>
</ul>
</li>
<li>在构造函数里调用虚函数，那就是调用本类(本地)的虚函数版本，并不涉及到延后绑定机制</li>
<li>在析构函数里也是如此</li>
<li><p><strong>成为虚函数的析构函数</strong> </p>
<ul>
<li>让析构函数成为虚函数的目的就是为了防止在程序员动态分配内存(heap上)，并且销毁对象时可能出现的错误</li>
<li><p>这种错误出现在，当你对析构函数使用多态这种机制的时候：</p>
<ul>
<li><p>在创建一个对象，起先并不知道其类型，用继承体系中的基类指针指向(即使用new创建)，在之后的某个情形下，使用 <code>delete</code> 销毁，如果此时析构函数非虚函数，则会导致内存泄漏的Bug，因为此时 <code>delete</code> 只会调用当前类型版本的析构函数，对于其基类的析构函数并不会调用.</p>
<pre><code><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">___</span>_
|        Deri2         |
|    <span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>   |
|    |    Deri1    |   |
|    |    <span class="strong">_____</span>_   |   |
|    |    |Base|   |   |
|    |    |<span class="emphasis">___</span>_|   |   |
|    |<span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">___</span>|   |
|<span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>__|
</code></pre><p>  其中如果让析构函数成为虚函数，则 <code>delete</code> 时会层层调用各个类的析构函数，如果为普通成员函数，则只会调用某一层的析构函数。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数的 析构函数</p>
<ul>
<li><p>它要有一个函数体，即所谓的定义。可以显式的定义它为 内联。因为要给它函数体，所以必定要在类外定义，这就无法成为内联函数，所以需要显式指定</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="comment">//..</span>
    <span class="keyword">virtual</span> ~ClDefByMe() = <span class="number">0</span>;
...
<span class="keyword">inline</span> ClDefByMe::~ClDefByMe() {} <span class="comment">//即使没做任何事</span>
</code></pre></li>
<li>对于析构函数而言，当它是<strong>纯虚函数</strong> 时，其继承类并没有被强制要求 需要重写这个函数，为了达到这个目的，所以我们给了基类的纯虚函数 一个函数体，这样编译器就能自动为我们生成继承类的析构函数版本。</li>
</ul>
</li>
</ul>
<h4 id="C++_显式类型转换">C++ 显式类型转换</h4><ul>
<li>一共四个转换： <ol>
<li><code>static_cast</code> </li>
<li><code>const_cast</code> </li>
<li><code>reinterpret_cast</code> </li>
<li><code>dynamic_cast</code></li>
</ol>
</li>
<li>之所以需要他们，是因为由 C语言继承过来的<strong>强制类型转换</strong>含有许多漏洞，它无法给予我们任何信息，只是简单的执行了类型转换。</li>
</ul>
<ol>
<li><p>用于普通的类型转换，即强制类型转换能做的，它也能做，区别于是否在必要的时候提供一个警告信息：</p>
<pre><code><span class="keyword">int</span> i = <span class="number">0</span>
<span class="keyword">float</span> j = <span class="number">0</span>;
<span class="keyword">long</span> k = <span class="number">0</span>;
i = k;
i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(k);
j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(k);
</code></pre></li>
<li><p>用来去除 <strong>const/volatile</strong> 属性</p>
<pre><code><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;
<span class="keyword">int</span> * j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;i);
</code></pre></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="更新于_2015/7/14_21:14:21">更新于 2015/7/14 21:14:21</h3><h4 id="再记录_operator=_重载">再记录 operator= 重载</h4><ul>
<li>因为在类的设计中 重载 <code>=</code> 可能是在所难免的，如果你的类设计比较复杂。</li>
<li>之所以需要重载它是为了当类中包含了复杂的关系的时候，提供了一个人为的保证，最典型的莫过于对象的拷贝：<ol>
<li>假设 类中有一个成员是指针，指向一个对象，这个对象可以是数组，也可以是其他类或者容器。</li>
<li>当我们执行赋值操作符的时候，假定这里规范的使用赋值运算符，让其一定能调用<strong>赋值拷贝构造函数</strong> <code>=</code> ，此时对于这个指针成员，就有两种情形： <strong>拷贝指针</strong> 或者 <strong>拷贝对象</strong> 。</li>
</ol>
</li>
<li><strong>拷贝指针</strong>，即便不重载运算符 <code>=</code> 编译器也会帮你自动实现，这在国内大概就叫做 <strong>浅拷贝</strong> ，如果仅仅拷贝指针，这就引发了一个问题，多个对象共享一个实际内存，当执行析构函数的时候，会造成多次析构同一个内存块。</li>
<li><strong>拷贝对象</strong>，这是普遍的解决方法，在拷贝的同时，将指针所指向的对象同样做一份拷贝，似乎也不错，但是如果对象太大，似乎并不是什么很喜人的事 情，但也不失为一种好的解决方案]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp记录10.4k]]></title>
    <link href="//wushxin.top/2015/06/21/Cpp%E8%AE%B0%E5%BD%9510.4k.html"/>
    <id>//wushxin.top/2015/06/21/Cpp记录10.4k.html</id>
    <published>2015-06-21T03:38:55.000Z</published>
    <updated>2015-07-21T06:50:05.692Z</updated>
    <content type="html"><![CDATA[<h4 id="更新于_2015/7/9_10:03:12">更新于 2015/7/9 10:03:12</h4><h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span>
{
    <span class="keyword">int</span> challenge = <span class="number">0</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>
    </span>{
        ...
}
</code></pre></li>
<li><p>名称空间的创建</p>
</li>
</ul>
<p>一般来说，声明实现是要分离的，而对于一个名称空间来说，不能再某个名称空间中声明了，却在另一个名称空间里定义，所以我们一般在头文件中声明它，并在实现文件中定义它们</p>
<pre><code><span class="comment">// file1.h</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        ...
}


<span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }

        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }
}
</code></pre><ul>
<li><p>使用名称空间的时候，最好避免全部倒入，容易造成名称污染。<a id="more"></a></p>
<pre><code><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//不建议这么做</span>

<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;
<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="comment">//最好如此或者，更好的做法是:</span>

<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In the Real Code"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="comment">//但是这么做会让代码显得十分臃肿，所以取舍在于自己。</span>
</code></pre></li>
</ul>
<ul>
<li>类设计中特殊的函数</li>
</ul>
<p>一个类，当它拥有这样的构造函数时：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Wushxin</span></span>{

<span class="keyword">public</span>:
        Wushxin() {}
        Wushxin(<span class="keyword">double</span> heigth);
...
<span class="keyword">private</span>:
        <span class="keyword">double</span> my_heth;
...
};
</code></pre><p>我们可以这么使用它：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Wushxin FirstCopy;
    FirstCopy = <span class="number">178.6</span>; <span class="comment">//这样的赋值是成立的</span>
                       <span class="comment">//首先调用Wushxin(double heigth)，将176.8传入，</span>
                       <span class="comment">//将生成一个临时的Wushxin类型的对象，再拷贝进FirstCopy对象中。</span>
    <span class="keyword">double</span> heigth = FirstCopy; <span class="comment">// 可行吗？，答案是不可行</span>
...
</code></pre><p>但是，如果要让他成立，自然也有方法：</p>
<p>很少使用的特殊函数：</p>
<pre><code><span class="keyword">class</span> <span class="title">Wushxin</span>{
...
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>{
            <span class="keyword">return</span> my_heth;
    }
...
}; 
</code></pre><p>如此定义一个特殊的转换函数之后，我们就能无错的编译通过并运行上述代码了。</p>
<h4 id="const">const</h4><ul>
<li><p>在C++中，<code>const</code>默认是内部链接，即只能在本文件中可见，如果想让其他文件也能使用，则应该添加<code>extern</code>说明符</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> sizes = <span class="number">100</span>;
</code></pre><p>代表着，编译器给它分配了内存空间，使得其他文件能够找到它</p>
</li>
<li><p>一个<code>const</code>的临时变量，总能将自己的地址传递给函数：</p>
<ul>
<li><p>这句话的意义在于，我们可以让一个函数返回值的过程中，所创建的临时变量，被林一个函数以<code>const &amp;</code>接收，并保证它的正确性和效率。</p>
</li>
<li><p>一个函数的返回值所创建的临时对象(编译器创建它的目的是为了保存返回值)，只能被<code>const</code>的参数列表接收，这是因为任何对临时变量进行修改的操作都是无意义的，因为最后临时变量都是要被销毁的(在表达式之后)。</p>
</li>
<li><p>一个临时变量是不能够被取地址的，而且编译器总是把<strong>临时类对象</strong>当成常量。</p>
</li>
</ul>
</li>
<li><p>一个<code>const</code>对象，必须在创立的时候就初始化它，所以选择在构造函数里的参数列表中对<code>const</code>进行初始化是一个最好的选择。</p>
<pre><code><span class="tag">MyClass</span>(int args)<span class="pseudo">:mem_int</span>(args) {} 
</code></pre></li>
</ul>
<h4 id="引用">引用</h4><ul>
<li>引用经常被用在函数的参数列表以及返回值类型。</li>
<li><p>当使用引用作为参数的时候，如非必要，我们要尽最大限度的让参数是 <code>const &amp;</code>：</p>
<ul>
<li>如果我们按值传递(Pass By value),那么我们就需要一个构造函数和一个析构函数的调用，而如果是常量引用，我们紧紧需要将这个对象的地址压入函数建立的栈中。</li>
</ul>
</li>
</ul>
<h4 id="auto_(C++11)">auto (C++11)</h4><ul>
<li><code>auto</code> 并不能自动的添加 <code>const</code> 属性，只能人为选择是否添加</li>
<li><p><code>auto</code> 可以与 <code>decltype</code> 配合使用，来推断函数的返回值，在<strong>C++14</strong>中可以只用 <code>auto</code> ，但对于 <strong>C++11</strong> 而言：</p>
<pre><code><span class="function"><span class="keyword">auto</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> -&gt; <span class="title">decltype</span><span class="params">(arg_1+arg_2)</span> 
</span>{
    <span class="keyword">return</span> arg_1+arg_2;
}
</code></pre><p>在代码中，auto的作用就是占一个位置，类型由 <code>-&gt; decltype(x+y)</code> 提供，与Lambdas的语法类似。</p>
</li>
</ul>
<h4 id="copy-construction">copy-construction</h4><ul>
<li>对于一个类而言，一个拷贝构造函数是十分有必要的，它能有效的防止你的类对象在传递的时候不出错，否则，由于C++要与C语言进行兼容，在按值传递(<strong>Pass By Value</strong>)故采用的是<strong>位拷贝</strong>，这会导致并不是真正的重新构造一个新的临时对象，但是在退出函数的时候，却会调用<strong>析构函数</strong>，相当于一不小心把传递进来的这个对象给销毁了！而我们并没有想让它被改变，所以我们当初才采用按值传递。</li>
<li>这一点十分重要。</li>
<li><p>拷贝构造函数，通常是这样的：</p>
<pre><code>ClassDefineByMe(<span class="keyword">const</span> ClassDefineByMe &amp; PassObj);
<span class="comment">//ClassDefineByMe是自己定义的类型</span>
</code></pre></li>
<li>总之，拷贝构造函数是为了解决按值传递这个问题的，如果你不会用到按值传递，那么可以关闭它(<code>=delete</code> — <strong>C++11</strong> OR <code>private it</code> — <strong>C++98</strong>)。或者干脆一些，不显式定义，交给编译器去自动生成。</li>
</ul>
<h4 id="operator=_重载">operator= 重载</h4><ul>
<li>当我们在表达式中使用 <code>=</code> 时，对于内建类型，自然是很简单的拷贝，对于C++的容器而言，自有重载好的 <code>=</code> 进行拷贝操作。</li>
<li><p>对于自己定义的类而言，当我们：</p>
<pre><code><span class="title">ClDefByMe</span> tmp1 = <span class="number">1</span>;
<span class="title">ClDefByMe</span> tmp2 = tmp1;
<span class="title">tmp1</span> = tmp2;
</code></pre><p>第一句调用匹配的构造函数或者默认构造函数，第二句调用拷贝构造函数(而不是 <code>=</code> )，第三句才是使用重载后的<code>=</code>(假设类中重载了它)</p>
</li>
<li><p>所以对于初始化以及赋值而言，为了清晰明了，我们在初始化定义一个新的对象的时候，时空直接初始化的语法即：</p>
<pre><code><span class="function">ClDefByMe <span class="title">tmp</span><span class="params">(<span class="number">1</span>)</span></span>;
</code></pre></li>
<li><p>对于已经创建好的对象进行赋值的时候，使用<code>=</code></p>
<pre><code><span class="attribute">tmp2 </span>=<span class="string"> tmp;</span>
</code></pre><p>这样就能很清楚的看出使用的是<code>=</code>的功能。</p>
</li>
</ul>
<h4 id="指向类成员的指针">指向类成员的指针</h4><ul>
<li>实际上，因为类的实际对象，一直到运行时才会有具体的地址，但是我们如果对某个还没有生成的对象中的成员取地址呢？</li>
<li>可以，但那并不是真正的地址，而是取到<strong>偏移量</strong>，但是表面上看着像取了地址一般，所以由此引发了两种新的怪异语法糖： <code>-&gt;*</code> 和 <code>.*</code></li>
<li><p>也就是说，对一个类成员成员，无论是数据成员还是成员函数，都是一样的。就是语法有些怪异。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ClDefByMe</span></span>{
<span class="keyword">public</span>:
    ClDefByMe():count(0),pubIntMem(0){}
    ClDefByMe(<span class="keyword">int</span> PreKey):count(PreKey),pubIntMem(0){}
    <span class="function"><span class="keyword">void</span> <span class="title">getCounts</span><span class="params">()</span></span>{
        std::cout &lt;&lt; <span class="string">"The count is "</span> &lt;&lt; count &lt;&lt; std::endl;
    }
    <span class="keyword">int</span> pubIntMem;
<span class="keyword">private</span>:    
    <span class="keyword">int</span> count;
};
</code></pre><p>这是类的实现，类中有一个 <code>int</code> 私有数据成员, <code>int</code> 公有数据成员，和一个成员函数</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    ClDefByMe testObj, *pToObj = &amp;testObj;
    <span class="comment">//我们可以这么用</span>
    <span class="keyword">int</span> ClDefByMe::*pToInt = &amp;ClDefByMe::pubIntMem;
    <span class="keyword">void</span> (ClDefByMe::*pToFunc) = &amp;ClDefByMe::getCounts;
    <span class="comment">//可以直接初始化，也可以声明完后再初始化。</span>
    testObj.*pToInt = <span class="number">10</span>; <span class="comment">//现在数据成员pubIntMem的值为10</span>
    (testObj.*pToFunc)(); <span class="comment">//调用。</span>
    <span class="comment">//pToObj-&gt;*pToInt = 10;</span>
    <span class="comment">//(pToObj-&gt;*pToFunc)();</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>其中域解析操作符 <code>::</code> 一定要有，其次函数前方的取地址符号<code>&amp;</code>也一定要有。虽然函数名即使函数地址，但是此处并非真正的取函数地址，而是偏移量。</p>
</li>
</ul>
<h4 id="运算符重载">运算符重载</h4><ul>
<li>用于自定义类的运算符重载</li>
<li>不能重载一切内建类型的运算符，不能重载不存在的运算符(如 <code>**</code> )，</li>
</ul>
<blockquote>
<p>重载方式1： <strong>友元函数形式</strong></p>
</blockquote>
<ul>
<li><p>.</p>
<ul>
<li>特点：<ul>
<li>可以在类的外部直接操作类的私有成员</li>
<li>但是不能使用 <code>this</code> 指针</li>
<li>类外实现时，可以不带域解析操作符，而一般类成员函数却要</li>
<li>使用所重载的运算符时，可以任意调换<strong>运算符</strong>两边的<strong>操作数</strong>，只需要有对应的重载函数即可。</li>
</ul>
</li>
<li><p>声明：</p>
<pre><code><span class="keyword">class</span> ClDefByMe{
<span class="keyword">public</span>:
    <span class="comment">//...构造函数 和 接口</span>
    <span class="comment">//新增接口:</span>
    ClDefByMe* address(){ <span class="keyword">return</span> <span class="keyword">this</span>; }

    <span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">friend</span> ClDefByMe* 
            <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> ClDefByMe&amp;); <span class="comment">//重载取地址运算符</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe&amp;
            <span class="keyword">operator</span>++(ClDefByMe&amp;); <span class="comment">//重载前缀递增操作符</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>++(ClDefByMe&amp;, <span class="keyword">int</span>); <span class="comment">//重载后缀形式</span>
    <span class="comment">//递减运算符类似。</span>
    <span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

    <span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>+(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">int</span>);

    <span class="keyword">friend</span> <span class="keyword">const</span> ClDefByMe
            <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="keyword">friend</span> ClDefByMe&amp;
            <span class="keyword">operator</span>&amp;=(ClDefByMe&amp;, <span class="keyword">const</span> ClDefByMe&amp;);
    <span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="keyword">private</span>:
    <span class="comment">//...数据成员</span>
};
</code></pre></li>
<li><p>类外部实现：</p>
<pre><code><span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;记得不必写friend&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
ClDefByMe* operator&amp;(<span class="keyword">const</span> ClDefByMe&amp; GetAddress)
{
    <span class="keyword">return</span> GetAddress.address();
}<span class="comment">//此处并没有用到域解析操作符，因为是友元函数</span>
<span class="keyword">const</span> ClDefByMe&amp; operator++(<span class="keyword">const</span> ClDefByMe&amp; PrePlus)
{
    ++PrePlus.<span class="keyword">count</span>;
    <span class="keyword">return</span> PrePlus;
}
<span class="keyword">const</span> ClDefByMe operator++(ClDefByMe&amp; PostPlus, int)
{<span class="comment">//int可以看成一个永远不会被使用的标志，值由编译器提供。</span>
    ClDefByMe tmpRet(PostPlus.getCounts());
    ++PostPlus.counts; <span class="comment">//此处使用前缀后缀都无所谓，推荐前缀</span>
    <span class="keyword">return</span> tmpRet; <span class="comment">//使用这个返回值的表达式结束后，这个对象立刻被销毁，不用担心内存问题</span>
}
<span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&amp;在此处是二元运算符与&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe operator+(<span class="keyword">const</span> ClDefByMe&amp; addObjLeft, <span class="keyword">const</span> ClDefByMe&amp; addObjRight)
{
    <span class="keyword">return</span> ClDefByMe(addObjLeft.<span class="keyword">count</span> + addObjRight.<span class="keyword">count</span>);
}

<span class="keyword">const</span> ClDefByMe operator&amp;(<span class="keyword">const</span> ClDefByMe&amp; andObjLetf, <span class="keyword">const</span> ClDefByMe&amp; andObjRight)
{
    <span class="keyword">return</span> ClDefByMe(andObjLeft.<span class="keyword">count</span> &amp; andObjRight.<span class="keyword">count</span>);
}
ClDefByMe&amp; operator&amp;=(ClDefByMe&amp; andassiLeft, <span class="keyword">const</span> ClDefByMe&amp; adnassiRight)
{<span class="comment">//此处注意，Left是非const，因为根据语法 x &amp;= y 中的x是需要拥有被改变的权限的，</span>
 <span class="comment">//并且返回值设为非const也是为了这个权限考虑</span>
    <span class="comment">//在这种永久改变操作对象的实现中，我们要注意一点就是，</span>
    <span class="comment">//如果运算符两边的操作数是同一个的情况</span>
    <span class="keyword">if</span>(&amp;andassiLeft == &amp;andassiRight) <span class="comment">//判断是否相同</span>
    {
        andassiLeft.<span class="keyword">count</span> = andassiRight.<span class="keyword">count</span> &amp; andassiRight.<span class="keyword">count</span>;
        <span class="keyword">return</span> andassiLeft;    
    }
    andassiLeft.<span class="keyword">count</span> &amp;= andssiLeft.<span class="keyword">count</span>;
    <span class="keyword">return</span> andassiLeft;
}

<span class="keyword">const</span> ClDefByMe operator&lt;&lt;(<span class="keyword">const</span> ClDefByMe&amp; lmoveLeft, int moveBits)
{
    <span class="keyword">return</span> ClDefByMe(lmoveLeft.<span class="keyword">count</span> &lt;&lt; moveBits);
}<span class="comment">//注意这不是重载输出流的运算符，而是移位运算符</span>
<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>重载方式2：<strong>成员函数形式</strong></p>
</blockquote>
<ul>
<li><p>.</p>
<ul>
<li>特点：<ul>
<li>可以使用this指针</li>
<li>与普通的成员函数一眼</li>
<li>当所重载的运算符左边不是该类的对象时重载失效。</li>
<li>成员函数形式的重载，相当于运算符左边的操作数被默认定下（即对象本身）</li>
</ul>
</li>
<li><p>声明：</p>
<pre><code><span class="keyword">class</span> <span class="title">ClDefByMe</span>{
<span class="keyword">public</span>:
    <span class="comment">//...构造函数 和 接口</span>

    <span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">const</span> ClDefByMe&amp; <span class="keyword">operator</span>+(); <span class="comment">//一元运算符 取正</span>
    <span class="keyword">const</span> ClDefByMe&amp; <span class="keyword">operator</span>--(); <span class="comment">//前缀递减</span>
    <span class="keyword">const</span> ClDefByMe  <span class="keyword">operator</span>--(<span class="keyword">int</span>); <span class="comment">//后缀递减</span>
    <span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

    <span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
    <span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>-(<span class="keyword">const</span> ClDefByMe&amp;);  <span class="comment">//二元运算符 减法</span>
    <span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span>); <span class="comment">//二元运算符 右移</span>
    ClDefByMe&amp;      <span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> ClDefByMe &amp;); <span class="comment">//组合运算</span>
    <span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">private</span>:
    <span class="comment">//...</span>
};
</code></pre></li>
<li><p>类外部实现：</p>
<pre><code><span class="comment">//部分一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;使用域解析操作符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>+()
{
    <span class="keyword">return</span> ClDefByMe(counts); <span class="comment">//也可以返回 *this,不过类型要变为</span>
                              <span class="comment">// const ClDefByMe &amp;</span>
}
<span class="keyword">const</span> ClDefByMe&amp; ClDefByMe::<span class="keyword">operator</span>--()
{
    --counts;     <span class="comment">//因为是成员函数，可以直接操作私有成员</span>
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    <span class="keyword">return</span> ClDefByMe(counts--);
}
<span class="comment">//一元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

<span class="comment">//部分二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="keyword">const</span> ClDefByMe ClDefByMe::<span class="keyword">operator</span>+(<span class="keyword">const</span> ClDefByMe&amp; addArgRight)
{
    <span class="keyword">return</span> ClDefByMe(count+addArgRight.count);<span class="comment">//直接操作私有成员    </span>
}
<span class="keyword">const</span> ClDefByMe <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span> moveBits)
{
    <span class="keyword">return</span> ClDefByMe(count &gt;&gt; moveBits);
}

ClDefByMe&amp; <span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> ClDefByMe &amp; andassiRight)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;andassiRight)
    {
        count = andassiRight.count &amp; andassiRight.count;
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }
    count &amp;= andassiRight.count;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
<span class="comment">//二元运算符&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>某些特殊的操作符重载</p>
</blockquote>
<pre><code><span class="comment">//某些操作实现包含在&lt;iostream&gt;中</span>
<span class="keyword">friend</span> ostream &amp; 
    <span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> ClDefByMe &amp;);<span class="comment">//类中声明 重载输出</span>
ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; streams, <span class="keyword">const</span> ClDefByMe &amp; outRight)
{
    streams &lt;&lt; outRight.count &lt;&lt; endl;
    <span class="keyword">return</span> streams; <span class="comment">//没有return其实也行，但是就无法嵌套输出了。</span>
}
</code></pre><p>此处，传递的参数和返回值必须是引用(对于流)，这样在函数里的改变才能影响到外部。</p>
<p>输入也是一样。</p>
<ul>
<li><p>总结</p>
<ol>
<li>对于一元运算符而言，成员函数形式总是比较适合的。</li>
<li>一些正常的数学运算，将传递的参数都置为 常量引用(<code>const &amp;</code>)</li>
<li>对比成员函数形式和友元函数形式的重载，后者可能将具有更高的灵活性，例如类型转换，比如表达式： <code>a+1</code>,两种形式的重载都合法，但是换一个写法 <code>1+a</code>,成员函数形式的写法一定会报错，但是友元函数的写法只要有对应的构造函数进行类型转换(将1构造成对应的类型)就能通过编译。<strong>因为</strong>对于成员函数的实现而言，其左操作数的类型必须是完全匹配的。</li>
<li>所有赋值运算符这一类运算符(如=, +=, &amp;=, …)的重载，需要改变其左边的操作数，<ul>
<li>对于友元函数形式的，就需要将左操作数声明为非 <code>const</code> 参数，否则就在函数参数列表中把它们都声明为 <code>const</code> </li>
<li>对于成员函数形式的，就需要将函数声明为 <code>const</code> 即可，其余不需考虑。</li>
</ul>
</li>
<li><p>返回值类型：</p>
<ul>
<li>对于返回临时对象，需要让返回值类型为 const value.</li>
<li>对于返回非临时对象的，需要让返回值类型为 const value reference.</li>
<li>如果是改变左值的运算符，那么就去掉返回值中的const，其余结构不变，何时改变，就是所有赋值一类的运算符。</li>
<li>但临时对象总是默认为 <code>const</code>，所以如果返回临时对象，但是不在返回值地方声明为 <code>const</code>，它依然是 <code>const</code>。</li>
<li><p>如果没有必要，请不要把(如果是版本新的编译器就无所谓了，会帮你优化)：</p>
<pre><code><span class="command">return</span> ClDefByMe(addObjLeft.<span class="command">count</span> + addObjRight.<span class="command">count</span>);
</code></pre><p>  写成</p>
<pre><code>ClDefByMe tmp(addObjLeft.<span class="command">count</span> + addObjRight.<span class="command">count</span>)；
<span class="command">return</span> tmp;
</code></pre><p>  这涉及到编译器的操作，一般情况下后面这种写法会多出一个操作，也就是调用拷贝构造函数，如果你的类恰好没定义，而这个类的拷贝又需要自己定义的拷贝构造函数，那就 Boom！</p>
</li>
</ul>
</li>
<li>推荐的重载写法：<ul>
<li>推荐写成 <strong>友元函数形式</strong> 的运算符： <code>所有二元运算符</code></li>
<li>必须写成 <strong>成员函数形式</strong> 的运算符： <code>=, (), [], -&gt;, -&gt;*</code></li>
<li>推荐写成 <strong>成员函数形式</strong> 的运算符： <code>所有赋值相关的运算符，如：</code><br><code>+=, /=, *=, &gt;&gt;=, ...</code></li>
<li>推荐写成 <em>*成员函数形式</em> * 的运算符： <code>所有一元运算符</code></li>
</ul>
</li>
<li>不可以重载的运算符：<ul>
<li><code>**</code>(不存在)， <code>.</code>(点运算符), <code>.*</code></li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="更新于_2015/7/9_10:03:12">更新于 2015/7/9 10:03:12</h4><h4 id="名称空间">名称空间</h4><ul>
<li><p>匿名的名称空间只在本文件中可见。</p>
<pre><code><span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span>
{
    <span class="keyword">int</span> challenge = <span class="number">0</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>
    </span>{
        ...
}
</code></pre></li>
<li><p>名称空间的创建</p>
</li>
</ul>
<p>一般来说，声明实现是要分离的，而对于一个名称空间来说，不能再某个名称空间中声明了，却在另一个名称空间里定义，所以我们一般在头文件中声明它，并在实现文件中定义它们</p>
<pre><code><span class="comment">// file1.h</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span></span>;
        ...
}


<span class="comment">//file1.cpp</span>
<span class="keyword">namespace</span> <span class="title">mix_define</span>{

        <span class="function"><span class="keyword">void</span> <span class="title">interF</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }

        <span class="function"><span class="keyword">double</span> <span class="title">goRound</span><span class="params">(<span class="keyword">int</span> args_1)</span>
        </span>{
            <span class="comment">//Something happen...</span>
        }
}
</code></pre><ul>
<li><p>使用名称空间的时候，最好避免全部倒入，容易造成名称污染。]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Qt记录]]></title>
    <link href="//wushxin.top/2015/06/12/Qt%E8%AE%B0%E5%BD%95.html"/>
    <id>//wushxin.top/2015/06/12/Qt记录.html</id>
    <published>2015-06-12T00:42:47.000Z</published>
    <updated>2015-09-20T03:03:52.375Z</updated>
    <content type="html"><![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4><a id="more"></a>
<p>作为信号(signal)与槽(slot)，我们的信号函数的<strong>参数个数</strong>可以多于槽函数的参数个数，也就是说，我们可以选择接受不多于信号函数<strong>参数个数</strong>的参数，有点绕：</p>
<ul>
<li><p>信号函数的类：</p>
<pre><code><span class="keyword">class</span> Signal_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span>:
...
    <span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
    </span>{
        <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName, UserAge)</span></span>;
        <span class="comment">//UserName, UserAge 是该类的私有属性。</span>
    }
signals:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSignal</span><span class="params">(<span class="keyword">const</span> QString &amp; name, <span class="keyword">int</span> age)</span></span>;
<span class="comment">// ...</span>
</code></pre></li>
</ul>
<pre><code>-<span class="ruby"> 对于这段代码而言，有两个地方需要注意，<span class="string">`emit`</span>, <span class="string">`public signals:`</span>
</span>
    -<span class="ruby"> 此处故意令信号函数重载，是为了在后方体现，槽函数的参数个数可以小于或者等于信号函数的参数个数。
</span>    -<span class="ruby"> <span class="string">`emit`</span> 就是发射信号的意思。</span>
</code></pre><ul>
<li><p>槽函数的类：</p>
<pre><code><span class="keyword">class</span> Slot_Class:<span class="keyword">public</span> QObject{
...
<span class="keyword">public</span> slots:
    <span class="function"><span class="keyword">void</span> <span class="title">Q_TestSlot</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span>
    </span>{
         QMessageBox mesbox;
         mesbox.setText(<span class="string">"Receive : "</span>+name);
         mesbox.exec();
    }
<span class="comment">// ...</span>
</code></pre></li>
<li><p>测试：</p>
<pre><code><span class="keyword">void</span> (Signal_Class::* p_to_test)(<span class="keyword">const</span> QString &amp;, <span class="keyword">int</span>) = 
     &amp;Signal_Class::Q_TestSignal;
    <span class="comment">//因为是重载函数，所以需要明确指明使用哪个作为连接的信号函数 </span>
QObject::connect(&amp;test_sig, p_to_test,
                 &amp;test_slot, Slot_Class::Q_TestSlot);
test_sig.Q_SendSignal(); <span class="comment">//发射信号</span>
</code></pre><blockquote>
<p>效果图</p>
</blockquote>
</li>
<li><p><img src="http://ww1.sinaimg.cn/mw690/81b736ebtw1et2ajoj7ydj20bk09f3ye.jpg" alt=""></p>
</li>
</ul>
<p>我们会发现，即使槽函数的参数个数与信号函数不一致（小于），但是依然可以接收到参数，但是需要注意的是，虽然能够自由选择接受的参数，但是依旧需要按照顺序(按照C++语法上的顺序)。</p>
<p>既然槽函数能够接受不多于信号函数参数个数的参数，那么我们自然而然能够想到，是否可以使用让槽函数拥有默认参数，以此来扩大槽函数的适用范围，答案是可以。</p>
<ul>
<li><p>依旧是上方的代码，改动些许：</p>
<ul>
<li><p>信号函数的类改动</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Q_SendSignal</span><span class="params">()</span>
</span>{
    <span class="function">emit <span class="title">Q_TestSignal</span><span class="params">(UserName)</span></span>;
    <span class="comment">//UserName 是该类的私有属性。</span>
}
</code></pre></li>
<li><p>信号函数类改动</p>
<pre><code><span class="keyword">void</span> Q_TestSlot(<span class="keyword">const</span> QString &amp; name
              , <span class="keyword">const</span> QDate &amp; time = QDate::currentDate())
{
    <span class="comment">//需要添加#include &lt;QDebug&gt;</span>
    <span class="comment">//如果接受成功，可在终端看到输出。</span>
    qDebug() &lt;&lt; name &lt;&lt; time;
}
</code></pre></li>
<li>测试代码改动（关键点）</li>
<li><p>在此刻我们需要让编译器知道，我们的信号函数是一个参数，而槽函数是两个参数，其中一个是带有默认参数的，我们应该怎么做？函数指针对于默认参数是无效的，那么除了使用C++11新特性<strong>Lambda匿名函数</strong>以外，最直接的还是使用宏<strong>SLOT 和 SIGNAL</strong>，在这里我们使用这两个宏可以节省很多工作量，缺点就是无法在编译时刻知道是否匹配，所以我们需要小心谨慎的使用。</p>
<pre><code><span class="rule"><span class="attribute">QObject</span>:<span class="value">:<span class="function">connect</span>(&amp;new_paper_1, <span class="function">SIGNAL</span>(<span class="function">newPaper</span>(QString)),
                &amp;new_reader_1, <span class="function">SLOT</span>(<span class="function">receive_newpaper</span>(QString)))</span></span>;
</code></pre><p>可以看到，我们的槽函数明明有两个参数，但是此处<strong>SLOT</strong>宏内只出现了一个，这就表明已经告知编译器是默认参数。</p>
</li>
</ul>
</li>
<li><p><strong>Lambda 匿名函数在 connect 的应用</strong></p>
<ul>
<li>再实在没有办法用其他方法实现两个窗口或者不同对象之间的<strong>直接对话</strong>时候，可以考虑使用信号槽来间接实现</li>
<li><strong>Lambda</strong> 扮演的角色是让类更加简洁，语法更加简单。</li>
<li><p>到了 <strong>Qt5</strong> 时代，在使用信号槽语法的时候，更多的是用函数指针地址，而不是之前的<code>SIGNAL</code> 和 <code>SLOT</code> 宏，这样更能充分的发挥 <strong>Lambda</strong> 的性质。</p>
<pre><code>class MainWindows::MainWindow():
<span class="comment">//... 一些自动生成的初始化</span>
{
    <span class="comment">//...setup Ui</span>
    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=](){
       ui-&gt;browser_show-&gt;setText(QStringLiteral(<span class="string">"成功使用Lambda语法设置文本显示"</span>))；<span class="comment">//一个槽</span>
    ui-&gt;pushButton-&gt;setEnable(<span class="keyword">false</span>);<span class="comment">// 另一个槽</span>
    qDebug &lt;&lt; QStringLiteral(<span class="string">"成功使用Lambda语法！"</span>);

    }
    ...
}
</code></pre><p>这是基本使用方式，好处就是可以一次性的调用多个槽，而不是一个connect只能对应一对信号槽链接。</p>
</li>
</ul>
</li>
</ul>
<h4 id="老生常谈的_中文显示">老生常谈的 中文显示</h4><ul>
<li>使用 <strong>UTF-8</strong> 模式存储源文件（借助其他编辑器，例如 <strong>NotePad++</strong>, <strong>Sublime Text</strong> 等）</li>
<li>使用 <code>QStringLiteral 包裹中文</code></li>
<li>行了。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="开启C++11支持">开启C++11支持</h4><ol>
<li><p>.pro文件中增加：</p>
<pre><code><span class="comment">CONFIG</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>
</code></pre><p>或者</p>
<pre><code>QMAKE_CXXFLAGS += -<span class="keyword">std</span>=c++<span class="number">11</span>
</code></pre><p>两种添加形式都是可行的，建议每个工程单独配置，而不要一劳永逸。</p>
</li>
</ol>
<h4 id="信号与槽">信号与槽</h4>]]>
    
    </summary>
    
      <category term="Qt" scheme="//wushxin.top/tags/Qt/"/>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Opencv3.0.0配置]]></title>
    <link href="//wushxin.top/2015/06/08/Opencv3%E9%85%8D%E7%BD%AE.html"/>
    <id>//wushxin.top/2015/06/08/Opencv3配置.html</id>
    <published>2015-06-08T08:26:15.000Z</published>
    <updated>2015-06-10T08:21:31.798Z</updated>
    <content type="html"><![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/" target="_blank" rel="external">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="external">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html" target="_blank" rel="external">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/" target="_blank" rel="external">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4><a id="more"></a>
<p>有了上述两个工具之后，我们就可以着手配置自己的开发环境了，但是先要声明的是，每一个不同的工程项目就需要重新配置一次。</p>
<ol>
<li><p>工程项目是什么？就是 <strong>文件 -&gt; 新建 -&gt; 项目</strong>，在这里我们点击了项目之后出现一个窗口：<br><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwljr6jj211y0lc418.jpg" alt=""></p>
<p> 图片可能不太清晰，但是大概是这么一个回事，修改一下名称，以及存储位置(为了方便)之后，点击 <strong>确定</strong> 之后 Visual Studio 自动帮你生成一个工程项目，这时候先停下，回到桌面。</p>
<ul>
<li>打开目录： <strong>C:\opencv\build\x64\vc12\bin</strong>，查看里面是否有文件，并将目录添加到系统环境变量(<strong>PATH</strong>)当中，如何添加？<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwivdbyj20mz0cbdgq.jpg" alt=""> </li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwh92pcj20dp0gtq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgi9m8j20cp0fkdg7.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkxxz0j20bh05adfs.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>添加完环境变量以后，我们可以开始下一步的配置，根据第一步所创建的项目，我们打开它的属性管理器，当然很可能的就是你创建完成以后，自动就在这个界面，初始情况下，我们创建的是Win32(x86)的工程，这个时候我们需要做的就是，因地制宜。先前说了我是X86_64，也就是64位操作系统，那么我们就应该让整个环境适配他，<strong>(至于32位网上的教程很多)</strong></p>
<ul>
<li><p><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwkirl7j20880hh749.jpg" alt=""></p>
<p>接下来，右键你的工程，选择 <strong>属性</strong>，可以很清楚的看见，右上角显示的是<strong>Win32</strong>，我们的目的是将其改为适配64位的开发环境：</p>
</li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwjcj8kj20lc0ea3zk.jpg" alt=""></li>
<li>如图所示，点击配置管理器，选择X64，并在外面将目标计算机改成x64<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwehzjxj20jw0e0aa7.jpg" alt=""></li>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwf0k50j20jw0e0jrp.jpg" alt=""></li>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwfiqf9j20lc0fc3zn.jpg" alt=""> </li>
</ul>
</li>
<li>架构问题解决。接下去才是真正的配置步骤。</li>
<li>在属性管理器中，打开你的工程看见四个包含文件夹，删除Win32的两个，留下x64，右键 <strong>Debug|x64</strong> 文件夹，选择 <strong>添加新项目属性表(P)…</strong>，保存为 <strong>opencv_debug</strong> 以后，会发现多了一个属性表文件，如法炮制<strong>Release|x64</strong>文件夹，接下来的操作直到第五步，其它的两个属性表都一样</li>
<li><strong>(opencv_release)</strong></li>
</ul>
</li>
<li><p>首先是打开任意一个属性表文件(双击它= =)，在 <strong>配置属性 -&gt; VC++目录 -&gt; 包含目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>include 目录</strong>，按照我的路径格式，需要添加三个路径分别是：</p>
<blockquote>
<p>C:\opencv\build\include</p>
<p>C:\opencv\build\include\opencv</p>
<p>C:\opencv\build\include\opencv2</p>
</blockquote>
<ul>
<li><img src="http://ww3.sinaimg.cn/mw690/81b736ebjw1eswqwg1wm4j20lc0f4ab0.jpg" alt=""></li>
</ul>
</li>
<li><p>其次是，在 <strong>配置属性 -&gt; VC++目录 -&gt; 库目录 -&gt; &lt;编辑…&gt;</strong>之中添加 <strong>lib</strong> 目录，按照我的路径格式，需要添加路径是：</p>
<blockquote>
<p>C:opencv\build\x64\vc12\lib</p>
</blockquote>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwhuj95j20lc0gaab2.jpg" alt=""><br>这个便是存放依赖文件的地方，后续会用到。</li>
</ul>
</li>
<li><p>最后是，在 <strong>配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; &lt;编辑…&gt;</strong> 之中添加依赖，对于 <strong>Opencv-3.0.0</strong> 来说，我们只需要添加两个依赖就足够了，此处分为两部分：</p>
<ul>
<li><p>对于<strong>Debug|x64</strong>，也就是当下我们正在配置的这个属性表，添加两个文件:</p>
<blockquote>
<p>opencv_ts300d.lib</p>
<p>opencv_world300d.lib</p>
</blockquote>
<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwib94kj20sb0e1dh5.jpg" alt=""></li>
</ul>
</li>
<li><p>对于 <strong>Release|x64</strong>的属性表来说，需要添加剩下的两个文件：</p>
<blockquote>
<p>opencv_ts300.lib</p>
<p>opencv_world300.lib  </p>
</blockquote>
</li>
</ul>
</li>
<li>Ps: 对于其他版本的Opencv的依赖库添加，可以自行打开 <strong>lib</strong> 文件夹进行查看，不一定需要网上的教程。</li>
<li>如果不想每次创建工程的时候都这么麻烦，那么我们只需要把两个属性表拷贝出来就行了，下次直接导入即可。 </li>
<li>当两个属性表都配置完成之后，我们就大功告成啦，接下来进入最后一步，测试</li>
</ol>
<h4 id="测试">测试</h4><p>在 <strong>属性管理器</strong> 的旁边有一个 <strong>解决方案资源管理器</strong> ，点击之后，会发现这才是以后工作的场景</p>
<ol>
<li>在 <strong>源文件</strong> 文件夹中，添加C++源文件，在其中输入测试代码：<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1eswqwgxfdfj20j009o74r.jpg" alt=""></li>
</ul>
</li>
</ol>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt; </span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\core\core.hpp&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;opencv2\highgui\highgui.hpp&gt;  </span>

<span class="keyword">using</span> <span class="keyword">namespace</span> cv;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Mat img = imread(<span class="string">"temp.jpg"</span>);    

    <span class="keyword">if</span> (img.empty())
    {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>;
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    imshow(<span class="string">"mypic"</span>, img);
    waitKey();

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>保存。</p>
<ol>
<li>在 <strong>资源文件</strong> 文件夹中，添加图片<strong>temp.jpg</strong>，随便找一张格式是jpg的图，放进去就行，放进去的方式是 <strong>右键资源文件 -&gt; 添加 -&gt; 现有项(G)…</strong>，找到你的图片，双击，添加完成。</li>
</ol>
<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwnccirj20iy076wer.jpg" alt=""></li>
</ul>
<ol>
<li><p>点击 <strong>生成 -&gt; 生成解决方案</strong> ，之后点击 <strong>启动调试</strong> 也就是运行的意思。</p>
</li>
<li><p>很大的几率发现并不能正常的运行，错误提示无法打开PDB文件，查了一下，似乎尿性很高，于是乎有一个解决办法，不是无法打开吗？那就从微软的服务器在线下载过来，这个方法对每个工程都需要进行一次，但是第一次过后就不需要第二次了。请在联网情况下，完成下列操作，具体方法： </p>
<ul>
<li>依次点击 <strong>调试 -&gt; 选项与设置(G)…</strong> <ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1eswqwd6uz9j20ag0e9jry.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 常规</strong> ，勾选 <strong>启动源服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwdmf0nj20l20dqjsk.jpg" alt=""></li>
</ul>
</li>
<li>之后选择 <strong>调试 -&gt; 符号</strong> ，勾选 <strong>Microsoft服务器支持</strong><ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1eswqwe3srkj20l20dqt9j.jpg" alt=""> </li>
</ul>
</li>
<li>中间如果有警告，一律选择是。</li>
</ul>
</li>
</ol>
<h4 id="2_配置_Code::Blocks_13-12">2 配置 Code::Blocks 13.12</h4><ul>
<li><p>首先打开安装好的 <strong>CMake-gui</strong>，在<strong>source code</strong>一栏加入源文件的路径，也就是下载的<strong>opencv</strong>里的<strong>source</strong>，在<strong>build binaries</strong>一栏加入输出的路径。</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9ay0n5j20n20jdq30.jpg" alt=""></li>
</ul>
</li>
<li><p>点击<strong>Tools -&gt; Configure</strong>，如图配置：</p>
<ul>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo9bdr6hj20n20jdglz.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后出现红色的选项，将<strong>WITH_IPP</strong>选项去掉，之后点击<strong>Options -&gt; Sipress dev Warnings</strong>，后点击<strong>Generate</strong>生成makefile文件：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9bvra5j20n20jd0td.jpg" alt=""></li>
</ul>
</li>
<li>随后等待进度条，完成之后，打开目录<strong>C:\opencv\mybuild</strong>，双击打开工程文件<strong>OpenCV.cbp</strong>开始编译，并附上编译后的文件夹图：<ul>
<li><img src="http://ww1.sinaimg.cn/mw690/81b736ebjw1esxo9cnz6sj20h70eq0u6.jpg" alt=""></li>
</ul>
</li>
<li>编译结束后，如果一切正常，将上图中的<strong>bin</strong>加入路径</li>
<li>打开<strong>Code::Blocks</strong>，新建一个Console Application工程，右键工程名字，选择<strong>Build Option</strong>出现一个新窗口，在其中我们要开始配置<strong>Opencv</strong>：<ul>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo99ko98j20kw0fmq3c.jpg" alt=""></li>
<li><img src="http://ww2.sinaimg.cn/mw690/81b736ebjw1esxo99xg7wj20kw0fmjrp.jpg" alt=""></li>
<li><img src="http://ww4.sinaimg.cn/mw690/81b736ebjw1esxo9ajo5qj20rw0gataz.jpg" alt=""></li>
</ul>
</li>
<li>添加测试文件（和VS的一样）。</li>
</ul>
<h4 id="结束">结束</h4><p>就是这样如果还有什么错误的话，不妨去Google看看，比如dll不存在的问题，那一定是你没有把要使用的bin目录加入到系统环境当中</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="配置Opencv3-0-0">配置Opencv3.0.0</h4><p>前天，Opencv3.0.0的正式版本发布，不再有奇怪的缺少文件之类的错误，正好最近需要使用它来完成一些神经网络上的辅助，也就尝试了配置，下面记录配置的过程。</p>
<h4 id="准备">准备</h4><ol>
<li><a href="https://www.visualstudio.com/">Visual Studio 2013</a></li>
<li><a href="http://www.codeblocks.org/downloads/26">Code::Blocks 13.12</a></li>
<li><a href="http://opencv.org/downloads.html">Opencv-3.0.0</a></li>
<li><a href="http://www.cmake.org/download/">CMake3.3.0-rc1-win32-x86</a></li>
</ol>
<h4 id="声明">声明</h4><ul>
<li><p>按照自己的喜好来选择第一部分或者第二部分</p>
</li>
<li><p>第一部分 ： Visual Studio 2013 配置 Opencv3.0.0</p>
</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0 的放置路径为 <strong>C:\opencv</strong></li>
<li>Visual Studio 工程存放位置为 <strong>C:\VSProject</strong> 目录下<ul>
<li>在此处建议，无论什么路径，都是用英文，并且不要使用空格，如果是操作系统自带的文件路径请看准是否有空格，否则配置这opencv会让你疯狂。</li>
</ul>
</li>
<li>对于 <strong>Visual Studio 2013</strong> 来说，我们使用的官方编译好的文件夹所在位置是 <strong>vc12</strong>，我也不懂为什么，总之就是这样。</li>
</ol>
<ul>
<li>第二部分 ： Code::Blocks 13.12 配置 Opencv3.0.0</li>
</ul>
<ol>
<li>Windows8.1 + 64位</li>
<li>Opencv-3.0.0待编译的源代码路径为 <strong>C:\opencv3</strong>（由Github上下载）</li>
<li>Opencv编译完成的所有文件放于 <strong>C:\opencv\mybuild</strong>，即待会使用CMake输出的文件夹。</li>
<li><strong>include</strong> 和第一部分相同，不同的只是 <strong>lib</strong> 和 <strong>bin</strong> 目录，我选择把<strong>bin</strong>目录全部拷贝到Debug文件夹里。</li>
</ol>
<h4 id="1_配置_Visual_Studio_2013">1 配置 Visual Studio 2013</h4>]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
      <category term="Opencv" scheme="//wushxin.top/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(5)---效率(下)]]></title>
    <link href="//wushxin.top/2015/05/29/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C-5.html"/>
    <id>//wushxin.top/2015/05/29/我为什么学C-5.html</id>
    <published>2015-05-29T13:19:50.000Z</published>
    <updated>2015-06-06T14:46:48.104Z</updated>
    <content type="html"><![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。<a id="more"></a>    
<ul>
<li>打个不太贴切的比喻，假设计算机是一个家，CPU是一个人，想象一下这个家中的所有物品都是井然有序的，这个人想要工作必然会需要工作物品，所以他需要从某些地方拿来，用完以后再放回去，这些地方就是存储器，但是过了一段时间发现这么做太浪费时间，有时候某些东西太远了，所以，人想把它把它放在离自己更进的地方，这样自己的效率就高很多，如果这个东西一段时间内不再用，则把它放回原处，留出位置给更需要的工作物品，于是形成了越常使用的物品离人越近的现象。这便是计算机存储器的分层结构的意义。</li>
<li>而对于一个有良好局部性的程序而言，我们总能在离自己最近的地方找到我们所需要的数据，回到计算机：我们知道计算机的存储器是分层结构的，即每一层对应着不同的读写速度等级(CPU寄存器 &gt; 高速缓存 &gt; 主存 &gt; 硬盘)，而我们的程序总是按照从左至右的顺序依次查找，每次找到一个所需要数据，不出意外，总是将其移动到上一层次的存储器中存储，以便下次更高速的访问，我们称这种行为叫做 <strong>命中</strong> 。越好的程序，越能将当时所需的数据放在越靠近左边的地方。这便是局部性的意义所在。</li>
<li>当然，存储器如此分层也是出于无奈，在处理器的速度和存储器的速度实在差距的情况下只有如此做才能让处理器更加充分的利用，而不至于等待存储器读写而空闲，也许某一天，当内存的<strong>位价</strong>和普通硬盘不相上下或者差距不多的时候，也许内存就是硬盘了。而当今也有人使用某些特殊的软件在实现这个功能，凭着自己计算机上大容量的内存，分割出来当作硬盘使用，存取速度让硬盘望尘莫及。</li>
</ul>
</li>
</ul>
<h4 id="局部性">局部性</h4><p>前方提到了局部性，局部性体现在了，当步长越大，空间局部性越低，大多数情况下会造成性能降低，比如最常见的多维数组循环(我鲜少使用多维数组的原因之一便在于此)，前面说过多维数组实际上只是数个一维数组的包装而已，C语言中并没有真正的多维数组，而是将其解读成内存中的一维的连续内存，但是当我们遍历它的时候，C语言为了不让我们被底层实现所困扰，所以生成了多维数组遍历的假象：</p>
<p>让我们重温一遍”多维数组”：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;    </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> dim_1_arr[<span class="number">4</span>]    = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
    <span class="keyword">int</span> dim_2_arr[<span class="number">2</span>][<span class="number">2</span>] = { {<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>} };
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)
        result_1 += dim_1_arr[i];
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>此例中，对一维数组进行步长为 <code>1</code> 遍历求和，假设内存中数组的起始位置是 <code>0</code></p>
<p><code>0 =&gt; 4 =&gt; 8 =&gt; 12</code></p>
<pre><code><span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; <span class="number">3</span>;++j)<span class="comment">{
    for(int i = 0;i &lt; 3;++i){
        result_2 += dim_2_arr[i][j];
    }</span>
}
</code></pre><p>此例中，我们的步长是多少呢？我们来看一下</p>
<p><code>0 =&gt; 8 =&gt; 4 =&gt; 12</code></p>
<p>可以很清晰的看出两段不同代码之间的跳跃，为什么？观察到多维数组的遍历中我们和平时的做法有些不同，是先对<code>i</code>进行遍历，再对<code>j</code>进行遍历，这就导致了程序必须在内存块中<strong>无规律</strong>的跳动，这里的无规律是计算机认为的无规律，虽然在我们看来的确是有迹可寻，优秀的编译器能够对它进行优化处理。就事论事，即这段程序的空间局部性比较差，对于一个在内存中大幅度跳跃，无规律跳跃的程序都将影响程序的性能。这个判定对于一个连续的内存块来说是很重要的，比如C语言中的结构体。</p>
<p>实际上C语言也是能够面向对象的，但是十分复杂，就像拿着棒子织衣服一样。而C语言的机构体能够让我们在一定程度上初步理解对象这个概念，因为它是一个完整的个体，虽然对外界<strong>毫不设防</strong>。</p>
<blockquote>
<p><strong>对于结构体</strong></p>
</blockquote>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> VECTOR 4</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">double</span> salary;
        <span class="keyword">int</span>    index[<span class="number">4</span>];
}test_data;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span> result_1 = <span class="number">0</span>;
    <span class="keyword">int</span> result_2 = <span class="number">0</span>;
    test_data dim_1_arr[VECTOR];
    <span class="comment">/* ...填充数据 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
    {    
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
            result_1 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 1 */</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; VECTOR;++i)
            result_2 += dim_1_arr[i].index[j];
    }<span class="comment">/* for loop 2 */</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre><p>还是和上方一样，假设 <code>dim_1_arr</code> 起始位置为 <code>0</code></p>
<p> <strong>for loop 1</strong>：</p>
<p><code>8 =&gt; 12 =&gt; 16 =&gt; 20 ==&gt; 32 =&gt; 36 =&gt; 40 =&gt; 44 ==&gt; ...</code></p>
<p><strong>for loop 2</strong>：</p>
<p><code>8 =&gt; 32 =&gt; 56 =&gt; 80 ==&gt; 12 =&gt; 36 =&gt; 60 =&gt; 84 ==&gt; ...</code></p>
<p>从上方不完整的比较来看，<strong>loop 1</strong> 相对于 <strong>loop 2</strong> 来说有更好的空间局部性，很明显在 <strong>loop 2</strong> 中，CPU读取是在无规律的内存位置跳跃，而 <strong>loop 1</strong> 则是以单调递增的趋势向前(这里的向前指的是直观上的向前)读取内存。</p>
<ul>
<li>在此处回顾一下C语言的结构体性质与知识：<ul>
<li>对于任意一个完整定义的结构体，每一个对象所占有的内存大小都符合<strong>内存对齐</strong>的规则。</li>
<li>对于结构体内的各个成员而言，其相对于对象存储地址起始的距离，称为<strong>偏移量</strong>。</li>
</ul>
</li>
<li><p>解释：</p>
<ul>
<li><p>内存对齐便是对于一个结构体而言，其所占内存大小总是最大成员的整数倍，其中最大成员指的是最基本成员，即：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
    test_data test_1;
    <span class="keyword">int</span>       test_2;
}test_data_2;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_2 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_2));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 32</code></p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index[<span class="number">4</span>];
        <span class="keyword">int</span> store_1;
        <span class="keyword">int</span> store_2;
}test_data_3;
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        test_data_3 test_3;
        <span class="keyword">int</span>         test_4;
}test_data_4;

<span class="comment">/*...*/</span>
<span class="built_in">printf</span>(<span class="string">"The size of test_data_4 = %d\n"</span>,<span class="keyword">sizeof</span>(test_data_4));
<span class="comment">/*...*/</span>
</code></pre><p>  <code>输出： The size of test_data_2 = 28</code></p>
<p>  仔细对比<code>test_data_3</code>与<code>test_data</code>的差异，可以发现不同处，在前者的内部包含了一个<code>double</code>类型的成员，在我的机器上它的长度为 <code>8</code> ，后者的内部包含了两个<code>int</code>类型的成员，每个长度为 <code>4</code>，但是他们的长度在直观上是一样的！但是真正在使用的时候我们才能察觉到其中的差异，这就是我所说的<strong>最基本成员</strong>的意义所在。虽然我们在使用结构体的时候，能够将其当作一个整体，但是实际上他们与内建(build-in)的类型还是有一些差异的。</p>
</li>
<li>偏移量通俗地说，就是该成员起始地址距离起始位置的长度，在结构体中，C语言是怎么为结构体分配设定大小的呢？除了内存对齐外，还需要考虑定义结构体时，其中成员的声明顺序，换句话说，谁首先声明，谁的位置就靠前。而某个成员的偏移量代表着其<strong>起始位置</strong>减去其所属对象的<strong>起始位置</strong>，(此处需要注意的是，两个毫不相干的指针相减所得到的结果是无意义的，只有当两个指针同在一个作用域内时，减法才是有意义的，为了避免潜在的错误，我们要谨慎使用指针减法操作)。</li>
</ul>
</li>
<li><p>就此回过头去再看看上方的 <strong>loop</strong> 解释，应该能够理解到，那些数字是通过偏移量来进行计算得到的。</p>
</li>
<li><p>之所以没有详细的介绍时间局部性是因为，对于时间局部性而言，其最大的影响因素便是操作区域的大小，比如我们操作的数组或者文件的大小，越小时间局部性越好，试想一下对于一个小的文件和大的文件，我们更容易操作到同一块地方多次的，必定是小的文件。而操作文件的大小有时候并不能很好得成为我们的操作因素，故只能多关注空间局部性。</p>
</li>
</ul>
<h4 id="高速缓存器">高速缓存器</h4><ol>
<li><p>在前方提到了，一般情况下，局部性好的程序能够让程序比局部性差的程序更有效率，而对于局部变量而言，一个好的编译器总是尽可能的将之优化，使其能充分使用<strong>CPU寄存器</strong>,那么寄存器的下方,也就是速度最接近寄存器的,便是所谓的<strong>高速缓存器</strong>了，对于高速缓存器而言，其最大的功效便是缓冲，缓冲有两层意思：</p>
<ul>
<li>缓存数据，使下一次需要的数据尽可能的<strong>“靠近”</strong>CPU，此处的靠近并不是物理意义上的距离靠近。</li>
<li>缓冲一下CPU于存储器巨大的速度差距，防止CPU空闲浪费。</li>
</ul>
</li>
<li><p>对于现在的计算机而言，CPU基本都是三层缓存：<strong>一级缓存(L1)</strong>,<strong>二级缓存(L2)</strong>,<strong>三级缓存(L3)</strong>，可以通过 <strong>CPU-Z(Windows) / Mac OS系统报告</strong> 来查看自己的CPU缓存，在软件中我们能够看到，在一级缓存中会分为两个部分 ：<strong>一级数据</strong>，<strong>一级指令</strong>，这代表着<strong>只读写数据</strong>，<strong>只读写指令</strong>，这样分开的意义在于处理器能够同时处理一个数据和一个指令，上述所说的都是对于一个CPU核而言的，也就是说当CPU是多核的时候，那就有多个这种<strong>“功能集合(L1+L2)”</strong>。二级缓存则与一级缓存同在一个核中，每个核都拥有自己的二级缓存，最后所有核共享唯一一个(L3)</p>
<ul>
<li>总的来说，对于高速缓存器来说，一般分为三层，第一层比较特殊由独立的两个部分组成，第二层第三层则是各自独立一体并未区分功能(既存数据又存指令)，而第一层和第二层则是每个核单独享有不同的缓存器，第三层则是各个核共享一个层，所以我们经常看见在个人计算机上，L3的大小经常是以<strong>MB</strong>为单位的，而第一层则多以KB甚至是Byte为单位。</li>
<li>在实际中，喜欢研究计算机的人经常会在一些专业软件中看见自己的<strong>CPU</strong>配置，在<strong>缓存</strong>一栏的一级和二级中总能看见<code>2 x 32 KBytes</code>之类的参数，<code>32</code>代表的就是某级的缓存大小，而前方的<code>2</code>则是核数，即有几个核便有乘多少，和之前所说的一致，具体可参见下方的<strong>缓存器图示</strong></li>
</ul>
</li>
</ol>
<ol>
<li><p>高速缓存器的各个层依然遵守逐步降速的规律，即读取周期 <strong>L1 &lt; L2 &lt; L3</strong>，而影响较大的便是上文提到的的命中率，我们知道越上层的高速缓存器总是将下层的存储器映射在自己的存储器中，而按照逻辑推断，上层的实际空间比下层的要小，因为上层的空间更加宝贵速度更快，这就导致我们无法将下层的空间一一对应的映射到上层里，那么我们就想到一个办法，并不是将下层存储器的内容完全映射到上层，<strong>而是上层有选择性的将下层的部分内容抽取到上层</strong>，这便是不命中之后的操作。</p>
</li>
<li><p>对于CPU从存储器中读取数据这个操作，如果我们使用了高速缓存以及内存这两个概念，那么就会有一个延伸概念，命中。而对于这个概念只有两种情况，命中或者不命中。而对于一个初始化的高速缓存器，它一定是空的，也许在物理意义上它并不是空，但是实际上在程序看来它的确是空的，为了区分这个，高速缓存器专门使用了一个<strong>位(bit)</strong>来表示此组是否有效(即是否为空)，既然它是空的那么，我们第一次无论如何都无法命中数据，这时候该层的高速缓存器就会向下一层，在该层中寻找所要的数据，每次要向下一层申请寻找的行为一般称为<strong>惩罚</strong>，而当我们从存储器中将所需的数据加载到高速缓存器中的时候，我们便开始了运算，而一切关于高速缓存器效率的改进都集中在命中率的提升。</p>
<ul>
<li><p>假设有一个数组需要操作，由于数组是一个连续的内存空间，对其进行步长为<code>1</code>的操作拥有很好的空间局部性，那么可以当成一个很好的例子，在高速缓存器看来读取一个有<code>n(n&gt;N)</code>个元素的数组<code>vector</code>并不是一次性读完，而是分次读取，如果读取了<code>k</code>次那么至少有<code>k</code>次不命中，这是不可避免的，而对于读取的数据也不一定是我们需要的，用书上的例子来说：<br><code>vector:|[0]|[1]|[2]|[3]|[]|[]|[]|[]|[]|[]|[]|</code><br>假设操作数组的每一个元素，我们一次读取三个内存的值，类型为<code>int</code>，因为原理都一样。那么在初始化时候，高速缓存器为空，在第一次操作的时候，读取了四个(如上所示)，此时一定经过了一次 <strong>不命中</strong> 。</p>
<p>  很好理解，因为缓存器空，所以第一次操作必然不命中，所以我们需要向下级存储器读取我们需要的数据，那么第二访问高速缓存的时候，可以命中<code>vector[0]</code>，依次命中后续两个，直到需要<code>vector[4]</code>，出现了不命中，那么我们就需要重复上一步，再次读取三个数据，依次类推直到结束。<br><code>vector:|[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[]|[]|[]|</code></p>
<p>  现在我们能够从一定层面上解释为什么局部性好的程序比局部性差的程序要有更好的效率了，原因就在对于高速缓存器的利用，<strong>首先反复利用本地临时变量能够充分的调用高速缓存器的功能做到读写的最优化，其次步长为越小也越能尽最大的能力发挥高速缓存器读取的数据</strong>，在这点上再回过头思考多维数组的遍历并进行操作，如果没有考虑空间局部性(即先操作大块，再操作小块)，那么在高速缓存器中，它的不命中率令人发指，这也是操作不当效率低的原因。</p>
</li>
<li><p>另一方面，对于不同步长而言，其影响的也是高速缓存器的命中率，还是上方的<code>vector</code></p>
<pre><code>步长       | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> |
不命中<span class="regexp">/命中 |1/</span><span class="number">4</span>|<span class="number">1</span><span class="regexp">/2|2/</span><span class="number">3</span>|<span class="number">1</span><span class="regexp">/1|1/</span><span class="number">1</span>|
</code></pre><p>可以看出来，对于步长而言，当到了一定的上限以后，每次的请求都会不命中，那么这时候本层的高速缓存器相当于作废，时间全都耗费在下层数据传送到上层的时间，因为每次读取都是不命中，可以利用上方的例子自己试着推理一下。</p>
</li>
</ul>
</li>
<li><p>在参考文献中提到了一种优化程序的技巧，便是充分的利用高速缓存器，并且不受缓存器大小的限制，做法是当所操作的数据过大的情况下，通过构造循环来创建一个有一个大块，这些块能够被高速缓存器容纳，那么我们就能够充分利用高速缓存器来实现功能。 </p>
</li>
</ol>
<blockquote>
<p>缓存器示意图</p>
</blockquote>
<pre><code><span class="code">----------------------------------------------
|  CPU某个核                                  |  ......其他核
| ----------  ----------  ------------------ | 
| |        |  |        |  |                | |  
| |   L1   |  |   L1   |  |   L2高速缓存器  | | 
| | 一级数据|  | 一级指令|   |    二级缓存器   | |
| ----------  ----------  ------------------ |
----------------------------------------------</span>

<span class="code">------------------------------------------------------------------------------------
|                                                                                  |
|                                   L3高速缓存器                                    |
|                                    三级缓存器                                     |
------------------------------------------------------------------------------------</span>
</code></pre><h4 id="参考:[1]深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">[1]深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="更新于_2015/6/3_19:19:13">更新于 2015/6/3 19:19:13</h4><h4 id="0x08-C语言效率(下)">0x08-C语言效率(下)</h4><h4 id="注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。">注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，<code>z</code>轴为速率，<code>x</code>轴为步长，<code>y</code>轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。</h4><p>上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？</p>
<p>当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的<strong>命运</strong>。</p>
<p>可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<br><strong>CPU寄存器</strong> <strong>高速缓存器</strong> <strong>主存</strong> <strong>硬盘</strong></p>
<p>但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？</p>
<ul>
<li>有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。</li>
<li>就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 <strong>Visual Studio 2008</strong> 在 <strong>Windows XP</strong> 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：<strong>时间局部性和空间局部性</strong> 。<ul>
<li>时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它</li>
<li>空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。</li>
<li>良好的局部性改进一般能很好的提升程序的性能。</li>
</ul>
</li>
<li>所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(4)---效率(上)]]></title>
    <link href="//wushxin.top/2015/05/20/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(4).html"/>
    <id>//wushxin.top/2015/05/20/我为什么学C(4).html</id>
    <published>2015-05-20T03:06:38.000Z</published>
    <updated>2015-06-03T11:50:43.786Z</updated>
    <content type="html"><![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的<a id="more"></a></li>
<li><p>注：随着编译器的版本更新，即使不开启优化选项，自带的编译器优化依旧能够为我们编写的代码提供一部分优化，这便是不使用老版本编译器的原因，虽然作为一个程序员不应该太依赖于编译器，但是我认为，时代在进步，信息量正在无限的膨胀，但是人类的大脑以及精力在一个大时代内是有限的，换句话说对于普通人而言我们的记忆是有限的，我们不应该把精力放在前人已经做完的事情上，而是要站在巨人的肩膀上向更远处眺望，如此我们应该充分利用工具来帮助我们实现一些既有的功能，而程序员应该更 专注于发现新的思路，以及想法，在图灵测试尚未有人打破之前，程序员依赖编译器并不是一件错误的事情。</p>
<p>  对于当下的编译器，以<code>GCC</code>(<strong>GCC不仅仅是一个编译器，但这里将它当成编译器的代名词</strong>)为例，<code>-O2</code>是一个为大众所接受的优化等级，对于其他编译器，一般程序员可以选择使用由Google和Apple联合开发的编译器<code>clang</code>也是一个很好的选择， 在<code>-O2</code>的优化等级下，<code>GCC</code>一般情况下能够自动执行<strong>循环展开</strong>优化，</p>
</li>
</ul>
<h4 id="开始">开始</h4><ol>
<li><p>.</p>
<pre><code><span class="comment">/*struct.h*/</span>   
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> me{
        <span class="keyword">int</span>        value;
        <span class="keyword">struct</span> me* next;
}data_t;

<span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> index;
        data_t* storage;
}block;    
</code></pre><p>为了测试方便我们首先定义了两个结构体，分别是:</p>
<p> <code>block</code>代表一个块，每个块都有一个序号(<code>int</code>)，一个数据域<code>data_t</code><br><br> <code>data_t</code>代表一个数据域，原型是一个链表，每个<code>data_t</code>对象中包含一个数据和一个指针。</p>
<pre><code>/*main.c*/
<span class="comment">#include "struct.h"</span>
<span class="comment">#define ARR_SIZE 10</span>
<span class="keyword">static</span> inline <span class="type">int</span> get_len(<span class="keyword">const</span> data_t* data)
{
    <span class="type">int</span> len = <span class="number">0</span>;

    <span class="keyword">if</span>(!data)
        fprintf(<span class="literal">stderr</span>,<span class="string">"The data in %p is NULL\n"</span>,data);
    <span class="keyword">else</span>
        <span class="keyword">while</span>(!data-&gt;next)
        {
            ++len;
            data = data-&gt;next;
        }
    <span class="keyword">return</span> len;
}

<span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; get_len(process-&gt;storage);++i)
    {
        *<span class="literal">result</span> += (process-&gt;storage)[i];
    }
}
</code></pre><p>此时我们得到了两个测试函数，<code>get_len</code>和<code>mix_cal</code>分别用来得到<code>data_t</code>长度，以及计算数据域的总和。</p>
<pre><code>/*main.c*/    
<span class="type">int</span> main(<span class="type">void</span>)
{
    <span class="keyword">block</span>* block_in_all[<span class="type">ARR_SIZE</span>]  = { <span class="type">NULL</span> };
    <span class="type">int</span>    result_in_all[<span class="type">ARR_SIZE</span>] = { <span class="number">0</span> };
    /*
    *假设生成了许多的`<span class="keyword">block</span>`类型对象
    *将许多的`<span class="keyword">block</span>`放置在一个数组中，每个元素类型为`<span class="keyword">block</span>*`
    *每个<span class="keyword">block</span>对象中都包含非空的data_t类型的数据域
    */
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        mix_cal(block_in_all[i], result_in_all+i);
    }
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="type">ARR_SIZE</span>;++i)
    {
        printf(<span class="string">"The %dth block have the total %d data\n"</span>,
                    block_in_all[i]-&gt;index, result_in_all[i]);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>耐心读完上述的代码，它是用来求和的，求一个域中的所有元素的和。仔细分析一下，很容易就能看见一些缺点，最大的莫过于在<code>mix_cal</code>函数中对于<code>get_len</code>函数的调用，在此处看来十分明显，但是我们在编写程序的时候是否能够注意到这个问题呢？<br><br>对于一些不必要的函数调用我们要做的便是将他们提取出来，使用临时变量是一个很好的办法，因为在编译器的帮助下<strong>临时变量</strong>在<strong>允许的情况下</strong>能够充分的利用CPU的寄存器。之所以是允许的情况下，是因为寄存器的数量并不多，而编译器在寄存器的使用上需要考虑许多的复杂因素，故并不是每次使用临时变量都能加入寄存器。但这并不妨碍我们提升程序的性能。</p>
<p> 在此处，我们应该将<code>for</code>循环中的判断语句里的<code>get_len</code>函数提取出来，在外部使用一个临时变量接收结果，而不是在循环中一直调用该函数。</p>
<pre><code><span class="typename">int</span> <span class="built_in">len</span> = get_len(process-&gt;storage);
</code></pre></li>
<li><p>.</p>
<p> 依旧是上方的代码，我们来讲述一下，循环展开。</p>
<p> 对于<code>mix_cal</code>函数，我们或者说编译器可以如何提升它的速度呢？我们说过一点的小改变都可能对一个程序的最终代码产生极大的影响，对此最常用的便是尝试，前人之路早已铺好，不需要重复造轮子了。</p>
<p> 循环展开:</p>
<pre><code><span class="type">int</span> reality = len - <span class="number">1</span>, i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
{
    *<span class="literal">result</span> = *<span class="literal">result</span> + (process-&gt;storage)[i] 
                      + (process-&gt;storage)[i+<span class="number">1</span>];
}
<span class="keyword">for</span>(;i &lt; len;++i)
{
    *<span class="literal">result</span> +=  (process-&gt;storage)[i];
}
</code></pre><p> 这就是循环展开中的<strong>2次循环展开</strong>，同样还有n次循环展开。</p>
<p> 同样，在刚才提到过寄存器的使用以及减少不必要的开销，在此程序中对于<code>(process-&gt;storage)[i]</code>这样的存储器位置解引用太过浪费，我们总是将其优化成本低临时变量的使用</p>
<pre><code><span class="typedef"><span class="keyword">data</span>* local_data = process-&gt;storage;</span>
</code></pre><p> 这将为程序带来十分可观的节约，虽然这些工作在编译器的优化中都能包括，但是一旦我们的代码难以被编译器所理解(虽然编译器的升级最大的目的就是提升优化效果)，那么我们很可能得到一个性能不够可观的程序。所以当我们并不是特别紧凑的时候，可以将这些工作当成我们的本分来做，而不是交给编译器来做。</p>
<p> 以及对于外部存储位置 <code>result</code> 我们在此处也是存在着浪费，同样我们应该使用一个临时变量来存储总和，而不是每次得到结果便对它进行解引用操作。</p>
<pre><code><span class="type">int</span> local_result = <span class="number">0</span>;
/*...*/
local_result = local_result + local_data[i] + local_data[i+<span class="number">1</span>];
/*...*/
*<span class="literal">result</span> = local_result;
</code></pre><p>在上方我们可以看见<strong>循环展开</strong>被称作<strong>2次循环展开</strong>，那么自然可以推断有<code>n</code>次循环展开，自然是有的，对于一个n次循环展开的式子我们有一个简便的上界确定公式即:</p>
<pre><code><span class="attribute">reality </span>=<span class="string"> len - n + 1;</span>
</code></pre><p>至于展开几次最好，依然是视环境而定。<br>故最终的版本应该为：</p>
<pre><code><span class="keyword">static</span> inline <span class="type">void</span> mix_cal(<span class="keyword">const</span> <span class="keyword">block</span>* process, <span class="type">int</span> <span class="literal">result</span>[])
{
    <span class="type">int</span> local_result = <span class="number">0</span>;
    <span class="type">int</span> len = get_len(process-&gt;storage);
    <span class="type">int</span> reality = len - <span class="number">1</span>, i;
    data* local_data = process-&gt;storage;

    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">2</span>)
        local_result += local_data[i] + local_data[i+<span class="number">1</span>];
    <span class="keyword">for</span>(;i &lt; len;++i)
        local_result += local_data[i];

    *<span class="literal">result</span> = local_result;
}
</code></pre><p>解释：循环展开将元素相加分为两个部分，第一部分每次加两个元素，由于如此做会剩余元素没有加，故在第二部分将剩下的元素都加起来。</p>
</li>
<li><p>.<br>还有一种叫做<strong>重新组合</strong>的技巧，即为让一个表达式中的运算数自由组合，组合出最快速的一种，但是这种方法未曾试验过。故不提及。</p>
</li>
<li><p>.<br>对于条件分支预测错误造成的时间损耗，称之为<strong>惩罚</strong>，最通俗的说法，就是当你编写的代码中含有条件分支的时候，处理器会选择去<strong>预判</strong>某一个分支是此次正确的支路，这样可以避免修改任何实际的寄存器和存储器，一直到确定了实际结果，要是不对，那就惨了，这段时间做的事情都白费了。但是也不必过分的关心这种条件分支的预测，这也是我放在最后说的意义所在。</p>
<p> 这里有两种较为客观的方法，一种被称为<strong>命令式</strong>，一种被称为<strong>功能式</strong></p>
<p> 命令式：</p>
<pre><code><span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{
    if(a[i] &gt; b[i]){
        int temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }</span>
}
</code></pre><p> 功能式：</p>
<pre><code>int min, max;
<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n;++i)
<span class="comment">{    
    min = a[i] &lt; b[i] ? a[i] : b[i];
    max = a[i] &lt; b[i] ? b[i] : a[i];
    a[i] = min;
    b[i] = max;
}</span>
</code></pre><p>很清晰的一个例子，明显看出来，前者对于不同情况所作的程序步数明显不同，而后者无论什么情况都是相同的程序步。</p>
<p> 两个形式的好处前者对于可预测数据来说，是一个很好的模型，后者则是中庸之道，什么是可预测不可预测，比如一个数是负数还是正数这就是不可预测的，用前面那个代码会有很大的<strong>惩罚</strong>。</p>
</li>
<li><p>.<br>多路并行的技巧也是一个很重要的思路，可能在很多人眼中看来，两条语句依次写出和合并的效果一定是一样。但是多路并行有一个缺点就是对寄存器的数量有所要求，当寄存器不够时(称为溢出)，性能不升反降。同样是对于循环展开，此次使用<strong>四次循环展开</strong>加<strong>二路并行</strong>：</p>
<pre><code><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; reality;i+=<span class="number">4</span>){
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i] + <span class="built_in">local</span>_data[i+<span class="number">1</span>];
    <span class="built_in">local</span>_result_2 += <span class="built_in">local</span>_data[i+<span class="number">2</span>] + <span class="built_in">local</span>_data[i+<span class="number">3</span>];
}//也可以分成四路并行，每一路存一个。这种做法充分利用了CPU流水线的性能
<span class="keyword">for</span>(;i &lt; len;++i)
    <span class="built_in">local</span>_result_1 += <span class="built_in">local</span>_data[i];

*result = <span class="built_in">local</span>_result_1 + <span class="built_in">local</span>_result_2;
</code></pre></li>
</ol>
<h4 id="结束">结束</h4><h4 id="Tips:">Tips:</h4><p>上文中写到的函数大都带有<code>static inline</code>关键字，这是何意？首先我们要确定一件事情，对于非工程的单文件而言，<code>static</code>函数并没有什么意义(意义指的是对于可见性而言，并非说它一无是处)，许多人对于<code>static</code>函数感到茫然的原因在于:我明明将一个函数声明定义成<code>static</code>类型了，但是我还是可以在别的文件中访问到啊！</p>
<p>其实这是因为你根本就没有理解<strong>C语言</strong>工程这个意思，大部分人是这么测试的:</p>
<ol>
<li><p>首先在一个文件夹里创建两个文件 <code>test_static.c</code>和<code>static.h</code>:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> "static.h"</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//编译通过，可以运行。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
<li><p>然后编译运行，发现可以通过啊！！标准怎么说在其他文件中不可见？而把<code>static.h</code>去掉<code>#include</code>之后发现报错<code>test undefined</code>，瞬间初学者就凌乱了。</p>
</li>
<li><p>好吧，实际上是前辈们以及教材的错，因为从始至终，所有外界现象都告诉我们<strong>C程序</strong>是独立的一个一个文件组成的，但是并没有告诉我们要先将他们弄成一个工程！此处如果是使用<strong>Visual Studio</strong>学习C语言的可能会对工程这个概念理解的稍微好一些，虽然极度反对排斥使用 VS 学习C语言这种行为。</p>
</li>
<li><p>你想要实现<code>static</code>函数仅在本文件可见的效果，请你先补习一下<strong>工程</strong>这个概念，对于任何可见或者不可见的概念而言都是建立在一个工程内而言，而不是像上方的代码，使用<code>#include</code>来表示，你都<code>#include</code>了，那还有什么可见不可见的当然都可见了。所以一个<code>static</code>函数可见于不可见是基于一个个工程里的所有C语言源文件而言的。所以你将常看见前辈们这么回答你的提问:</p>
<pre><code><span class="comment">/*static.h*/</span>
<span class="preprocessor">#ifndef STATIC_H</span>
<span class="preprocessor">#<span class="keyword">define</span> STATIC_H</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
{
    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p> …</p>
<pre><code><span class="comment">/*test_static.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    test();         <span class="comment">//报错，因为test是static函数。</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>发现了吗？在上方代码中，少了一行<code>#include &quot;static.h&quot;</code>但是这个代码依旧可行，因为这两个文件是建立在同一个工程里的，而不是在一个文件夹中随意新建两个源文件这么简单，你可以使用各个<strong>IDE</strong>的工程功能来进行测试。</p>
</li>
</ol>
<p>回到正题，在这里稍微提一下<strong>static</strong>对函数的某些作用，它可以让函数放在一个静态的空间中，而不是栈里，这是的它的调用更加快速，经常与<strong>inline</strong>关键字一起使用，为的就是让函数更加快。但是有利有弊，可以自己权衡一下。</p>
<h4 id="参考:深入理解计算机系统—Randal_E-Bryant_/_David_O’Hallaro">参考:<a href="http://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统—Randal E.Bryant / David O’Hallaro</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0x07-C语言效率(上)">0x07-C语言效率(上)</h4><h4 id="更新于_2015-05-23">更新于 2015-05-23</h4><p>大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。 </p>
<p>对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离<strong>电子</strong>的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。</p>
<p>对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。</p>
<p>提高程序的速度，就C语言而言可以有这几种方法:</p>
<ul>
<li>首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候</li>
<li>要避免连续的函数调用。</li>
<li>消除不必要的<strong>存储器</strong>使用(并非推荐使用register)</li>
<li>使用<strong>循环展开</strong>技巧，一般编译器的优化选项能自动帮你修改代码成循环展开</li>
<li>对于一个操作的核心耗时部分，通过重新组合技术来提高速度</li>
<li>多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可视化Qt信号与槽]]></title>
    <link href="//wushxin.top/2015/05/19/%E5%8F%AF%E8%A7%86%E5%8C%96Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html"/>
    <id>//wushxin.top/2015/05/19/可视化Qt信号与槽.html</id>
    <published>2015-05-19T01:38:38.000Z</published>
    <updated>2015-06-12T12:52:32.538Z</updated>
    <content type="html"><![CDATA[<h2 id="Qt5_中的信号与槽">Qt5 中的信号与槽</h2><p>对于已经有了IDE的Qt而言，我们拥有更多的建立<strong>信号-槽</strong>方法的选择，但是作为一名自然人类，我们最喜欢的还是眼见为实，既然Qt为我们设计了 <strong>Qt Creator</strong>，那么我们就应该充分利用它，然而国内的教程大都停留在非可视化操作下，这里记录在 <strong>Qt Creator</strong> 下我们该如何设计一个<strong>信号-槽</strong>机制</p>
<h4 id="准备工作">准备工作</h4><p>打开<strong>Qt Creator</strong>，创建<strong>Qt Gui</strong>项目，我使用的是Qt5，但是同样也适用于Qt4，两者的在本次中的区别就在于建立连接<code>(QObject::connect)</code>的时候，Qt5更加灵活。</p>
<p>项目是<code>MainWindow</code>类，建立完成之后， <strong>Qt Creator</strong> 自动生成一系列文件</p>
<ol>
<li>打开<code>mainwindow.h</code>头文件，进行添加测试函数 <code>void test();</code></li>
<li><p>首先包含以下测试使用的头文件<code>&lt;QDebug&gt; &lt;QMessageBox&gt;</code><br>该函数原型需要首先加在<code>private:</code>下，作为私有成员函数。</p>
</li>
<li><p>其次打开<code>mainwindow.cpp</code>文件，进行测试函数的定义:</p>
<pre><code><span class="tag">void</span> <span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">test</span>()
{
    <span class="function">qDebug</span>() &lt;&lt; <span class="string">"Test Successful!"</span></span></span>;
    <span class="rule"><span class="attribute">QMessageBox</span>:<span class="value">:<span class="function">information</span>(this, <span class="function">tr</span>(<span class="string">"Tip"</span>), <span class="function">tr</span>(<span class="string">"Test"</span>))</span></span>;
}
</code></pre></li>
<li>上方的系列操作，<code>2</code>这个功能在Qt5下成功，Qt4需要在标签<code>public slots:</code>下放置该函数声明。<code>3</code>这个操作中定义了<code>test()</code>的函数体，其中<code>qDebug()</code>是在终端调试的时候使用的一个函数，我们使用它来在 <strong>应用程序输出</strong> 窗口显示是否成功。<code>QMessageBox::information(...)</code>则是用来显示一个窗口，也用来显示是否成功。</li>
</ol>
<h4 id="方法1">方法1</h4><ol>
<li><p>双击<code>.ui</code>文件，进入<strong>Qt Designer</strong>，至于不懂这个的也无所谓，只是个叫法而已，只需要知道如何在这个界面操作即可。</p>
<a id="more"></a>  
<ul>
<li>这时候我们为了演示，拖动添加一个<code>Push Button</code>按钮进窗口，这时候发现主界面上多了一个 <strong>PushButton</strong>，这时候看到你的右下方，有一个<strong>属性</strong>窗口，有过设计经验的都很熟悉，</li>
<li><code>objectName</code>代表的是在代码中这个控件的名字，记好它，当然你也可以修改它</li>
<li><code>QAbstractButton</code>下的<code>text</code>代表的是，你的程序运行起来以后该控件在你面前显示出来的名字。</li>
<li><code>statusTip</code>代表的是，当你鼠标移动到这个控件上时，在整个窗口中的下部有一块区域 <strong>Status Bar</strong> ，在此处显示你在其中填写的信息</li>
<li><code>shortcut</code>顾名思义就是快捷键的意思，但是此处快捷键使用<strong>Qt Designer</strong>设置有一个不太好的地方便是，无法很好的跨平台支持，如Mac OS下是<code>Command</code>代替了很多Windows下的<code>Ctrl</code>操作，使用代码则可以调用Qt所配置好的API。</li>
<li>以上几个是常用的几个属性。</li>
</ul>
</li>
<li><p>做完<strong>PushButton</strong>的准备工作之后，<code>objectName</code>为<strong>Button_1</strong></p>
<ul>
<li>由于<strong>Qt Designer</strong>只支持Qt的内置槽函数的建立连接，但是我们可以想办法让它变为可行，右键主窗体，选择 <strong>改变信号/槽</strong>，在出现的窗口中的槽里，点击加号，在其中输入刚才预先做好的测试函数<code>test()</code>，点击<code>OK</code>即可</li>
<li>这时候我们在下方找到一个窗口<code>Signals &amp; Slots Editor</code>,如果没有可以仔细找找，或者上网查询如何打开它，在此处我们可以很轻松的使用Qt中的信号与槽的连接，点击加号，出现一个新的记录，记录中包含 <strong><code>发送者(sender), 信号(signal), 接收者(receiver), 槽(slot)</code></strong> 犹如字面意思</li>
<li>在其中发送者选择<strong>Button_1</strong>，信号选择<strong>triggered</strong>，接收者选择<strong>MainWindow</strong>，槽选择<strong>open()</strong></li>
</ul>
</li>
<li><p>这样做完就行，这时候只需要保证<code>main.cpp</code>中包含有如下代码</p>
<pre><code>MainWindow win_1<span class="comment">;</span>
win_1.<span class="literal">show</span>()<span class="comment">;</span>
</code></pre><p> 就行，这时候编译运行，OK，你想要的效果就出来啦</p>
<ul>
<li>这就是全程的可视化操作，省去了一部份精力<h4 id="方法2">方法2</h4></li>
</ul>
</li>
<li><p>步骤1与上方的方法1一致，直到</p>
</li>
<li><p>在此处我们记下了<strong>PushButton</strong>的<code>objectName</code>之后，在<code>mainwindow.cpp</code>文件的类构造函数的定义中，修改代码，以代码形式得到我们上面使用可视化操作的效果，在这一步，往往有人会卡住，总是发现，明明关联没有错误，但是总是提示错误: <strong>QObject connect invaild null parameter</strong>，这是为什么？我们看一下<code>mainweindow.cpp</code>的构造函数的原始状态</p>
<pre><code><span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">MainWindow</span>(QWidget *parent) :
    <span class="function">QMainWindow</span>(parent),
    <span class="function">ui</span>(new Ui::MainWindow)
{
    ui-&gt;<span class="function">setupUi</span>(this)</span></span>;
}
</code></pre><p> 其中最后一句代码是将<strong>Qt Designer</strong>中的实现自动转化为代码，如果你在这句代码之前使用使用<code>QObject::connect</code>那么会导致，无法找到刚才创建的控件对象。所以我们只需要把<code>connect</code>放在后面即可。</p>
<pre><code>ui-&gt;setupUi(<span class="keyword">this</span>);
QObject::connect(ui-&gt;pushButton, &amp;QPushButton::click, 
                <span class="keyword">this</span>, <span class="keyword">this</span>-&gt;open);
</code></pre><p> 在此处<code>QObject::connect</code>可以简写为<code>connect</code>,因为此刻我们正处于<code>MainWindow::MainWindow</code>这个对象的作用域当中。</p>
</li>
<li>最后也是保证<code>main.cpp</code>的代码即可。</li>
</ol>
<h4 id="对于可视化">对于可视化</h4><p>虽然<strong>Qt Creator</strong>给予了我们极大的便利，但是在实际的复杂功能实现中，个人感觉还是需要代码操作占到主体，而界面设计毕竟只是一小部分，虽然Qt这个框架十分之大，但是其命名却是非常的人性化，常见的几个属性:</p>
<pre><code>ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setText(tr(<span class="string">"button_name_you_want"</span>));
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setStatusTip(tr(<span class="string">""</span>));
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setShortcut(QKeySequence<span class="tag">::shortcut_you_want</span>);
ui<span class="subst">-&gt;</span>button_name<span class="subst">-&gt;</span>setIcon(QIcon(<span class="string">":/adressofpicture"</span>));
<span class="attribute">...</span>
</code></pre><p>如此看，基本只要是属性的函数命名都是以<code>set...</code>开头，每个成员函数都能很清楚的看出功能。</p>
<p>并且其中大部分都是以<code>QString</code>为类型参数，即<code>tr(&quot;...&quot;)</code>代表的就是将<strong>C风格字符串</strong>转为<code>QString</code>类型。</p>
<p>而某些特殊的则需要记住，例如<code>QKeySequence::...</code>代表的是由Qt自带的快捷键API,使用它能更好的适应跨平台的问题。<code>QKeySequence::Open</code>在Windows下默认为<strong>Ctrl+O</strong>,Mac下为<strong>Command+O</strong></p>
<h4 id="最后的最后感谢_Haavard_Nord_和_Eirik_Chambe-Eng_为我们无私贡献了这么强大的Qt开源库">最后的最后感谢 Haavard Nord 和 Eirik Chambe-Eng 为我们无私贡献了这么强大的Qt开源库</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Qt5_中的信号与槽">Qt5 中的信号与槽</h2><p>对于已经有了IDE的Qt而言，我们拥有更多的建立<strong>信号-槽</strong>方法的选择，但是作为一名自然人类，我们最喜欢的还是眼见为实，既然Qt为我们设计了 <strong>Qt Creator</strong>，那么我们就应该充分利用它，然而国内的教程大都停留在非可视化操作下，这里记录在 <strong>Qt Creator</strong> 下我们该如何设计一个<strong>信号-槽</strong>机制</p>
<h4 id="准备工作">准备工作</h4><p>打开<strong>Qt Creator</strong>，创建<strong>Qt Gui</strong>项目，我使用的是Qt5，但是同样也适用于Qt4，两者的在本次中的区别就在于建立连接<code>(QObject::connect)</code>的时候，Qt5更加灵活。</p>
<p>项目是<code>MainWindow</code>类，建立完成之后， <strong>Qt Creator</strong> 自动生成一系列文件</p>
<ol>
<li>打开<code>mainwindow.h</code>头文件，进行添加测试函数 <code>void test();</code></li>
<li><p>首先包含以下测试使用的头文件<code>&lt;QDebug&gt; &lt;QMessageBox&gt;</code><br>该函数原型需要首先加在<code>private:</code>下，作为私有成员函数。</p>
</li>
<li><p>其次打开<code>mainwindow.cpp</code>文件，进行测试函数的定义:</p>
<pre><code><span class="tag">void</span> <span class="rule"><span class="attribute">MainWindow</span>:<span class="value">:<span class="function">test</span>()
{
    <span class="function">qDebug</span>() &lt;&lt; <span class="string">"Test Successful!"</span></span></span>;
    <span class="rule"><span class="attribute">QMessageBox</span>:<span class="value">:<span class="function">information</span>(this, <span class="function">tr</span>(<span class="string">"Tip"</span>), <span class="function">tr</span>(<span class="string">"Test"</span>))</span></span>;
}
</code></pre></li>
<li>上方的系列操作，<code>2</code>这个功能在Qt5下成功，Qt4需要在标签<code>public slots:</code>下放置该函数声明。<code>3</code>这个操作中定义了<code>test()</code>的函数体，其中<code>qDebug()</code>是在终端调试的时候使用的一个函数，我们使用它来在 <strong>应用程序输出</strong> 窗口显示是否成功。<code>QMessageBox::information(...)</code>则是用来显示一个窗口，也用来显示是否成功。</li>
</ol>
<h4 id="方法1">方法1</h4><ol>
<li><p>双击<code>.ui</code>文件，进入<strong>Qt Designer</strong>，至于不懂这个的也无所谓，只是个叫法而已，只需要知道如何在这个界面操作即可。</p>]]>
    
    </summary>
    
      <category term="Qt" scheme="//wushxin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(3)---预处理器]]></title>
    <link href="//wushxin.top/2015/05/13/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(3).html"/>
    <id>//wushxin.top/2015/05/13/我为什么学C(3).html</id>
    <published>2015-05-13T09:17:49.000Z</published>
    <updated>2015-06-03T11:50:20.405Z</updated>
    <content type="html"><![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x06-C语言预处理器">0x06-C语言预处理器</h4><p><strong>预处理最大的标志便是大写，虽然这不是标准，但请你在使用的时候大写，为了自己，也为了后人。</strong></p>
<p>预处理器在一般看来，用得最多的还是宏，这里总结一下预处理器的用法。</p>
<pre><code><span class="id">#include</span> &lt;stdio.h&gt;
<span class="hexcolor">#def</span>ine MACRO_OF_MINE
<span class="id">#ifdef</span> MACRO_OF_MINE
<span class="id">#else</span>
#endif
</code></pre><p>上述五个预处理是最常看见的，第一个代表着包含一个头文件，可以理解为没有它很多功能都无法使用，例如C语言并没有把输入输入纳入标准当中，而是使用库函数来提供，所以只有包含了<code>stdio.h</code>这个头文件，我们才能使用那些输入输出函数。<br><code>#define</code>则是使用频率第二高的预处理机制，广泛用在常量的定义，只不过它和<code>const</code>声明的常量有所所区别:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MAR_VA 100</span>
<span class="keyword">const</span> <span class="keyword">int</span> Con_va = <span class="number">100</span>;
...
<span class="comment">/*定义两个数组*/</span>
...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
{
    mar_arr[i] = MAR_VA;
    con_arr[i] = Con_va;
}
</code></pre><ul>
<li>区别1,定义上<code>MAR_VA</code>可以用于数组维数，而<code>Con_va</code>则不行</li>
<li>区别2,在使用时，MAR_VA的原理是在文中找到所有使用本身的地方，用值替代，也就是说<code>Con_va</code>将只有一分真迹，而<code>MAR_VA</code>则会有<code>n</code>份真迹(n为使用的次数)<br>剩下三个则是在保护头文件中使用颇多。<a id="more"></a></li>
</ul>
<p>几个比较实用的用于调试的宏,由C语言自带</p>
<ul>
<li><code>__LINE__和__FILE__</code><br>用于显示当前行号和当前文件名</li>
<li><code>__DATA__和__TIME__</code><br>用于显示当前的日期和时间</li>
<li><code>__func__</code><strong>(C99)</strong><br>用于显示当前所在外层函数的名字</li>
</ul>
<p><em>上述所说的五种宏直接当成值来使用即可。</em></p>
<ul>
<li><p><code>__STDC__</code></p>
<ul>
<li><p>如果你想检验你现在使用的编译器是否遵循ISO标准，用它，如果是他的值为1。</p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, __STDC_<span class="number">_</span>);
</code></pre><p><code>输出: 1</code></p>
</li>
<li><p>如果你想进一步确定编译器使用的标准版本是C99还是C89可以使用<code>__STDC__VERSION__</code>，C99(199901) </p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, __STDC_VERSION_<span class="number">_</span>);
</code></pre><p><code>输出: 199901</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="对于#define">对于<code>#define</code></h5><ol>
<li><p>预处理器一般只对同一行定义有效，但如果加上反斜杠，也能一直读取下去</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">err</span><span class="params">(flag)</span></span> \
    <span class="function"><span class="title">if</span><span class="params">(flag)</span></span> \
      <span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Correctly"</span>)</span></span>
</code></pre><p>可以看出来，并没有在末尾添加<code>;</code>，并不是因为宏不需要，而是因为，我们总是将宏近似当成函数在使用，而函数调用之后总是需要以<code>;</code>结尾，为了不造成混乱，于是在宏定义中我们默认不添加<code>;</code>，而在代码源文件中使用，防止定义混乱。</p>
</li>
<li><p>预处理同样能够带来一些便利</p>
<pre><code><span class="title">#define SWAP1</span><span class="comment">(a, b)</span> <span class="comment">(a += b, b = a - b, a -= b)</span>
<span class="title">#define SWAP2</span><span class="comment">(x, y)</span> {x ^= y; y ^= x; x ^= y}
</code></pre><p>引用之前的例子，交换两数的宏写法可以有效避免函数开销，由于其是直接在调用处展开代码块，故其比拟直接嵌入的代码。但，偶尔还是会出现一些不和谐的错误，对于初学者来说:</p>
<pre><code>int v1 = <span class="number">10</span><span class="comment">;</span>
int v2 = <span class="number">20</span><span class="comment">;</span>
SWAP1<span class="list">(<span class="keyword">v1</span>, v2)</span><span class="comment">;</span>
SWAP2<span class="list">(<span class="keyword">v1</span>, v2)</span><span class="comment">;//报错</span>
</code></pre><p>对于上述代码块的情况，为什么<code>SWAP2</code>报错？对于一般的初学者来说，经常忽略诸如<code>，</code> <code>goto</code> <code>do...while</code>等少见关键字用法，故很少见<code>SWAP1</code>的写法，大多集中于<code>SWAP2</code>的类似错误，错就错在<code>{}</code>代表的是一个代码块，不需要使用<code>;</code>来进行结尾，这便是宏最容易出错的地方<br><strong>宏只是简单的将代码展开，而不会做任何处理</strong><br>对于此，即便是老手也常有失足，有一种应用于单片机等地方的C语言写法可以在此借鉴用于保护代码:</p>
<pre><code><span class="title">#define SWAP3</span><span class="comment">(x ,y)</span> <span class="keyword">do</span>{ \
        x ^= y; y ^= x; x ^= y; \
        }<span class="keyword">while</span><span class="comment">(0)</span>
</code></pre><p>如此便能在代码中安全使用花括号内的代码了，并且如之前所约定的那样，让宏的使用看起来像函数。</p>
</li>
<li><p>但正所谓，假的总是假的，即使宏多么像函数，它依旧不是函数，如果真的把它当成函数，你会在某些时候错的摸不着头脑,还是一个经典的例子，比较大小:</p>
<pre><code><span class="comment">#define CMP(x, y) (x &gt; y ? x : y)</span>
...
<span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;
<span class="type">int</span> <span class="literal">result</span> = <span class="type">CMP</span>(x, y++);
printf(<span class="string">"x = %d, y = %d, result = %d\n"</span>, x, y, <span class="literal">result</span>);
</code></pre><p>执行这部分代码，会输出什么呢？<br>答案是，<strong>不知道！</strong>至少<code>result</code>的值我们无法确定，我们将代码展开得到</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = (x &gt; y++ ? x : y++);
</code></pre><p>看起来似乎就是<code>y</code>递增两次，最后<code>result</code>肯定是<code>200</code>。真是如此？C语言标准对于一个确定的程序语句中，一个对象只能被修改一次，超过一次那么结果是未定的，由编译器决定，除了三目操作符<code>?:</code>外，还有<code>&amp;&amp;</code>, <code>||</code>或是<code>,</code>之中，或者函数参数调用，<code>switch控制表达式，for里的控制语句</code><br>由此可看出，宏的使用也是有风险的，所以虽然宏强大，但是依旧不能滥用。</p>
</li>
<li><p>对于宏而言，前面说过，它只是进行简单的展开，这有时候也会带来一些问题:</p>
<pre><code><span class="comment">#define MULTI(x, y) (x * y)</span>
...
<span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;
<span class="type">int</span> <span class="literal">result</span> = <span class="type">MULTI</span>(x+y, y);
</code></pre><p>看出来问题了吧？展开之后会变成:<br><code>int result = x+y * y;</code><br>完全违背了当初我们设计时的想法，一个比较好的修改方法是对每个参数加上括号:<br><code>#define MULTI(x, y) ((x) * (y))</code>如此，展开以后:</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = ((x+y) * (y));
</code></pre><p>这样能在很大程度上解决一部分问题。</p>
</li>
<li><p>如果对自己的宏十分自信，可以嵌套宏，即一个表达式中使用宏作为宏的参数，但是宏只展开这一级的宏，对于多级宏另有办法展开</p>
<pre><code><span class="type">int</span> <span class="literal">result</span> = <span class="type">MULTI</span>(<span class="type">MULTI</span>(x, y), y);
</code></pre><p>展开成:<code>int result = ((((x) * (y))) * (y));</code></p>
</li>
</ol>
<h5 id="对宏的应用">对宏的应用</h5><ol>
<li><p>由于我们并不明白，在某些情况下宏是否被定义了，<strong>(NULL宏是一个例外，它可以被重复定义)</strong>，所以我们可以使用一些预处理保护机制来防止错误发生</p>
<pre><code><span class="id">#ifndef</span> MY_MACRO
<span class="hexcolor">#def</span>ine MY_MACRO <span class="number">10000</span>
#endif
</code></pre><p>如果定义了<code>MY_MACRO</code>那就不执行下面的语句，如果没定义那就执行。</p>
</li>
<li><p>在宏的使用中有两个有用的操作符，姑且叫它操作符<code>#</code>, <code>##</code></p>
<ul>
<li><p>对于<code>#</code><br>我们可以认为<code>#</code>操作符的作用是将宏参数转化为字符串。</p>
<pre><code><span class="variable">#define</span> HCMP(x, y) printf(<span class="variable">#x</span><span class="string">" is equal to"</span> <span class="variable">#y</span><span class="string">" ? %d\n"</span>, (x) <span class="subst">==</span> (y))
<span class="attribute">...</span>
int x <span class="subst">=</span> <span class="number">100</span>, y <span class="subst">=</span> <span class="number">200</span>;
HCMP(x, y);
</code></pre><p>展开以后</p>
<pre><code>printf<span class="list">(<span class="string">"x is equal to y ? %d\n"</span>, <span class="list">(<span class="number">100</span>)</span> == <span class="list">(<span class="number">200</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>总结起来，即将宏参数放于<code>#</code>操作符之后便由预处理器自动转换为字符串常量，转义也由预处理器自动完成，而不需要我们自行添加转义符号。</p>
</li>
<li><p>对于<code>##</code><br>它实现的是将本操作符两边的参数合并成为一个完整的标记，但需要注意的是，由于预处理器只负责展开，所以程序员必须自己保证这种标记的合法性，这里涉及到一些写法问题，都列出来</p>
<pre><code><span class="comment">#define MERGE(x, y) have_define_ ## (x + y)</span>
<span class="comment">#define MERGE(x, y) have_define_##(x + y)</span>
...
<span class="literal">result</span> = <span class="type">MERGE</span>(<span class="number">1</span>, <span class="number">3</span>);
</code></pre><p>这里首先说明，上述写法由于习惯原因，我使用第二种，但是无论哪种都无伤大雅，效果一样。上述代码展开以后是什么呢？</p>
<pre><code><span class="literal">result</span> = have_define_1 + <span class="number">3</span>;
</code></pre><p>在我看来，这就有点<code>C++</code>中模版的思想了，虽然十分原始，但是总是有了一个方向，凭借这种方法我们能够使用宏来进行相似却不同函数的调用，虽然我们可以使用函数指针数组来存储，但需要提前知晓有几个函数，并且如果要实现动态增长还需要消耗内存分配，但宏则不同。</p>
<pre><code><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_0</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 + arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_1</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 - arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_2</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 * arg_2; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func_3</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">int</span> arg_2)</span> </span>{ <span class="keyword">return</span> arg_1 / arg_2; }
<span class="preprocessor">#<span class="keyword">define</span> CALL(x, arg1, arg2) func_##x(arg1, arg2)</span>
...
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">0</span> ,CALL(<span class="number">0</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">1</span> ,CALL(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">2</span> ,CALL(<span class="number">2</span>, <span class="number">2</span>, <span class="number">10</span>));
    <span class="built_in">printf</span>(<span class="string">"func_%d return %d\n"</span>,<span class="number">3</span> ,CALL(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>));
</code></pre><p>十分简便的一种用法，在我们增加减少函数时我们不必考虑如何找到这些函数只需要记下每个函数对应的编号即可，但还是那句话，不可滥用。</p>
<pre><code><span class="comment">#define CAT(temp, i) (cat##i)</span>
//...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)
{
    <span class="keyword">int</span> CAT(<span class="keyword">x</span>,i) = i*i;
    <span class="keyword">printf</span>(<span class="string">"x<span class="variable">%d</span> = <span class="variable">%d</span> \n"</span>,i,CAT(<span class="keyword">x</span>,i));
}
</code></pre></li>
</ul>
</li>
<li><p>对于宏，在使用时一定要注意，宏只能展开当前层的宏，如果你嵌套使用宏，即将宏当作宏的参数，那么将导致宏无法完全展开，即作为参数的宏只能传递名字给外部宏</p>
<pre><code>#define WHERE(value_name, line) #value_name <span class="preprocessor">#line</span>
...
puts(WHERE(x, <span class="keyword">__LINE__</span>)); <span class="comment">//x = 11</span>
</code></pre><p><code>输出: 11__LINE__</code></p>
</li>
<li><p>对于其他的预编译器指令，如:<code>#program, #line, #error</code>和各类条件编译并不在此涉及，因为使用上并未有陷阱及难点。</p>
</li>
</ol>
<h4 id="Create_By_WuShengxin_@_2015">Create By WuShengxin @ 2015</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x06-C语言预处理器">0x06-C语言预处理器</h4><p><strong>预处理最大的标志便是大写，虽然这不是标准，但请你在使用的时候大写，为了自己，也为了后人。</strong></p>
<p>预处理器在一般看来，用得最多的还是宏，这里总结一下预处理器的用法。</p>
<pre><code><span class="id">#include</span> &lt;stdio.h&gt;
<span class="hexcolor">#def</span>ine MACRO_OF_MINE
<span class="id">#ifdef</span> MACRO_OF_MINE
<span class="id">#else</span>
#endif
</code></pre><p>上述五个预处理是最常看见的，第一个代表着包含一个头文件，可以理解为没有它很多功能都无法使用，例如C语言并没有把输入输入纳入标准当中，而是使用库函数来提供，所以只有包含了<code>stdio.h</code>这个头文件，我们才能使用那些输入输出函数。<br><code>#define</code>则是使用频率第二高的预处理机制，广泛用在常量的定义，只不过它和<code>const</code>声明的常量有所所区别:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MAR_VA 100</span>
<span class="keyword">const</span> <span class="keyword">int</span> Con_va = <span class="number">100</span>;
...
<span class="comment">/*定义两个数组*/</span>
...
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
{
    mar_arr[i] = MAR_VA;
    con_arr[i] = Con_va;
}
</code></pre><ul>
<li>区别1,定义上<code>MAR_VA</code>可以用于数组维数，而<code>Con_va</code>则不行</li>
<li>区别2,在使用时，MAR_VA的原理是在文中找到所有使用本身的地方，用值替代，也就是说<code>Con_va</code>将只有一分真迹，而<code>MAR_VA</code>则会有<code>n</code>份真迹(n为使用的次数)<br>剩下三个则是在保护头文件中使用颇多。]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(2)---指针]]></title>
    <link href="//wushxin.top/2015/05/13/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(2).html"/>
    <id>//wushxin.top/2015/05/13/我为什么学C(2).html</id>
    <published>2015-05-13T04:17:12.000Z</published>
    <updated>2015-08-21T11:23:15.794Z</updated>
    <content type="html"><![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x05-C语言指针:(Volume-1)">0x05-C语言指针:(Volume-1)</h4><p>这似乎是一个很凝重的话题，但是它真的很有趣。</p>
<p><strong><em>1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的</em></strong></p>
<p><strong><em>2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及<code>sizeof</code></em></strong></p>
<p><strong><em>3. C语言最晦涩难明的就是它复杂的声明: `void (</em>signal(int sig, void (<em>func)(int)))(int)`,试试着把它改写成容易理解的形式</em></strong></p>
<p><strong><em>4. 对于指针，尽最大的限度使用<code>const</code>保护它，无论是传递给函数，还是自己使用</em></strong></p>
<p>先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: <code>NULL</code>，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):</p>
<pre><code><span class="hexcolor">#def</span>ine NULL <span class="number">0</span>
<span class="hexcolor">#def</span>ine NULL ((void*)<span class="number">0</span>)
</code></pre><p>有什么区别吗？看起来没什么区别都是<code>0</code>，只不过一个是常量，一个是地址为0的指针。</p>
<p>当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:</p>
<pre><code><span class="keyword">int</span>* temp_int_1 = <span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_2 = (<span class="keyword">void</span>*)<span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_3 = <span class="number">10</span>; <span class="comment">//出现警告</span>
</code></pre><p>为什么？为什么<code>0</code>可以赋值给指针，但是<code>10</code>却不行？他们都是常量。</p>
<p>因为C语言规定当处理上下文的编译器发现常量<code>0</code>出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。</p>
<p>回到最开始，对于<code>NULL</code>的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。</p>
<p>在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加<code>&#39;\0&#39;</code>，好这里又出现了一个0值。</p>
<p>对于某些人，在使用字符数组的时候总是分不清楚<code>NULL</code>与<code>&#39;\0&#39;</code>的区别而误用，在字符数组的末尾使用<code>NULL</code>是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。</p>
<h5 id="开胃菜已过">开胃菜已过</h5><p>对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参</p>
<pre><code>int <span class="function"><span class="keyword">function</span><span class="params">(int value)</span>
</span>{
        <span class="comment">/*...*/</span>
}
<span class="comment">//...</span>
<span class="function"><span class="keyword">function</span><span class="params">(11)</span></span>;
</code></pre><p>其中，<code>value</code>是形参，<code>11</code>是实参，我们知道场面上，C语言拥有两种传递方式:<strong>按值传递</strong>和<strong>按址传递</strong>，但是你是否有认真研究过？这里给出一个实质，其实C语言只有<strong>按值传递</strong>，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。<br><a id="more"></a></p>
<p>对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数</p>
<pre><code>void swap_v1(int<span class="keyword">*</span> val_1, int<span class="keyword">*</span> val_2)
{
    int temp = <span class="keyword">*</span>val_1;
    <span class="keyword">*</span>val_1 = <span class="keyword">*</span>val_2;
    <span class="keyword">*</span>val_2 = <span class="keyword">*</span>val_1;
}
</code></pre><p>这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参<code>val_1</code>与<code>val_2</code>，实际上我们使用:</p>
<pre><code><span class="title">#define SWAP_V2</span><span class="comment">(a, b)</span> <span class="comment">(a += b, b = a - b, a -= b)</span>
<span class="title">#define SWAP_V3</span><span class="comment">(x, y)</span> {x ^= y; y ^= x; x ^= y}
</code></pre><p>试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。</p>
<p>但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？</p>
<pre><code>...
int <span class="built_in">test</span>_1 = <span class="number">10</span>, <span class="built_in">test</span>_2 = <span class="number">100</span>;
SWAP_V2(&amp;<span class="built_in">test</span>_1, &amp;<span class="built_in">test</span>_2);                    
<span class="built_in">printf</span>(<span class="string">"Now the test_1 is %d, test_2 is %d\n"</span>, <span class="built_in">test</span>_1, <span class="built_in">test</span>_2);
.../*恢复原值*/
SWAP_V2(&amp;<span class="built_in">test</span>_1, &amp;<span class="built_in">test</span>_1);
<span class="built_in">printf</span>(<span class="string">"Now the test_1 is %d\n"</span>, <span class="built_in">test</span>_1);   
</code></pre><p>会输出什么？:</p>
<pre><code>$: <span class="built_in">Now</span> the test_1 <span class="keyword">is</span> <span class="number">100</span>, test_2 <span class="keyword">is</span> <span class="number">10</span>
$: <span class="built_in">Now</span> the test_1 <span class="keyword">is</span> <span class="number">0</span>
</code></pre><p>对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的<code>SWAP_V3</code>亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap_final</span><span class="params">(<span class="keyword">int</span>* val_1, <span class="keyword">int</span>* val_2)</span>
</span>{
    <span class="keyword">if</span>(val_1 == val_2)
        <span class="keyword">return</span>;
    *val_1 ^= *val_2;
    *val_2 ^= *val_1;
    *val_1 ^= *val_2;
}
</code></pre><p>这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。<br>提示：可用<code>void*</code></p>
<p>与上面的情况类似，偶尔的不经意就会造成严重的后果:</p>
<pre><code><span class="built_in">int</span> combine_1(<span class="built_in">int</span>* dest, <span class="built_in">int</span>* <span class="built_in">add</span>)
{
    *dest += *<span class="built_in">add</span>;
    *dest += *<span class="built_in">add</span>;
    <span class="keyword">return</span> *dest;
}
<span class="built_in">int</span> combine_2(<span class="built_in">int</span>* dest, <span class="built_in">int</span>* <span class="built_in">add</span>)
{
    *dest = <span class="number">2</span>* (*<span class="built_in">add</span>);<span class="comment">//在不确定优先级时用括号是一个明智的选择</span>
    <span class="keyword">return</span> *dest;
}
</code></pre><p>上述两个函数的功能一样吗？恩看起来是一样的</p>
<pre><code>int <span class="built_in">test</span>_3 = <span class="number">10</span>, <span class="built_in">test</span>_4 = <span class="number">100</span>;

combine_1(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_4);
<span class="built_in">printf</span>(<span class="string">"After combine_1, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
.../*恢复原值*/
combine_2(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_4);
<span class="built_in">printf</span>(<span class="string">"After combine_2, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
</code></pre><p>输出</p>
<p><code>$: After combine_1, test_3 = 210</code></p>
<p><code>$: After combine_2, test_3 = 210</code></p>
<p>如果两数相等呢？</p>
<pre><code>... /*恢复<span class="built_in">test</span>_3原值*/
combine_1(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_3);
<span class="built_in">printf</span>(<span class="string">"After second times combine_1, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
...
combine_2(&amp;<span class="built_in">test</span>_3, &amp;<span class="built_in">test</span>_3);
<span class="built_in">printf</span>(<span class="string">"After second times combine_2, test_3 = %d\n"</span>,<span class="built_in">test</span>_3);
</code></pre><p>输出</p>
<p><code>$: After second times combine_1, test_3 = 30</code></p>
<p><code>$: After second times combine_2, test_3 = 20</code></p>
<p>知道真相总是令人吃惊，指针也是那么令人又爱又恨。</p>
<ul>
<li><strong>C99</strong> 标准之后出现了一个新的关键字， <code>restrict</code>，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 <strong>你自己</strong> 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何<ul>
<li>首先这个关键字是写给编译器看的</li>
<li>其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)</li>
<li>最后，如果不熟悉，还是不要乱用。</li>
</ul>
</li>
</ul>
<h5 id="关于数组的那些事">关于数组的那些事</h5><p>数组和指针一样吗？</p>
<p><strong>不一样</strong></p>
<p>要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？</p>
<pre><code><span class="keyword">int</span> arr[<span class="number">10</span>] = {<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>};
<span class="keyword">int</span>* parr  = arr;
</code></pre><p>我们还是那句话，结合上下文，编译器推出 ‘arr’处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用’arr’时也总是将其当成是指向该数组内存块首位的指针。</p>
<pre><code>//int <span class="keyword">function</span>2(const int <span class="built_in">test</span>_arr[<span class="number">10</span>]
//int <span class="keyword">function</span>2(const int <span class="built_in">test</span>_arr[]) 考虑这三种写法是否一样
int <span class="keyword">function</span>2(const int* <span class="built_in">test</span>_arr)
{
    <span class="built_in">return</span> sizeof(<span class="built_in">test</span>_arr);
}
...
int size_out = sizeof(arr);
int size_<span class="keyword">in</span>  = <span class="keyword">function</span>2(arr);

<span class="built_in">printf</span>(<span class="string">"size_out = %d, size_in = %d\n"</span>, size_out, size_<span class="keyword">in</span>);
</code></pre><p><code>输出: size_out = 40, size_in = 8</code></p>
<p>这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而<code>arr</code>代表的是一个<strong>指向10个int类型的数组</strong>的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写</p>
<pre><code><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;arr;
</code></pre><p>此时<code>p</code>的类型就是一个<strong>指向含有10个元素的数组的指针</strong>,此时<code>(*p)[0]</code>产生的效果是<code>arr[0]</code>，也就是<code>parr[0]</code>，但是<code>(*p)</code>呢？这里不记录，结果是会溢出，为什么？</p>
<p>这就是数组与指针的区别与联系，但是既然我们可以使用像<code>parr</code>这样的指针，又为什么要写成<code>int (*p)[10]</code>这样丑陋不堪的模式呢？原因如下:</p>
<ul>
<li><p>回到最开始说过的传递方式，按值传递在传递<code>arr</code>时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个<strong>指向数组的指针</strong><br>这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同</p>
<pre><code><span class="keyword">int</span> arr_2[<span class="number">5</span>];
<span class="keyword">int</span> (*p_2)[<span class="number">5</span>] = &amp;arr_2;
<span class="keyword">float</span> arr_3[<span class="number">5</span>];
<span class="keyword">float</span> (*p_3)[<span class="number">5</span>] = &amp;arr_3;
</code></pre><p>如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。</p>
</li>
<li><p>这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。</p>
<ul>
<li><p>就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:</p>
<p>  <code>int dou_arr[5][3];</code><br>就这个二维数组而言，将5个每个为3个<code>int</code>类型的数组组合在一起，要想指向这个数组该怎么做？</p>
<pre><code><span class="atom">int</span> (*<span class="atom">p</span>)[<span class="number">3</span>]        = &amp;<span class="atom">dou_arr</span>[<span class="number">0</span>];
<span class="atom">int</span> (*<span class="atom">dou_p</span>)[<span class="number">5</span>][<span class="number">3</span>] = &amp;<span class="atom">dou_arr</span>;
<span class="atom">int</span> (*<span class="atom">what_p</span>)[<span class="number">3</span>]   = <span class="atom">dou_arr</span>;
</code></pre><p>实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制<br>对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 <strong>指向该数组元素的类型</strong>，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。</p>
</li>
</ul>
</li>
</ul>
<p>对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:</p>
<pre><code><span class="keyword">int</span>* arr_3[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
<span class="keyword">int</span>* p_4      = arr_3;

<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> == <span class="variable">%d</span> == <span class="variable">%d</span> ?\n"</span>, arr_3[<span class="number">2</span>], *(p_4 + <span class="number">2</span>), *(arr_3 + <span class="number">2</span>));
</code></pre><p><code>输出: 3 == 3 == 3 ?</code><br>实际上对于数组与指针而言， <code>[]</code>操作在大多数情况下都能有相同的结果，对于指针而言<code>*(p_4 + 2)</code>相当于<code>p_4[2]</code>，也就是说<code>[]</code>便是指针运算的语法糖，有意思的是<code>2[p_4]</code>也相当于<code>p_4[2]</code>，<code>&quot;Iamastring&quot;[2] == &#39;m&#39;</code>，但这只是娱乐而已，实际中请不要这么做，除非是<strong>代码混乱大赛</strong>或者某些特殊用途。<br><strong>在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于<code>[]</code>运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道</strong></p>
<p>在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用<code>char*</code>指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。</p>
<p>实际上，最简单的安全研究之一，便是利用溢出进行攻击。</p>
<p><strong>Advance:</strong>对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。</p>
<h4 id="0x05-C语言指针(Volume-2)">0x05-C语言指针(Volume-2)</h4><h5 id="内存的使用的那些事儿">内存的使用的那些事儿</h5><p>你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以<strong>共享</strong>使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的<strong>硬盘</strong>上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:</p>
<pre><code>...
<span class="keyword">int</span>  stay_here;
<span class="keyword">char</span> tran_to_int[<span class="number">100</span>];
<span class="built_in">printf</span>(<span class="string">"Address: %p\n"</span>, &amp;stay_here);

fgets(tran_to_int, <span class="keyword">sizeof</span>(tran_to_int), stdin);
<span class="built_in">sscanf</span>(tran_to_int, <span class="string">"%d"</span>, &amp;stay_here);

<span class="keyword">for</span>(;;)
{
    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, stay_here);
    getchar();
    ++stay_here;
}
...
</code></pre><p>对此程序(引用<a href="http://kmaebashi.com" target="_blank" rel="external">前桥和弥</a>的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的<code>stay_here</code>都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:</p>
<ul>
<li><p>通俗地说，fgets将输入流中由调用起，<code>stdin</code>输入的东西存入起始地址为<code>tran_to_int</code>的地方，并且最多读取<code>sizeof(tran_to_int)</code>个，并在后方<code>sscanf</code>函数中将刚才读入的数据按照<code>%d</code>的格式存入<code>stay_here</code>，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于<code>scanf</code>的问题</p>
<pre><code>scanf<span class="list">(<span class="string">"%d"</span>, <span class="keyword">&amp;stay_here</span>)</span><span class="comment">;</span>
</code></pre><p>这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是<strong>回车</strong>会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。</p>
</li>
</ul>
<h5 id="函数与函数指针的那些事">函数与函数指针的那些事</h5><p>事实上，函数名出现在赋值符号右边就代表着函数的地址</p>
<pre><code><span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int argc)</span></span>{ /*...*/
}
...
<span class="built_in">int</span> (*p_fun)(<span class="built_in">int</span>) = <span class="function"><span class="keyword">function</span></span>;
<span class="built_in">int</span> (*p_fuc)(<span class="built_in">int</span>) = &amp;<span class="function"><span class="keyword">function</span></span>;//和上一句意义一致
</code></pre><p>上述代码即声明并初始化了函数指针，<code>p_fun</code>的类型是<strong>指向一个返回值是int类型，参数是int类型的函数的指针</strong></p>
<pre><code>p_fun<span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
<span class="list">(<span class="keyword">*p_fun</span>)</span><span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
function<span class="list">(<span class="number">11</span>)</span><span class="comment">;</span>
</code></pre><p>上述三个代码的意义也相同，同样我们也能使用<strong>函数指针数组</strong>这个概念</p>
<pre><code><span class="keyword">int</span> (*p_func_arr[])(<span class="keyword">int</span>) = {func1, func2,};
</code></pre><p>其中<code>func1,func2</code>都是返回值为<code>int</code>参数为<code>int</code>的函数，接着我们能像数组索引一样使用这个函数了。</p>
<p><strong>Tips:</strong> 我们总是忽略函数声明，这并不是什么好事。</p>
<ul>
<li>在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(<strong>inline</strong>)，因为它本身就只在本文件可用。</li>
<li><p>比如，当我们在某个地方调用了一个函数，但是并没有声明它：</p>
<pre><code>CallWithoutDeclare<span class="comment">(100)</span>; <span class="comment">//参数100为 int 型</span>
</code></pre><p>那么，C编译器就会推测，这个使用了<code>int</code>型参数的函数，一定是有一个<code>int</code>型的参数列表，一旦<strong>函数定义</strong>中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。</p>
</li>
<li>对函数指针的调用同样如此</li>
</ul>
<h5 id="C语言中malloc的那些事儿">C语言中malloc的那些事儿</h5><p>我们常常见到这种写法:</p>
<pre><code>int* pointer = <span class="list">(<span class="keyword">int*</span>)</span>malloc<span class="list">(<span class="keyword">sizeof</span><span class="list">(<span class="keyword">int</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>这有什么奇怪的吗？看下面这个例子:</p>
<pre><code><span class="keyword">int</span>* pointer_2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
</code></pre><p>哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， <code>void*</code> 这个类型还没有出现的时候，<code>malloc</code> 返回的是 <code>char*</code> 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 <code>void*</code> 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。</p>
<p><strong>题外话:</strong> C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。</p>
<p><strong>Tips:</strong></p>
<ul>
<li>C语言的三个函数<code>malloc</code>, <code>calloc</code>, <code>realloc</code>都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行<strong>再包装</strong>，可以选择宏包装，也可以选择函数包装。</li>
<li><code>realloc</code>函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用<strong>再包装</strong>阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。</li>
</ul>
<h5 id="指针与结构体">指针与结构体</h5><pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> tag{
        <span class="keyword">int</span>  value;
        <span class="keyword">long</span> vari_store[<span class="number">1</span>];
}vari_struct;
</code></pre><p>乍一看，似乎是一个很中规中矩的结构体</p>
<pre><code>...
vari_struct  vari_1;
vari_struct* vari_p_1 = &amp;vari_1;
vari_struct* vari_p_2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vari_struct))(
</code></pre><p>似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法</p>
<pre><code><span class="keyword">int</span>          what_spa_want = <span class="number">10</span>;
vari_struct* vari_p_3 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vari_struct) + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*what_spa_want);
</code></pre><p>这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。<code>what_spa_want</code>解释为<strong>你需要多大的空间</strong>，即在一个结构体大小之外还需要多少的空间，空间用来存储<code>long</code>类型，由于分配的内存是连续的，故可以直接使用数组<code>vari_store</code>直接索引。<br>而且由于C语言中，编译器并不对数组做越界检查，故对于一个有<code>N</code>个数的数组<code>arr</code>，表达式<code>&amp;arr[N]</code>是被标准允许的行为，但是要记住<code>arr[N]</code>却是非法的。<br>这种用法并非是娱乐，而是成为了标准(<strong>C99</strong>)的一部分，运用到了实际中</p>
<h5 id="对于内存的理解">对于内存的理解</h5><p>在内存分配的过程中，我们使用 <code>malloc</code> 进行分配，用 <code>free</code> 进行释放，但这是我们理解中的分配与释放吗？<br>在调用 <code>malloc</code> 时，该函数或使用 <code>brk()</code> 或使用 <code>nmap()</code> 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 <code>free</code>，与我们硬盘删除东西一样，实际上:</p>
<pre><code><span class="keyword">int</span>* value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">5</span>);
...
<span class="built_in">free</span>(value);
<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, value[<span class="number">0</span>]);
</code></pre><p>代码中，为什么在 <code>free</code> 之后，我又继续使用这个内存呢？因为 <code>free</code> 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。<br>这便引申出几个问题:</p>
<ul>
<li>Bug更加难以发现，让我们假设，如果我们有两个指针<code>p1</code>,<code>p2</code>指向同一个内存，如果我们对其中某一个指针使用了 <code>free(p1);</code> 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。</li>
<li>有可能会让某些问题更加简化，例如释放一个条条相连的链表域。</li>
</ul>
<p>总的来说，还是那句话C语言是一把双刃剑。</p>
<h4 id="Create_By_WuShengXin_@_2015">Create By WuShengXin @ 2015</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本章更新于_2015-05-16">本章更新于 2015-05-16</h2><h4 id="0x05-C语言指针:(Volume-1)">0x05-C语言指针:(Volume-1)</h4><p>这似乎是一个很凝重的话题，但是它真的很有趣。</p>
<p><strong><em>1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的</em></strong></p>
<p><strong><em>2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及<code>sizeof</code></em></strong></p>
<p><strong><em>3. C语言最晦涩难明的就是它复杂的声明: `void (</em>signal(int sig, void (<em>func)(int)))(int)`,试试着把它改写成容易理解的形式</em></strong></p>
<p><strong><em>4. 对于指针，尽最大的限度使用<code>const</code>保护它，无论是传递给函数，还是自己使用</em></strong></p>
<p>先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: <code>NULL</code>，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):</p>
<pre><code><span class="hexcolor">#def</span>ine NULL <span class="number">0</span>
<span class="hexcolor">#def</span>ine NULL ((void*)<span class="number">0</span>)
</code></pre><p>有什么区别吗？看起来没什么区别都是<code>0</code>，只不过一个是常量，一个是地址为0的指针。</p>
<p>当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:</p>
<pre><code><span class="keyword">int</span>* temp_int_1 = <span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_2 = (<span class="keyword">void</span>*)<span class="number">0</span>; <span class="comment">//无警告</span>
<span class="keyword">int</span>* temp_int_3 = <span class="number">10</span>; <span class="comment">//出现警告</span>
</code></pre><p>为什么？为什么<code>0</code>可以赋值给指针，但是<code>10</code>却不行？他们都是常量。</p>
<p>因为C语言规定当处理上下文的编译器发现常量<code>0</code>出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。</p>
<p>回到最开始，对于<code>NULL</code>的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。</p>
<p>在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加<code>&#39;\0&#39;</code>，好这里又出现了一个0值。</p>
<p>对于某些人，在使用字符数组的时候总是分不清楚<code>NULL</code>与<code>&#39;\0&#39;</code>的区别而误用，在字符数组的末尾使用<code>NULL</code>是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。</p>
<h5 id="开胃菜已过">开胃菜已过</h5><p>对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参</p>
<pre><code>int <span class="function"><span class="keyword">function</span><span class="params">(int value)</span>
</span>{
        <span class="comment">/*...*/</span>
}
<span class="comment">//...</span>
<span class="function"><span class="keyword">function</span><span class="params">(11)</span></span>;
</code></pre><p>其中，<code>value</code>是形参，<code>11</code>是实参，我们知道场面上，C语言拥有两种传递方式:<strong>按值传递</strong>和<strong>按址传递</strong>，但是你是否有认真研究过？这里给出一个实质，其实C语言只有<strong>按值传递</strong>，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。<br>]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么学C(1)---开篇]]></title>
    <link href="//wushxin.top/2015/05/12/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6C(1).html"/>
    <id>//wushxin.top/2015/05/12/我为什么学C(1).html</id>
    <published>2015-05-12T14:22:23.000Z</published>
    <updated>2015-06-22T01:33:14.181Z</updated>
    <content type="html"><![CDATA[<h1 id="我的C语言">我的C语言</h1><h2 id="本章更新于_2015/6/21_11:36:01">本章更新于 2015/6/21 11:36:01</h2><p><strong>正式接触编程，大概是一年连六个月吧，这真是一个令人着迷的领域</strong></p>
<h4 id="0x00-C语言前续工作">0x00-C语言前续工作</h4><p>正所谓，工欲善其事，必先利其器，把握住当下最强大的工具，能让我们在学习的道路上少走许多弯路，多吸取前人的失败经验，能让自己快速成长，因为成长总是在消耗我们的耐心以及生命。</p>
<p>入门或者精通或者应用，不管哪一方面，对于一个编程语言而言，最方便的还是使用一个<strong>IDE</strong>作为你的有力助手，什么事<strong>IDE</strong>？通俗而专业的说叫做<strong>集成开发环境</strong>，这个通过字面就能理解到了，就是所有其他的事情都不需要程序员操心，你需要操心的就是写出代码，至于代码完成之后的一系列工作，都不需要你来管，IDE一键帮你搞定。</p>
<p>当然，会有许多前辈告诉你，如果你想理解C语言，那你一定要使用最基层的东西来写，比如XXX编辑器配上XXX编译器，晕头转向之后更加茫然，本来就支离破碎的小心肝，又被粉碎了一次，撇开那些与当下不符合的幻想，活在现实中，选择一个适合你的<strong>IDE</strong>，逐渐适应它。</p>
<ul>
<li><p>讲几个著名的<strong>IDE</strong>，并给出建议，利器第一步：</p>
<ol>
<li><p>宇宙级的<strong>IDE</strong>: Visual Studio(2010~2015)，之所以说宇宙级，因为这是市面上最强大的集成开发环境，由微软公司出品，但是放在开头不是为了推荐他，而是为了警示大家不要使用它作为C语言的集成开发环境，因为它使用的是微软公司自己定制的C++编译器，也就是说，你的C语言代码会在C++的标准下编译运行，这就是一个十分不好的现象，即便是C++我依旧不喜欢使用Visual Studio，因为它的C++编译器总是和普通的标准有所出入。</p>
<p> 原归正传，Visual Studio的确不是一个好的C语言开发IDE，所以请另外选择一个。</p>
</li>
<li><p>老牌<strong>IDE</strong>: DevC++，这又是一个大家耳熟能详，经常能在老师手里看见的C语言教学利器，但是，它是C++的IDE，记住C于C++完全是两个世界的人，虽然C++宣称能全面兼容C程序，但是有些东西依旧是有所区别，体现在语法的兼容性上，后文会有提及。那为什么大学老师喜欢使用它呢？因为一本由清华大学出版社出版的《数据结构》，让无数人为之折服，其中赫然写着由于性能我们不能拘泥于小细节，故对于C++的特性<code>&amp;</code>引用，我们可以将其使用在C语言的语法中，就是这句话，让无数无知的学子扑向其中，再也分不清C与C++，看成谭浩强之后的，清华大学出版社又一诲人不倦的力作。</p>
<p> 所以，真爱编程，远离清华大学出版社，也请大家注意，不要使用DevC++这个IDE进行C语言程序的开发以及练习。</p>
</li>
<li><p>知名<strong>IDE</strong>: Code::Blocks，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是首推的C语言开发环境选择。</p>
</li>
<li><p>知名<strong>IDE</strong>: CodeLite，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是次推的C语言开发环境选择，因为使用起来稍微也有些额外的工作要做。</p>
</li>
<li><p>著名<strong>IDE</strong>: Xcode，是一个苹果电脑上的史诗级集成开发环境，虽然脱胎于C语言，但是由于某些原因，并不太建议使用其作为C语言的开发环境。 </p>
</li>
</ol>
</li>
<li><p>IDE的基本配置<br>利器第二步是对所选的IDE进行一些基本的配置，以及小科普。</p>
<ol>
<li><p>对于一个练习C语言的开发环境来说，选择合适的标准和编译器是很重要的，在Windows以及Linux操作系统下，我们还是使用<code>GCC</code>这个家伙比较多，开源，免费，且极其强大。当然你也可以选择<code>clang</code>，当然整个计算机领域中支持C语言的编译器并不止这两个，只不过这两个是开源免费，而且功能强大，十分适合作为个人开发以及无特殊需求的企业开发的选择。</p>
<p> 选择了编译器，我们开始讲标准：</p>
<p> 对于<code>GCC 5.1</code>以下的所有版本，都默认对C语言使用<code>C89</code>标准，但是我建议使用<code>C99</code>两者的差距，有一个极其明显的地方，便是<code>for</code>循环的使用</p>
<pre><code><span class="comment">/*C89:*/</span>
<span class="keyword">int</span> i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
<span class="comment">/*...*/</span>
</code></pre><p>…</p>
<pre><code><span class="comment">/*C99*/</span>
for<span class="comment">(int i = 0;i &lt; 10;++i)</span>
<span class="comment">/*...*/</span>
</code></pre><p> 这只是其中的一种差别，但是C99需要人为手动的开启，但是很多人有疑问，为什么有时候没有配置什么也能使用后面的语法？吴老师告诉你，这是因为你用了C++的文件进行C语言的开发，就像挂羊皮卖狗肉的道理。</p>
</li>
<li><p>开启C99</p>
<p>一般IDE的顶部都是一系列的标签，找到<code>工具/设置</code>，因为不同的IDE可能有不同的标签，总之在其中找到一个叫<strong>(编译器)Compiler</strong>之后，在其中的<strong>other option</strong>中加入以下:<code>-std=c99</code>，这便是开启C99的选项代码，完事之后保存即可。虽然说我们是中国人，但是毕竟这东西的外国人发明的，我们能看英文就看英文吧。</p>
</li>
</ol>
<ul>
<li><p>至此，利器成功配置。</p>
</li>
<li><p>当然最重要的还是内在，所以加油吧，虽然是一门很古老的语言，但是存在既有其道理。</p>
</li>
</ul>
</li>
</ul>
<h4 id="0x01-C语言序言">0x01-C语言序言</h4><p> 倒是觉得写代码首先不是语法，而是格式，任何时候任何地点，要是自己的代码难以理解，要么你是故意的，要么你就是菜菜</p>
<p> 一个难以被人理解的代码在我看来是没有太多的潜力的，但不排除故意为之的情况,也许很多人说这是强迫症，但是无论打开哪一个开源代码，你看到的都将是一个拥有规范的代码文件</p>
<p>也许有人说人不应该被限制，不应该拘泥于小节，但是当一个工程超过一千行，也许不用只需要不到五百行，就能完全暴露出代码规范的重要性，包括缩进，变量命名，接口存放，接口参数的规范之类，听起来似乎很虚<a href="https://code.google.com/p/google-styleguide/" target="_blank" rel="external">谷歌代码规范(翻墙后查看)</a></p>
<p>在我看来C语言的内建语法真是无比简洁，几乎存在既有道理，简洁不代表着不强大，强大的某些地方在近来渐渐复苏的Lisp身上也有体现。</p>
<p><code>if, for, while, switch</code></p>
<p></p><p>组成了每个C程序的半壁江山<br><br><code> “ + “ “ - “ “ * “ “ / “ “ % “ “ = “</code></p>
<p></p><p>组成了各式各样的算法计数<br><br><code>“&gt;&gt;” “&lt;&lt;” “|” “&amp;” “^” “~” “!”</code></p>
<p></p><p>让C语言有了更高效的算法以及更奇妙的思路<br><br><code>struct enum union #define return</code><br></p>
<p></p><p>而这些则让C语言在这乱世纷争中站稳了脚跟，并且一枝独秀<br><br><code>“{}” “()”</code><br></p>
<p></p><p>让代码不再无序混乱<br><br><code>“type * “ “&amp;” “()” “-&gt;”</code><br></p>
<p></p><p>让C语言在这个世界无处不在<br><code>“ . “ “[ ]” “ &lt; “ “ &gt; “ “ == “</code><br></p>
<a id="more"></a>
<p><strong>还记得他们吗？我想这一辈子都忘不了了</strong></p>
<h4 id="0x02-编程带给我的">0x02-编程带给我的</h4><p>是快乐而不是痛苦，如果你觉得编程痛苦，请放下你手头的工作，找找自己真正想要的，无论从什么角度来看，你都应该放弃令你痛苦的事情，花上三杯茶的时间，看看自己的心到底喜欢什么。</p>
<p>C语言可谓是让一个程序员最难以感受到自己进步的编程语言，一个黑窗口就让无数程序员再也走不出来。或者迷失，或者停滞不前，或者放弃，一个人最恐惧无助，甚至彷徨的时候，就是在努力之后却感受不到自己在进步，努力的白费是所有人不愿意看到的，但是太多人就着所谓前途而奋不顾身的投入这个事业，他们也许对计算机完全没有喜爱之心，埋头苦干，世人皆称<strong>爱读书的好孩子</strong>，但是这意义又在何处？即使最后你领着你觉得高的工资，站在了同学，朋友的前方，依然发现自己并没有得到满足，在我看来，让自己开心的才是最好的，不适合你的永远是最差的，即便能带来利益？何不花三杯茶的时间，想想自己到底适合何处。</p>
<p>在C语言的道路上，囊括了许多道天堑，并不是说这门语言比其他语言难，相反它十分符合人类的思维逻辑，但就是因为它存在的时间太久远，普通的使用于它于世界已经无甚大用，在现在这个高级语言遍地走的时代里，有用的只是那些将C语言发挥到极限的工程，不再是小窗口中写一个数据结构，一个算法，也许你觉得徒手写出一棵<strong>红黑树</strong>很了不起了？那也就是做成一个字典树，在一个浩大的工程中，一个虽重要却不起眼的小部分罢了，学完所有语法，却不知所措接下去该怎么做？有心人在无尽的探索之后发觉，啊！标准库！啊算法！嗯对了，还有各种各样的第三方扩展，以后呢？啊！操作系统！然而自学的路上充满着坎坷，艰辛，无助，烦恼，那又如何？喜欢就好。</p>
<p>所谓师傅领进门，修行在个人，这句话在我看来有两个重要点，却是现在大学生几乎缺失的。<strong>师傅</strong>一词告诉我们，要不耻下问，要善于询问，而不是伸手即来思想，”提问的智慧”在我看来是一门很重要的课程，特别是在当今信息时代。而更重要的是，先入为主的思想是极其可怕的，在这两年的自学历程里，见过太多后来者居上的事迹，当你一直认为自己一定比后辈强时，你就注定输了，所以不耻下问才是最重要的。但是如果师傅是那么容易找到的，那就不会有学校了，<strong>个人</strong>指的并不是孤军奋战，而是要善于自己发现问题，努力解决问题，这个过程可能少不了请教他人</p>
<p>编程可以是一种信仰，至少在我认为是这样的，把它当作信仰的人，它就能给你快乐，给你充实，当然也不要忘了现实，虽然现实中总是少不了加班的羁绊，但是如果是真心喜爱编程，又怎么会被这些困难所打败？但是C语言真的不是一门容易精通的语言。</p>
<h4 id="0x03-C代码">0x03-C代码</h4><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"That is Right Style\n"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>在一个标准的C语言程序中，最特殊的莫过于main函数了，而说到底它就是一个函数而已，仅仅因为它地位特殊拥有第一执行权力，换句话说，难道因为一个人是省长它就不是人类了？所以函数该有的它都应该有，那么函数还有什么呢？</p>
<p>函数大体上分为<a href="http://www.greenend.org.uk/rjk/tech/inline.html" target="_blank" rel="external">内联函数(C99)</a><strong>(内联函数并非C++专属，C语言亦有，具体见前方链接)</strong>和非内联的普通函数，它们之间有一个很明显的特点(一般情况下)，那就是不写原型直接在main函数上方定义，即使不加’inline’关键字，也能被编译器默认为内联函数，但之后带来的某些并发问题就不是编译器考虑的了。</p>
<p>普通函数正确的形式应该为声明与定义分离，声明就是一个函数原型，函数原型应该有一个函数名字，一个参数列表，一个返回值类型和一个分号。定义就是函数的内在，花括号内的就是函数的定义:</p>
<pre><code><span class="comment">//...</span>
<span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">float</span> arg_2)</span></span>;
<span class="comment">//...</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>
</span>{
  <span class="keyword">int</span> output = function(<span class="number">11</span>, <span class="number">22.0</span>);
  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,output);
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">float</span> arg_2)</span>
</span>{
 <span class="keyword">int</span>    return_value  = arg_1;
 <span class="keyword">float</span>  temp_float    = arg_2;
 <span class="keyword">return</span> return_value;
}    
</code></pre><p>依上所述，当非必要时，在自己编写函数的时候请注意在开头(main函数之前)写上你的函数的原型，并且在末尾(<code>main</code>函数之后)写上你的函数定义，这是一个很好的习惯以及规范。所谓代码整洁之道，就是如此。</p>
<p>函数的另一种分类是，有返回值和无返回值，返回值的类型可以是内建<strong>(build-in)</strong>的也可以是自己定义的(<code>struct, union</code>之类)，无返回值则是<code>void</code>。</p>
<ol>
<li>为什么我们十分谴责<code>void main()</code>这种写法？因为这完全是中国式教育延伸出来的谭式写法，<strong>main函数</strong>的返回值看似无用，实际上是由操作系统接收，在Windows操作系统下也许无甚”大碍”(实际上有),当你使用Linux的过程中你会清晰的发现一个C语言程序的<strong>main返回值</strong>关系到一个系统是否能正常，高效的运行，这里稍微提一句，<code>0</code>在Linux程序管道通信间代表着无错可行的意思。所以请扔掉<code>void main</code>这种写法。</li>
<li><p>为什么我们对 <code>main()</code>这种省略返回值的写法置有微词？能发明这种写法的人，必定是了解了，在C语言中，如果一个函数不显式声明自己的返回值，那么会被缺省认为是<code>int</code>，但这一步是由编译器掌控，然而C语言设计之初便是让我们对一切尽可能的掌握，而一切不确定因子我们都不应该让它存在。其次有一个原则，能自己做的就不要让编译器做。</p>
</li>
<li><p>为什么我们对参数放空置有不满(int main())?在C语言中，一个函数的参数列表有三种合法形态:<br></p>
<pre><code><span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(void)</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int arg_n)</span></span>;
<span class="built_in">int</span> <span class="function"><span class="keyword">function</span><span class="params">(int arg_n, ...)</span></span>;
</code></pre><p> 第一种代表拥有未知个参数,第二种代表没有参数，第三种代表有一个参数，第四种代表拥有未知个参数，并且第一个参数类型为int,未知参数在C语言中有一个解决方案就是，可变长的参数列表，具体参考C标准库，在此我们解释的依据就是，我们要将一切都掌控在自己的手中，我们不在括号内填写参数，代表着我们认为一开始的意思是它为空，正因此我们就应该明确说明它为void,而不该让它成为一个未知参数长度的函数，如此在你不小心传入参数的时候，编译器也无法发现错误。</p>
</li>
<li><p><code>int main(int argc, char* argv[])</code> 和 <code>int main(void)</code>才是我们该写的C语言标准形式<br><br>对于缩进，除了编译器提供的符号缩进之外，我们可以自己给自己一个规范(请少用或者不用Tab)，比如每一块代码相教上一个代码块有4格的缩进。<br><br>对于学习C语言，请使用.c文件以及C语言编译器练习以及编写C程序，请不要再使用C++的文件编写C语言程序，并且自圆其说为了效率而使用C++的特性在C语言中，我们是祖国的下一代，是祖国的未来，请不要让自己毁在当下，珍爱编程，远离清华大学出版社</p>
<p> 之所以如此叙述，并不是因为情绪，而是当真如此，下方代码:</p>
<pre><code><span class="comment">/*file: test.c*/</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> SIZES 5</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">int</span>* c_pointer = <span class="built_in">malloc</span>(SIZES * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="comment">/*发生了一些事情*/</span>
    <span class="built_in">free</span>(c_pointer);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p> 这是一段标准的C语言程序，但是它能在C++个编译器下编译运行吗？换句话说当你将文件扩展名由<code>.c</code>改为<code>.cpp</code>之后，它能编译通过吗？答案是不能。</p>
<p> 为什么？答案是C++并不支持<code>void*</code>隐式转换为其他类型的指针，但是C语言允许。还有许许多多C于C++不相同的地方，兴许有人说C++是C的超集，但我并不这么认为，一门语言的出现便有它的意义所在，关键在于我们如何发挥它的最大优势，而不是通过混淆概念来增强实用性</p>
</li>
<li><p>程序式子的写法</p>
<p> 一个人活在世界上，时时刻刻都注意着自己的言行举止，而写程序也是如此，对于一个规范的能让别人读懂的程序而言，我们应该尽可能减少阻碍因子，例如:</p>
<pre><code><span class="keyword">int</span> main(void)
{<span class="keyword">int</span> complex_int=<span class="number">100</span>;
<span class="keyword">int</span> i,j,k,<span class="keyword">x</span>;
<span class="keyword">for</span>(<span class="keyword">int</span> temp=<span class="number">0</span>;temp&lt;complex_int;++temp){k=temp;
<span class="keyword">x</span>=k+complex_int;}
<span class="keyword">printf</span>(complex_int=<span class="string">"<span class="variable">%d</span> is k=<span class="variable">%d</span> x=<span class="variable">%d</span>\n"</span>,complex_int,k,<span class="keyword">x</span>);
<span class="keyword">return</span> <span class="number">0</span>;}
</code></pre><p>对于上述的代码，我总是在班级里的同学手下出现，但这段代码除了让别人困惑以外，自己在调试的时候也是十分不方便，每每遇到问题了，即便IDE提示了在某处错误，你也找不到问题所在，经常有人来问我哪里错了，大部分情况都是少了分号，括号，或者作用域超过，原因在哪？</p>
<p> 要是一开始将代码写清楚了，这种情况简直是凤毛麟角，想遇上都难。对于一个代码而言，我们应该注意让其变得清晰。</p>
<ul>
<li><p>等号两边使用空格：</p>
<pre><code><span class="keyword">int</span> complex_int = <span class="number">100</span>;
</code></pre></li>
<li><p>使用多个变量的声明定义，或者函数声明定义，函数使用时，注意用空格分开变量：</p>
<pre><code><span class="keyword">int</span> i, j, k, x;<span class="comment">//但是十分不建议这么声明难以理解意义的变量</span>
<span class="built_in">printf</span>(<span class="string">"complex_int = %d is k = %d x = %d\n"</span>, complex_int, k, x);
<span class="function"><span class="keyword">void</span> <span class="title">present</span><span class="params">(<span class="keyword">int</span> arg_1, <span class="keyword">double</span> arg_2)</span></span>;
</code></pre></li>
<li><p>对于一个清晰的程序而言，我们要让每一个步骤清晰且有意义，这就要求我们在编写程序的时候尽量能让代码看起来结构化，或者整体化。尽量让每个程序式子为一行，如果有特别的需要让多个式子写在同一行，可以使用<code>,</code>操作符进行组合，但是会让程序更难理解，日后调试的时候也更难发现错误。</p>
<pre><code><span class="comment">/*Style 1*/</span>    
for(int <span class="variable">temp =</span> <span class="number">0</span>;temp &lt; complex_int;++temp)
{
    <span class="variable">k =</span> temp;
    <span class="variable">x =</span> k + complex_int;
}
<span class="comment">/*Style 2*/</span>
for(int <span class="variable">temp =</span> <span class="number">0</span>;temp &lt; complex_int;++temp){
    <span class="variable">k =</span> temp;
    <span class="variable">x =</span> k + complex_int;
}
</code></pre><p>对于上方的代码，是C语言代码花括号的两种风格，最好能选择其中一种作为自己的编程风格，这样能让你的程序看起来更加清晰，混合使用的利弊并不好说，关键还是看个人风格。</p>
</li>
<li><p>对于作用域而言，在C语言中有一个经常被使用的特例，当一个条件语句，或者循环只有一条语句的时候，我们常常省略了花括号<code>{}</code>，而是仅仅使用一个分号作为结尾，这在很多情况下让代码不再啰嗦：</p>
<pre><code><span class="keyword">if</span>(pointo_int == NULL)
    fprintf(stderr, <span class="string">"The pointer is NULL!\n"</span>);
<span class="keyword">else</span>
{
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>,*pointo_int);
    pointo_int = pointo_int-&gt;<span class="keyword">next</span>;
}
</code></pre><p>在这段代码中<code>if</code>语句下方的代码并没有使用<code>{}</code>运算符进行指明，但是根据语法，该语句的确是属于<code>if</code>语句的作用范围内，如果我们此时写上了<code>{}</code>反而会令代码看起来过于啰嗦。但是有的时候，这条特性并不是那么的有趣，当使用嵌套功能的时候，还是建议使用<code>{}</code>进行显式的范围规定，而不是使用默认的作用域：</p>
<pre><code>for<span class="comment">(int i = 0;i&lt; 10;++i)</span>
    for<span class="comment">(int k = 0;k &lt; 10;++k)</span>
        <span class="keyword">while</span><span class="comment">(flag != 1)</span>
            set_value<span class="comment">(arr[i][k])</span>;
</code></pre><p>这段代码，看起来十分简洁，但是确实是一个很大的隐患，当我们要调试这段代码的时候，总是需要修改它的构造，而这就带来了潜在的隐患。所以建议在使用嵌套的时候，无论什么情况，都能使用<code>{}</code>进行包装。</p>
</li>
</ul>
</li>
</ol>
<p><strong>综上所述，在开始编写一个标准C语言程序的时候，请先把下面这些东西写上:</strong><br></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>对于<code>main</code>的参数，有兴趣的可以查阅<a href="http://wrestlewsx.github.io/C++流操作(续)/" target="_blank" rel="external">我的文章</a>，或者自行谷歌，在此问题上百度也是可以的。</p>
<h4 id="0x04-C语言变量">0x04-C语言变量</h4><p>C语言在明面上将数的变量分为两类，<strong>整型变量</strong>以及<strong>浮点数</strong>，对应着现实世界的整数和小数。</p>
<ul>
<li><p>首先是整数，使用了这么多的C语言之后，每当在使用整数之时都会将其想象成二进制的存在，而不是十进制。原因在于，这是程序的本质所在，稍有研究编译器工作原理的都会发现，在编译器处理乘法乃至除法的时候，优秀的编译器总会想方设法的加快程序的速度，毫无疑问在所有运算中移位运算是最快速的”乘法”以及”除法”: <br><br><code>1&lt;&lt;2 == 4</code> ,<code>8&gt;&gt;2 == 2</code></p>
<p>  而正常一个乘法相当于十数次的加法运算的时间消耗，移位则不用<strong>(除法的消耗更大，但是随着CPU的进步，这些差距正在逐渐缩小，就目前来看依旧是有着不小的差距但无论如何优化，乘法时间都会大于加法)</strong>。正如前面所说，C语言设计之初便是给了程序员所有的权利，而程序员要做的就是掌控所有能掌控的，即便是数的计算亦是如此，比如在优秀的编译器看来:<br><br>  <code>2*7 ====&gt; (2&lt;&lt;3) - 2</code><br><br>  <code>5*31 ====&gt; (5&lt;&lt;5) - 5</code><br><br>  毫无疑问经过编译器优化后的代码此前者要快许多。这就是为什么我们要将一个数看作二进制，这不仅仅是表面，而是要在深层次的认为它是二进制，总体来说C语言的整型是非常简洁明了的总体分为 <em>有符号</em> 和 <em>无符号</em>，很好理解只需要注意不要让无符号数进行负数的运算，这里有一个原则，可以很好的规避这种无意之过，<strong>不把无符号类型变量和有符号类型变量放于同一运算中</strong>，时刻记得保持式子的类型一致是设计时的保障。</p>
</li>
<li><p>浮点数，由于实数域可以看作稠密的，故除了整数以外，还有无数的小数，而小数在计算机中如何表示？一种无限的状态是无法在计算机中被精确表示，所以有了浮点法，关于浮点法可以参考书籍<a href="http://www.amazon.cn/计算机科学丛书-深入理解计算机系统-布莱恩特/dp/B004BJ18KM" target="_blank" rel="external">《深入理解计算机系统》</a>。<br>这里介绍的是在C语言中我们应该如何正确使用浮点数？很多人(包括我)在初作之时总是想当然的以为计算机是无所不能的，连人类都无法完全表达出来的小数计算机一定可以，实际上并非如此，在这里我可以说，计算机只是近似表达，而最大的忌讳的便是将两个浮点数进行比较，此处介绍一种浮点数常用的比较方法，精确度法:</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> DISTANCE 0.00000001</span>
...
<span class="keyword">float</span> f_x_1 = <span class="number">20.5</span>;
<span class="keyword">float</span> f_x_2 = <span class="number">19.5</span>;
<span class="keyword">if</span>(f_x_1 - f_x_2 &lt; DISTANCE)
    <span class="built_in">printf</span>(<span class="string">"They are Equal\n"</span>);
<span class="keyword">else</span>
    <span class="built_in">printf</span>(<span class="string">"Different\n"</span>);
</code></pre><p>所以说，在很大程度上，当你在程序中使用了浮点数，又直接使用浮点数进行比较，却发现始终无法达到预期效果，那么你可以检查一下，是否是这个原因，在这一点上，不得不说是C语言的一个缺憾。<br></p>
</li>
<li><p>指针变量，是一种比较特别的变量，以至于总是对它进行特别对待。这里有几个原则:</p>
<ul>
<li>两个不相关的指针进行加减操作是无意义的</li>
<li>始终确保自己能够找到分配的内存</li>
<li>无论何时何地何种情况，都要记住，不使用未初始化的指针，不让未使用的内存持续存在。</li>
</ul>
<p>指针在不同位的操作系统上的大小是不一样的，但是在同一个操作系统下，无论什么类型的指针都是相同大小，这涉及到指针的寻址问题，<strong>(题外话:C语言的寻址实际上使用了汇编语言的间接寻址，有兴趣的可以自行尝试，方法之一，使用gcc编译器的汇编选项，产生汇编代码，进行一一比对)</strong>，对于寻址一个笼统一些的说法便是<br><br><code>4Byte = 32bit</code><br><br><code>2^32 = 4G</code><br><br>所以32位的操作系统下C语言指针:</p>
<pre><code>...
size_t what = <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);
<span class="built_in">printf</span>(<span class="string">"%d"</span>, what);
...
</code></pre><p>输出:<code>$root@mine: 4</code><br><br>对于大部分使用者来说，指针主要用来降低内存消耗以及提高运算效率的，这里设计许多学问，我也无法一一展示，比较有意思也常用的两个东西便是递增以及语法糖:<code>++, -&gt;</code></p>
<pre><code>...
<span class="keyword">int</span> dupli_of_me[<span class="number">10</span>] = {<span class="number">0</span>};<span class="comment">//也可以使用库函数memset()进行置0</span>
<span class="keyword">int</span> *point_to_me = dupli_of_me;
<span class="keyword">int</span> me = <span class="number">100</span>;
<span class="keyword">while</span>(point_to_me &lt; (dupli_of_me + <span class="number">10</span>))
    *point_to_me++ = me;
</code></pre><p>其中<code>*point_to_me++ = me;</code>在C语言应用广泛它相当于是:</p>
<pre><code>*point_to_me = <span class="keyword">me</span>;
point_to_me++;
</code></pre><p>的语法糖，对于<code>++</code>，在非必要的情况下，请使用前缀递增，而非后缀递增，原因是消耗问题，仔细想想这两种递增的区别在何处？<br>前缀递增总是在原数上进行递增操作，然而后缀递增呢？它首先拷贝一份原数放于别处，并且递增这份拷贝，在原数进行的操作完毕后，将这份拷贝再拷贝进原数取代它，此中的操作涉及的更多，<strong>所以在非必要的情况下，请使用前缀递增而不是后缀递增(递减也是同样的道理)</strong><br><br><code>-&gt;</code>则是在结构体上使用的非常广泛:</p>
<pre><code>typedef struct <span class="built_in">data</span>{
    int test;
    struct <span class="built_in">data</span><span class="subst">*</span> next;
}my_struct;
<span class="attribute">...</span>
my_struct temp;
my_struct <span class="subst">*</span>ptemp <span class="subst">=</span> <span class="subst">&amp;</span>temp;
ptemp<span class="subst">-&gt;</span>test <span class="subst">=</span> <span class="number">100</span>;
ptemp<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
<span class="keyword">if</span>(temp<span class="built_in">.</span>test <span class="subst">==</span> <span class="number">100</span>)
    printf(<span class="string">"Correctly!\n"</span>);
<span class="keyword">else</span>
    printf(<span class="string">"That is impossible!\n"</span>);
<span class="attribute">...</span>
</code></pre><p>可以很清楚的看出其实<code>ptemp-&gt;test</code>便是<code>(*ptemp).test</code>的语法糖</p>
</li>
<li><p>变量限定</p>
<p>  <code>const</code> 是最常用的变量限定符，它的意思是告诉编译器，这个变量或者对象在初始化以后不能被改变，常用它来保护一些必要的返回值，参数以及常量的定义。</p>
<p>  <code>volatile</code> 这个关键字常常被C语言教材所忽略，它很神秘。实际上确实如此，他的作用的确很神秘：一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗的说就是，<strong>告诉编译器，不要把你的那一套优化策略用在我身上</strong>。</p>
<pre><code><span class="comment">/* 此时我们将编译器优化等级提高到 -O2 */</span>
<span class="keyword">int</span>          test_num   = <span class="number">100</span>; <span class="comment">//测试一个迭代加法</span>
<span class="keyword">int</span>          nor_result = <span class="number">0</span>;
<span class="keyword">volatile</span> <span class="keyword">int</span> vol_result = <span class="number">0</span>;
<span class="comment">/* 测试无volatile限定下，该程序的耗时 */</span>            
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;++i)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10000</span>;++j)
            nor_result += test_num;
</code></pre><p>接下来就是测试<code>volatile</code>限定下的代码</p>
<pre><code><span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>;<span class="built_in">i</span> &lt; <span class="number">10000</span>;++<span class="built_in">i</span>)
    <span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="number">0</span>;<span class="built_in">j</span> &lt; <span class="number">10000</span>;++<span class="built_in">j</span>)
            vol_result += test_num;
</code></pre><p>在使用一些手段后，得到运行时间，可以很清晰的看出差别，在我的机器上，<code>i5-4CPU</code>，得到的结果是后者比前者慢大概十五倍。<br>从某一些方向上证明了，volatile的一些作用，比如调试的时候，或者一些特殊用途。涉足不多，故不记录。</p>
</li>
<li><p>变量说明</p>
<p><code>extern</code> 用于将不同文件的，带有外部链接性的变量引用到本文件中。所谓外部链接性就是可以被除本文件外的其他文件<strong>“看见”</strong>的变量，如全局变量，使用方法：</p>
<pre><code><span class="comment">/* 以下为一个工程内可见 */</span>
<span class="comment">/*file1.c*/</span>
<span class="keyword">int</span> glo_show;<span class="comment">//对于该全局变量来说，它们在声明时无初始化，则默认初始为0</span>
<span class="keyword">int</span> glo_print = <span class="number">10</span>;<span class="comment">//声明定义完成后，自动分配内存以存储信息    </span>
...

<span class="comment">/* file2.c */</span>
<span class="keyword">extern</span> glo_print; <span class="comment">//仅仅是引用名字，并不会额外分配空间</span>
                  <span class="comment">//所以，只需要写正确变量名字即可，后方的初始化无须完全</span>
                  <span class="comment">//因为变量的初始化定义只能有一次。</span>

<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"The Globle Value is %d \n"</span>, glo_print);
}
</code></pre><p>  <code>auto</code> 可以姑且忽略，因为没有什么实际意义。</p>
<h4 id="Create_By_WuShengXin_@_2015">Create By WuShengXin @ 2015</h4></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="我的C语言">我的C语言</h1><h2 id="本章更新于_2015/6/21_11:36:01">本章更新于 2015/6/21 11:36:01</h2><p><strong>正式接触编程，大概是一年连六个月吧，这真是一个令人着迷的领域</strong></p>
<h4 id="0x00-C语言前续工作">0x00-C语言前续工作</h4><p>正所谓，工欲善其事，必先利其器，把握住当下最强大的工具，能让我们在学习的道路上少走许多弯路，多吸取前人的失败经验，能让自己快速成长，因为成长总是在消耗我们的耐心以及生命。</p>
<p>入门或者精通或者应用，不管哪一方面，对于一个编程语言而言，最方便的还是使用一个<strong>IDE</strong>作为你的有力助手，什么事<strong>IDE</strong>？通俗而专业的说叫做<strong>集成开发环境</strong>，这个通过字面就能理解到了，就是所有其他的事情都不需要程序员操心，你需要操心的就是写出代码，至于代码完成之后的一系列工作，都不需要你来管，IDE一键帮你搞定。</p>
<p>当然，会有许多前辈告诉你，如果你想理解C语言，那你一定要使用最基层的东西来写，比如XXX编辑器配上XXX编译器，晕头转向之后更加茫然，本来就支离破碎的小心肝，又被粉碎了一次，撇开那些与当下不符合的幻想，活在现实中，选择一个适合你的<strong>IDE</strong>，逐渐适应它。</p>
<ul>
<li><p>讲几个著名的<strong>IDE</strong>，并给出建议，利器第一步：</p>
<ol>
<li><p>宇宙级的<strong>IDE</strong>: Visual Studio(2010~2015)，之所以说宇宙级，因为这是市面上最强大的集成开发环境，由微软公司出品，但是放在开头不是为了推荐他，而是为了警示大家不要使用它作为C语言的集成开发环境，因为它使用的是微软公司自己定制的C++编译器，也就是说，你的C语言代码会在C++的标准下编译运行，这就是一个十分不好的现象，即便是C++我依旧不喜欢使用Visual Studio，因为它的C++编译器总是和普通的标准有所出入。</p>
<p> 原归正传，Visual Studio的确不是一个好的C语言开发IDE，所以请另外选择一个。</p>
</li>
<li><p>老牌<strong>IDE</strong>: DevC++，这又是一个大家耳熟能详，经常能在老师手里看见的C语言教学利器，但是，它是C++的IDE，记住C于C++完全是两个世界的人，虽然C++宣称能全面兼容C程序，但是有些东西依旧是有所区别，体现在语法的兼容性上，后文会有提及。那为什么大学老师喜欢使用它呢？因为一本由清华大学出版社出版的《数据结构》，让无数人为之折服，其中赫然写着由于性能我们不能拘泥于小细节，故对于C++的特性<code>&amp;</code>引用，我们可以将其使用在C语言的语法中，就是这句话，让无数无知的学子扑向其中，再也分不清C与C++，看成谭浩强之后的，清华大学出版社又一诲人不倦的力作。</p>
<p> 所以，真爱编程，远离清华大学出版社，也请大家注意，不要使用DevC++这个IDE进行C语言程序的开发以及练习。</p>
</li>
<li><p>知名<strong>IDE</strong>: Code::Blocks，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是首推的C语言开发环境选择。</p>
</li>
<li><p>知名<strong>IDE</strong>: CodeLite，是一款非常优秀的开源跨平台集成开发环境，体积并不大，适合作为C语言的IDE，并且功能齐全，有兴趣的人可以深究，这是次推的C语言开发环境选择，因为使用起来稍微也有些额外的工作要做。</p>
</li>
<li><p>著名<strong>IDE</strong>: Xcode，是一个苹果电脑上的史诗级集成开发环境，虽然脱胎于C语言，但是由于某些原因，并不太建议使用其作为C语言的开发环境。 </p>
</li>
</ol>
</li>
<li><p>IDE的基本配置<br>利器第二步是对所选的IDE进行一些基本的配置，以及小科普。</p>
<ol>
<li><p>对于一个练习C语言的开发环境来说，选择合适的标准和编译器是很重要的，在Windows以及Linux操作系统下，我们还是使用<code>GCC</code>这个家伙比较多，开源，免费，且极其强大。当然你也可以选择<code>clang</code>，当然整个计算机领域中支持C语言的编译器并不止这两个，只不过这两个是开源免费，而且功能强大，十分适合作为个人开发以及无特殊需求的企业开发的选择。</p>
<p> 选择了编译器，我们开始讲标准：</p>
<p> 对于<code>GCC 5.1</code>以下的所有版本，都默认对C语言使用<code>C89</code>标准，但是我建议使用<code>C99</code>两者的差距，有一个极其明显的地方，便是<code>for</code>循环的使用</p>
<pre><code><span class="comment">/*C89:*/</span>
<span class="keyword">int</span> i;
<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)
<span class="comment">/*...*/</span>
</code></pre><p>…</p>
<pre><code><span class="comment">/*C99*/</span>
for<span class="comment">(int i = 0;i &lt; 10;++i)</span>
<span class="comment">/*...*/</span>
</code></pre><p> 这只是其中的一种差别，但是C99需要人为手动的开启，但是很多人有疑问，为什么有时候没有配置什么也能使用后面的语法？吴老师告诉你，这是因为你用了C++的文件进行C语言的开发，就像挂羊皮卖狗肉的道理。</p>
</li>
<li><p>开启C99</p>
<p>一般IDE的顶部都是一系列的标签，找到<code>工具/设置</code>，因为不同的IDE可能有不同的标签，总之在其中找到一个叫<strong>(编译器)Compiler</strong>之后，在其中的<strong>other option</strong>中加入以下:<code>-std=c99</code>，这便是开启C99的选项代码，完事之后保存即可。虽然说我们是中国人，但是毕竟这东西的外国人发明的，我们能看英文就看英文吧。</p>
</li>
</ol>
<ul>
<li><p>至此，利器成功配置。</p>
</li>
<li><p>当然最重要的还是内在，所以加油吧，虽然是一门很古老的语言，但是存在既有其道理。</p>
</li>
</ul>
</li>
</ul>
<h4 id="0x01-C语言序言">0x01-C语言序言</h4><p> 倒是觉得写代码首先不是语法，而是格式，任何时候任何地点，要是自己的代码难以理解，要么你是故意的，要么你就是菜菜</p>
<p> 一个难以被人理解的代码在我看来是没有太多的潜力的，但不排除故意为之的情况,也许很多人说这是强迫症，但是无论打开哪一个开源代码，你看到的都将是一个拥有规范的代码文件</p>
<p>也许有人说人不应该被限制，不应该拘泥于小节，但是当一个工程超过一千行，也许不用只需要不到五百行，就能完全暴露出代码规范的重要性，包括缩进，变量命名，接口存放，接口参数的规范之类，听起来似乎很虚<a href="https://code.google.com/p/google-styleguide/">谷歌代码规范(翻墙后查看)</a></p>
<p>在我看来C语言的内建语法真是无比简洁，几乎存在既有道理，简洁不代表着不强大，强大的某些地方在近来渐渐复苏的Lisp身上也有体现。</p>
<p><code>if, for, while, switch</code></p>
<p><p>组成了每个C程序的半壁江山<br><br><code> “ + “ “ - “ “ * “ “ / “ “ % “ “ = “</code></p>
<p><p>组成了各式各样的算法计数<br><br><code>“&gt;&gt;” “&lt;&lt;” “|” “&amp;” “^” “~” “!”</code></p>
<p><p>让C语言有了更高效的算法以及更奇妙的思路<br><br><code>struct enum union #define return</code><br></p>
<p><p>而这些则让C语言在这乱世纷争中站稳了脚跟，并且一枝独秀<br><br><code>“{}” “()”</code><br></p>
<p><p>让代码不再无序混乱<br><br><code>“type * “ “&amp;” “()” “-&gt;”</code><br></p>
<p><p>让C语言在这个世界无处不在<br><code>“ . “ “[ ]” “ &lt; “ “ &gt; “ “ == “</code><br></p>]]>
    
    </summary>
    
      <category term="C" scheme="//wushxin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python-lib安装]]></title>
    <link href="//wushxin.top/2015/05/10/Python-lib%E5%AE%89%E8%A3%85.html"/>
    <id>//wushxin.top/2015/05/10/Python-lib安装.html</id>
    <published>2015-05-09T23:48:28.000Z</published>
    <updated>2015-05-10T14:22:44.480Z</updated>
    <content type="html"><![CDATA[<h1 id="Python">Python</h1><h2 id="安装第三方库(Linux::Ubuntu_14-04_LTS)">安装第三方库(Linux::Ubuntu 14.04 LTS)</h2><p>   关于一个gui的库 SimpleGUICS2Pygame <br><br>   所有的命令均在 root 权限下执行 <br></p>
<h3 id="安装前提:">安装前提:</h3><ol>
<li>使用easy_install 工具 <code>apt-get install easy_install</code></li>
<li>安装pip <code>easy_install pip</code></li>
</ol>
<h3 id="开始安装">开始安装</h3><ol>
<li>在 <a href="https://pypi.python.org/pypi/SimpleGUICS2Pygame" target="_blank" rel="external">https://pypi.python.org/pypi/SimpleGUICS2Pygame</a> 下载.egg格式的安装包 <br></li>
<li>使用命令 <code>easy_install name.egg #name.egg 为下载的第三方库的egg包名称</code></li>
<li>我们这里可以使用 <code>easy_install *.egg #代表安装所有的egg包,方便快捷,不用输入完整的名字</code></li>
<li>我们可以通过 <code>pip freeze</code> 查看所安装的包</li>
</ol>
<h3 id="使用错误">使用错误</h3><ul>
<li><p>当我们 <code>import simplegui</code>时,却出现 <code>...importError: No module named simplegui</code> <br><br>此时,我们应该使用这个语句块替换: <br></p>
<pre><code><span class="string">try:</span>
    <span class="keyword">import</span> simplegui 
<span class="string">except:</span>
    <span class="keyword">import</span> SimpleGUICS2Pygame.simpleGUICS2Pygame <span class="keyword">as</span> simplegui
</code></pre></li>
</ul>
<p>· 作者给出的解释是由于内部冲突所以会导致这种现象的产生</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Python">Python</h1><h2 id="安装第三方库(Linux::Ubuntu_14-04_LTS)">安装第三方库(Linux::Ubuntu 14.04 LTS)</h2><p>   关于一个gui的库 SimpleGUICS2Pygame <]]>
    </summary>
    
      <category term="Python" scheme="//wushxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <link href="//wushxin.top/2015/05/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>//wushxin.top/2015/05/10/Python学习笔记.html</id>
    <published>2015-05-09T23:48:13.000Z</published>
    <updated>2015-05-10T14:17:51.926Z</updated>
    <content type="html"><![CDATA[<h2 id="Python学习笔记之基础">Python学习笔记之基础</h2><h3 id="Python缩进">Python缩进</h3><p>1. Python用相同缩进来代表同一个代码块，而某2些语言则是用花括号</p><br><p>2. 缩进最好使用四个空格，不要混用和使用Tab</p><br><p>3. 退出缩进多敲一个回车</p>

<h3 id="if语句">if语句</h3><pre><code><span class="keyword">if</span> statemen<span class="variable">t:</span>
    statement
elif statemen<span class="variable">t:</span>
    statement
<span class="keyword">else</span> statemen<span class="variable">t:</span>
    statement

<span class="keyword">print</span> <span class="string">'That is All'</span>
</code></pre> <a id="more"></a>
<h3 id="for语法">for语法</h3><p><pre><code><br>    for variable in list/tuple:<br>        statement<br></code></pre></p>
<p>则variable每次循环就会前进一个，代表一个元素</p><br><strong>for 和 in 是Python的关键字</strong><br><br><br>    int i = 0<br>    while i<2: statement="" <strong="">循环可以多层嵌套，判断条件也很灵活<br><br>    for x in [1, 2, 3]:<br>        for y in (1, 2, 3):<br>            print x+y<br>    #输出 2 4 6<br><p>同样while也可以嵌套，注意缩进即可</p><br><p>continue关键字的用法和C语言一样</p>

<h3 id="list有序表">list有序表</h3><p><code>[value, ...]</code> 创建语法，其内元素类型可不相同</p><br><p>1. <code>[index]</code> 索引，也可用来赋值</p><br><p>2. <code>append()</code> 将元素加入末尾</p><br><p>3. <code>insert()</code>将元素插入开头</p><br><p>4. <code>pop()</code>剔除最后一个元素,加上索引参数就剔除指定位置元素</p>

<h3 id="tuple有序表">tuple有序表</h3><p><code>(value, ...)</code> 创建语法，与list不同的是，创建后不可改变</p><br><p>1. <code>( )</code> 在创建tuple单元素的时候，记得加 , 以免造成语法歧义 &gt;&gt;&gt; t = (2,)</p><br><p>2. <code>t[1]</code>同样使用索引找到想要的值</p><br><p>“可变的”tuple 原理即在tuple中加入</p><br><pre><code><br>    list &gt;&gt;&gt; t = (1,2,[‘Kandle’, ‘Bankgh’])<br></code></pre><br><p>就可以使用tuple的索引到list进行增减</p>

<h3 id="dict无序表">dict无序表</h3><p><code>{&#39;Search_name&#39;: value, ... }</code>创建语法，就像是字典，通过”名称(专业术语叫key)”来查找值(value)，</p><br><p>原理是数据结构哈希表或者叫散列表(Hash Table)</p><br><pre><code><br>    &gt;&gt;&gt; d = {‘Leao’: 65, ‘Candy’: 89, ‘Saver’: 86}<br></code></pre><br><p>1. <code>d[&#39;Leao&#39;]</code> 同样使用索引找到对应的值</p><br><p>如果只是使用<code>[ ]</code>来索引，那么当key不存在时，程序将出错，可以使用dict所带的一种方法:</p><br><p>2. <code>get(&#39;Leao&#39;)</code> 同样返回对应的值，当key不存在时，将返回 None 而不是让程序报错</p><br><p>3. key是不可变的，不可重复的。value无限制</p><br><p>4. 高级应用:</p><br><p>    充分利用key的特性，由于Python中数字类型，字符串和tuple类型不可变，故可以用来做key</p><br><pre><code><br>    t1 = {‘string’: [1, 2, 3], 20: ‘string’, [1, 2]: True}<br></code></pre><br><p>5. <code>d[&#39;Newone&#39;] = 99</code> 向已有的dict中添加新成员</p>

<h3 id="set无序表">set无序表</h3><p><strong>与dict相似，只是少了value，只有key</strong></p>
<p>([‘A’, …]) 创建语法</p><br><p>1. 与list某些特性相似，打印时显示所有元素，但顺序不一定是加入的顺序</p><br><pre><code><br>    &gt;&gt;&gt; s = ([‘A’, ‘B’, ‘C’, ‘C’]<br></code></pre><br><p>print s 可能输出 set([‘A’, ‘C’, ‘B’])</p><br><p>2. set类型只有key没有value，那么访问它们时，返回的不再像dict那样是value，而是 True 或 False</p><br><p>3. set可以用关键字 in 访问 <code>&gt;&gt;&gt; &#39;A&#39; in s</code> 返回Ture</p><br><p>4. add() 添加元素</p><br><p>5. remove() 删除元素</p>

<h3 id="函数">函数</h3><p><strong>1. 内置函数可以使用 help(fun_name) 查看用法</strong></p>
<p>类型转换函数也是内置的，比如将字符串转为数字</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt; int(<span class="string">'123'</span>)
<span class="prompt">&gt;&gt;</span>&gt; <span class="number">123</span>
</code></pre><p>2. 编写函数</p><br><p>格式</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(args)</span>:</span>
    statement
    <span class="keyword">return</span>
</code></pre><p>其中def是定义函数的关键字，其后紧跟一个空格，函数名字，括号，括号中有传入的形式参数，冒号，</p><br><p>函数体(同样是缩进代表同一个代码块)，return也是关键字，后面可跟返回值，如果没有则默认返回None</p><br><p>3.Python的函数可以返回多个值，接收的时候可以用多个变量接受，用逗号隔开。</p><br><p>实际上Python<strong>只是返回一个tuple类型的值</strong>，并不是真的返回多个值，只不过多个变量可以接收同一个tuple类型的值，并按照相应位置赋值:</p>

<pre><code><span class="comment">#假设move_north函数接收一个距离，并返回下一个坐</span>
<span class="comment">#标的值</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y = move_north(<span class="number">200</span>)
<span class="prompt">&gt;&gt;</span>&gt; print x, y
<span class="prompt">&gt;&gt;</span>&gt; <span class="number">133.55</span> <span class="number">226.17</span>
<span class="prompt">&gt;&gt;</span>&gt; r = move_north(<span class="number">200</span>)
<span class="prompt">&gt;&gt;</span>&gt; print r
<span class="prompt">&gt;&gt;</span>&gt;(<span class="number">133.55</span>, <span class="number">226.17</span>)
</code></pre><p>4. 函数的默认参数</p><br><p>可以让某些函数的参数拥有默认值，来简化函数调用</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">my_function1</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span>
    <span class="keyword">return</span> x+y
<span class="function"><span class="keyword">def</span> <span class="title">my_function2</span><span class="params">(x, y)</span>:</span>
    <span class="keyword">return</span> x+y
&gt;&gt;&gt;<span class="keyword">print</span> my_function1(<span class="number">10</span>), my_function1(<span class="number">10</span>,<span class="number">10</span>)
&gt;&gt;&gt;<span class="number">20</span>, <span class="number">20</span>
&gt;&gt;&gt;<span class="keyword">print</span> my_function2(<span class="number">10</span>) <span class="comment">#报错</span>
&gt;&gt;&gt;<span class="keyword">print</span> my_function2(<span class="number">10</span>, <span class="number">10</span>)
&gt;&gt;&gt;<span class="number">20</span>
</code></pre><p>被设置默认值的参数后面不能有没有默认参数的参数。</p><br><p>5.可变参数的函数</p>

<pre><code><span class="function"><span class="keyword">def</span> <span class="title">averages</span><span class="params">(*args)</span>:</span>
    sum = <span class="number">0.0</span>
    count = <span class="number">0.0</span>
    <span class="keyword">for</span> val <span class="keyword">in</span> args:
        sum = sum + val
        count = count + <span class="number">1.0</span>
    <span class="keyword">return</span> sum/count
</code></pre><p>把args变量看作一个tuple即可</p>

<h3 id="list和tuple的_切片操作">list和tuple的 切片操作</h3><p>即取出其中部分的一种操作</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="number">0</span><span class="symbol">:</span><span class="number">3</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="symbol">:</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
<span class="comment">#接收第三个参数，用来增加条件</span>
<span class="prompt">&gt;&gt;</span>&gt;<span class="constant">L</span>[<span class="symbol">:</span><span class="symbol">:</span><span class="number">2</span>]
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]
</code></pre><h4 id="切片操作的用法">切片操作的用法</h4><pre><code>list[start_index:end_index+<span class="number">1</span>:step]
<span class="preprocessor">#索引为end_index+1位置上的元素不会被取到</span>
<span class="preprocessor">#步长为-1，就说明要倒序取</span>
</code></pre><p><strong>tuple的切片操作与list一致</strong><br></p>
<p>字符串的切片操作</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;<span class="string">'ABCD'</span>[<span class="symbol">:</span><span class="number">2</span>]
<span class="prompt">&gt;&gt;</span>&gt;<span class="string">'AB'</span>
</code></pre><h3 id="关于迭代">关于迭代</h3><p>1. for总是取出某个集合中的元素，而不是索引</p><br><p>如果我们想要索引，可以使用<strong>enumerate()</strong>函数</p>

<pre><code>#假设有L[<span class="string">'Linda'</span>, <span class="string">'Papara'</span>, <span class="string">'Gerada'</span>, <span class="string">'Bazinga'</span>]
<span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="function"><span class="title">enumerate</span><span class="params">(L)</span></span>:
    print index, <span class="string">'-'</span>, value
&gt;&gt;&gt;<span class="number">0</span> - Linda <span class="number">1</span> - Papara <span class="number">2</span> - Gerada <span class="number">3</span> - Bazinga
</code></pre><p>实际上enumerate自动把每个元素和其对应的索引组合成一个tuple类型，接下来就行了。</p><br><p>2. 迭代dict中的value</p><br><p>可以使用dict的values()方法或者intervalues()，两个方法效果一样，差别在于内存的消耗</p>

<pre><code><span class="keyword">for</span> val <span class="keyword">in</span> dictionary.value()<span class="symbol">:</span>
    print val
<span class="prompt">&gt;&gt;</span>&gt;<span class="comment">#打印出dict 中的所有值而不是key</span>
</code></pre><p><strong>同时输出key和value的方法:</strong></p>
<p>使用dict的items()和iteritems()方法</p>

<pre><code><span class="keyword">for</span> key, <span class="built_in">value</span> <span class="operator">in</span> dictionary.<span class="keyword">items</span>():
    print key, <span class="string">'-'</span>, <span class="built_in">value</span>
&gt;&gt;&gt;<span class="string">'Linda'</span> - <span class="number">65</span> ...<span class="comment">#打印出所有的key value</span>
</code></pre><h3 id="*生成列表">*生成列表</h3><p>1. <strong>range()</strong>函数可以生成既定步长的列表</p>

<pre><code><span class="prompt">&gt;&gt;</span>&gt;range(<span class="number">1</span>,<span class="number">10</span>)
<span class="prompt">&gt;&gt;</span>&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]
</code></pre><p>2. 有一种Python自带的列表语法</p>

<pre><code>&gt;&gt;&gt;[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>)</span></span>]
&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]
</code></pre><p>语法是，先写一个元素的表达式(你的元素要满足的条件，这里是x*x)，其次跟一个for迭代式子。放在一个list生成式里</p>

<pre><code>#range同样是一个有默认参数的内置函数
<span class="function"><span class="title">range</span><span class="params">(start_index, end_index+<span class="number">1</span>, step)</span></span>
</code></pre><p>3. 复杂表达式</p><br><p>在列表生成中，不仅可以使用for迭代，我们还能让if剔除迭代中不想要的元素</p>

<pre><code>&gt;&gt;&gt;[x*<span class="function">x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="title">range</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>)</span> <span class="keyword">if</span> x % 2 </span>== <span class="number">0</span>]
&gt;&gt;&gt;[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]
<span class="preprocessor">#只有<span class="keyword">if</span>语句是真时，才会出现在生成的list中</span>
</code></pre><p>4. 列表生成中，同样可以嵌套循环</p><br><p>5.高级应用，使用列表生成来制作网页中的部件，如生成表格</p>
</2:>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Python学习笔记之基础">Python学习笔记之基础</h2><h3 id="Python缩进">Python缩进</h3><p>1. Python用相同缩进来代表同一个代码块，而某2些语言则是用花括号</p><br><p>2. 缩进最好使用四个空格，不要混用和使用Tab</p><br><p>3. 退出缩进多敲一个回车</p>

<h3 id="if语句">if语句</h3><pre><code><span class="keyword">if</span> statemen<span class="variable">t:</span>
    statement
elif statemen<span class="variable">t:</span>
    statement
<span class="keyword">else</span> statemen<span class="variable">t:</span>
    statement

<span class="keyword">print</span> <span class="string">'That is All'</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Python" scheme="//wushxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++流操作(续)]]></title>
    <link href="//wushxin.top/2015/05/10/C-%E6%B5%81%E6%93%8D%E4%BD%9C-%E7%BB%AD.html"/>
    <id>//wushxin.top/2015/05/10/C-流操作-续.html</id>
    <published>2015-05-09T23:47:59.000Z</published>
    <updated>2015-09-20T02:43:04.458Z</updated>
    <content type="html"><![CDATA[<h3 id="Ｃ++流的使用(续)">Ｃ++流的使用(续)</h3><h2 id="文件I/O">文件I/O</h2><ul>
<li><p>常用的基本方法是 <code>open()</code>,<code>c_str()</code>,<code>is_open()</code> 分别时连接文件,转为Ｃ风格字符串,是否连接文件成功 </p><p></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt; <span class="comment">//此头文件已经包含了iostream</span></span>
...
<span class="built_in">string</span> cppstr1 = <span class="string">"input.txt"</span>, cppstr2 = <span class="string">"output.txt"</span>;
...
ifstream fin;      <span class="comment">//任意命名</span>
ofstream fout;
fin.open(cppstr1.c_str());
<span class="keyword">if</span>(!fin.is_open())
{
<span class="built_in">cerr</span> &lt;&lt; <span class="string">"..."</span>;
<span class="keyword">return</span> -<span class="number">1</span>;
}
fout.open();
...
</code></pre></li>
<li><p>使用命令行参数的使用  <a id="more"></a></p>
<ol>
<li><code>int main(int argc, char* argv[])</code> 式中的参数很多人既熟悉又陌生,第一个参数代表参数个数(包括自身)<p></p></li>
<li><p>第二个参数argv的意义在于使用某个参数的名字,以字符串的形式,举个栗子 </p><p></p>
<pre><code>#<span class="keyword">include</span> ...
<span class="comment">//...</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="keyword">file</span> = <span class="number">1</span>;<span class="keyword">file</span> &lt; argc;++<span class="keyword">file</span>)   <span class="comment">//file为 0 时输出的是该命令或者可执行文件的名称</span>
        cout &lt;&lt; argv[<span class="keyword">file</span>];                <span class="comment">//argv[file]的类型为char*, 即为一个字符串,内容</span>
                                          <span class="comment">//为参数的名字,argc代表总参数个数+1</span>
}
</code></pre></li>
<li><p>假设上面的程序经过编译,在<strong>Liunx</strong>下实验则为(Windows下请打开命令提示符模式(Win+R,输入cmd,回车后打开),后续操作大致相同) </p>
<ul>
<li><code>$ a.out file1 file2</code></li>
<li><strong>其中 argv[1] == “file1”, argv[2] == “file2” argv[0] == “a.out”</strong>  </li>
</ul>
</li>
</ol>
</li>
<li><p>文件I/O的模式 mode </p>
<pre><code><span class="comment">//接上上个程序</span>
fin.open(cppstr1.c_str(),mode);     <span class="comment">//mode代表模式,后面介绍</span>
<span class="function">ifstream <span class="title">fin2</span><span class="params">(cppstr2.c_str()</span>,mode)</span>;<span class="comment">//也可以使用构造函数的方式</span>
<span class="function">ofstream <span class="title">fout2</span><span class="params">(...)</span></span>;                <span class="comment">//ofstream的模式多于ifstream</span>
</code></pre></li>
</ul>
<ul>
<li><p><strong>下面模式可以与Ｃ中的I/O模式对应</strong></p>
<pre><code>using <span class="symbol">std:</span><span class="symbol">:ios_base</span>;
<span class="symbol">ios_base:</span><span class="symbol">:in</span>   /<span class="regexp">/此mode适用于ifstream类型,用于打开并读取文件&lt;/br</span>&gt;
<span class="symbol">ios_base:</span><span class="symbol">:out</span>  /<span class="regexp">/打开文件,并写入&lt;/br</span>&gt;
<span class="symbol">ios_base:</span><span class="symbol">:trunc//</span>如果文件存在则,截断文件,ofstream的构造函数默认使用 <span class="symbol">ios_base:</span><span class="symbol">:out|ios_base</span><span class="symbol">:</span><span class="symbol">:turnc`&lt;/br&gt;</span>
<span class="symbol">ios_base:</span><span class="symbol">:app</span>  /<span class="regexp">/打开文件,追加到文件尾写入&lt;/br</span>&gt;
<span class="symbol">ios_base:</span><span class="symbol">:ate</span>  /<span class="regexp">/打开文件,并移动到文件尾&lt;/br</span>&gt;
<span class="symbol">ios_base:</span><span class="symbol">:binary</span> /<span class="regexp">/使用二进制文件模式.对于数字十分迅捷,但也有不足,即兼容性.&lt;/br</span>&gt;
</code></pre><p><strong>符号<code>|</code>,代表或,该运算符两端的操作都使用</strong>   </p>
</li>
</ul>
<h2 id="文件I/O之二进制文件">文件I/O之二进制文件</h2><ul>
<li><p>此后的代码都必须建立在同一种类型的系统甚至同一种类型的编译器中,即产生或使用的文件的使用的范围. </p>
<pre><code><span class="preprocessor">#include `&lt;fstream&gt;`</span>
<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">"test.txt"</span>;
<span class="keyword">struct</span> test{
    <span class="keyword">char</span>   name[<span class="number">10</span>];
    <span class="keyword">double</span> popu;
    <span class="keyword">double</span> g;
};<span class="comment">//定义一个结构体,用来展示二进制的读以及写</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
...<span class="comment">//创建一个test类型的结构体对象,并填入值,对象名为 bintest</span>
<span class="function">ofstream <span class="title">fout</span><span class="params">(filename, `ios_base::<span class="keyword">in</span>`|`ios_base::binary`)</span></span>;
...<span class="comment">//检查是否打开成功</span>
fout.write((`<span class="keyword">char</span>*`)&amp;bintest, <span class="keyword">sizeof</span> bintest); 
<span class="comment">//使用write函数来写入,char*代表逐个字符的从内存写入到文件,而不考虑存储类型`</span>
<span class="function">ofstream <span class="title">fin</span><span class="params">(filename, `ios_base::<span class="keyword">in</span>`|`ios_base::binary`)</span></span>;
...<span class="comment">//检查是否打开成功</span>
fin.read((<span class="keyword">char</span>*)&amp;bintest, <span class="keyword">sizeof</span> bintest);<span class="comment">//使用read函数来恢复使用write函数写入的二进制数据</span>
...<span class="comment">//验证是否操作有误</span>
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></li>
</ul>
<p><strong>科普:由于三大类操作系统对于换行有不同定义,导致了第一句话</strong>:</p>
<p><strong>Windows</strong>使用换行加回车表示 换行符</p><p></p>
<p><strong>Unix/Liunx</strong>使用换行来表示  换行符</p><p></p>
<p><strong>Mac</strong>使用回车来表示   换行符(即苹果电脑)</p><p></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Ｃ++流的使用(续)">Ｃ++流的使用(续)</h3><h2 id="文件I/O">文件I/O</h2><ul>
<li><p>常用的基本方法是 <code>open()</code>,<code>c_str()</code>,<code>is_open()</code> 分别时连接文件,转为Ｃ风格字符串,是否连接文件成功 </P></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt; <span class="comment">//此头文件已经包含了iostream</span></span>
...
<span class="built_in">string</span> cppstr1 = <span class="string">"input.txt"</span>, cppstr2 = <span class="string">"output.txt"</span>;
...
ifstream fin;      <span class="comment">//任意命名</span>
ofstream fout;
fin.open(cppstr1.c_str());
<span class="keyword">if</span>(!fin.is_open())
{
<span class="built_in">cerr</span> &lt;&lt; <span class="string">"..."</span>;
<span class="keyword">return</span> -<span class="number">1</span>;
}
fout.open();
...
</code></pre></li>
<li><p>使用命令行参数的使用]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++流操作]]></title>
    <link href="//wushxin.top/2015/05/10/C-%E6%B5%81%E6%93%8D%E4%BD%9C.html"/>
    <id>//wushxin.top/2015/05/10/C-流操作.html</id>
    <published>2015-05-09T23:47:37.000Z</published>
    <updated>2015-09-20T02:32:19.353Z</updated>
    <content type="html"><![CDATA[<h1 id="C++流的使用">C++流的使用</h1><h2 id="每次使用完流,记得要关闭,虽然有时候并不是必须的-">每次使用完流,记得要关闭,虽然有时候并不是必须的.</h2><p><code>streamname.close();</code></p>
<h2 id="重定向">重定向</h2><p>   在Linux终端或者Windows命令提示符模式下,使用重定向可以改变输入源和输出源</p>
<p>   <code>~$ program &lt;input.filetype&gt;output.filetype</code> </p>
<p>   在Linux和Unix下, <code>&gt;</code> <code>&lt;</code> 默认是标准输出和标准输入, <code>2&gt;</code> 则是标准错误(即<code>std::cerr</code>)</p>
<h2 id="输出流">输出流</h2><ol>
<li><p><code>ostream</code> 类提供了 <code>put()</code> 和 <code>write()</code> 方法用来输出 </p>
<pre><code><span class="built_in">cout</span>.put(<span class="string">'W'</span>); <span class="comment">//输出字符Ｗ,可以拼接使用就像重载之后的 '&lt;&lt;'</span>
<span class="built_in">cout</span>.write(<span class="string">"Candy Bob"</span>,<span class="number">5</span>); <span class="comment">//输出第一个参数的第二个参数个长度</span>
</code></pre></li>
<li><p>刷新输出缓冲区可以有两种方法,原理都是重载 <code>&lt;&lt;</code> </p>
<ul>
<li><p>前者与后者的差别就在与后者刷新缓冲区后多了一个换行操作</p>
<pre><code><span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; flush; <span class="comment">//相当于flush(cout);</span>
<span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; endl;  
</code></pre></li>
</ul>
</li>
<li><p>可以通过流操作修改现实的进制, 默认十进制,十六进制,八进制 <br></p>
<a id="more"></a>
<pre><code><span class="keyword">int</span> n = <span class="number">100</span>;
<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
<span class="comment">//八进制</span>
<span class="built_in">cout</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; endl;
<span class="comment">//十六进制</span>
<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; endl;
<span class="comment">//这种作用是持久的,在不用的时候记得转换回来</span>
dec(<span class="built_in">cout</span>); <span class="comment">//代表转换为十进制 cout &lt;&lt; dec;同样适用  </span>
</code></pre></li>
<li><p>我们可以调整字段宽度来达到美观,但Ｃ++有一种数据完整大于美观的理念,所以即使你设置了字段宽度,一旦超过还是会打乱阵型,以保证数据的完整性.</p>
<pre><code><span class="built_in">cout</span>.fill(<span class="string">'*'</span>);<span class="comment">//使用'*'填充空白,注意此为持久的.</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i*=<span class="number">10</span>)
{
<span class="built_in">cout</span>.width(<span class="number">5</span>);
<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;
<span class="built_in">cout</span>.width(<span class="number">8</span>);
<span class="built_in">cout</span> &lt;&lt; i * i &lt;&lt; endl;
}<span class="comment">//注意，width()方法并不是持久的,也就是说每次排版都需要使用一次该方法.</span>
</code></pre></li>
<li><p>浮点数的使用 <br></p>
<pre><code><span class="built_in">cout</span>.precision(<span class="number">2</span>);<span class="comment">//设置浮点数的精度为2,Ｃ++默认六位精度,但不显示末尾的0.</span>
<span class="built_in">cout</span>.setf(ios_base::showpoint);<span class="comment">//显示末尾的零</span>
</code></pre><h2 id="输入流">输入流</h2></li>
</ol>
<ul>
<li><p><code>cin</code> 检查输入: 当读取到的流和指定的类型不符合的时候,不符合的流中的数据被保留,留待下一次读取.并返回<code>flase</code>, 可以使用 <code>while</code> 语句进行判断 <br></p>
<pre><code>int <span class="keyword">input</span>, <span class="keyword">sum</span>;
<span class="keyword">while</span>(cin &gt;&gt; <span class="keyword">input</span>)
<span class="keyword">sum</span> += <span class="keyword">input</span>;
</code></pre></li>
<li><p>当流由于输入不匹配失败时,发生的问题十分复杂,简述为位设置问题,使用下列代码恢复</p>
<pre><code><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; input)
    sum += input;
<span class="keyword">if</span>(<span class="built_in">cin</span>.fail() &amp;&amp; !<span class="built_in">cin</span>.eof())
{
<span class="built_in">cin</span>.clear();              <span class="comment">//重置流状态,但此时还是有残余留在流中</span>
<span class="keyword">while</span>(!<span class="built_in">isspace</span>(<span class="built_in">cin</span>.get()))<span class="comment">//丢弃那些残留在流中妨碍下一次输入的不符合的输入</span>
    <span class="keyword">continue</span>;           <span class="comment">//头文件 cctype</span>
}
<span class="built_in">cin</span> &gt;&gt; input; <span class="comment">//现在可以继续输入了</span>
</code></pre></li>
<li><p>字符串的输入: <code>get(char*, int)</code> 和 <code>getline(char*, int)</code> </p>
<pre><code>- get读取少于第二个参数减<span class="number">1</span>个或遇见换行符,并将换行符留在流中,<span class="escape">`g</span>etline<span class="escape">`则</span>将换行符抽取并丢弃
</code></pre></li>
<li><p><code>get(char*, int, char)</code> 和 <code>getline(char*, int, char)</code> </p>
<pre><code><span class="bullet">- </span>第三个参数则是分界符,读取到分界符号时停止读取. 
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="C++流的使用">C++流的使用</h1><h2 id="每次使用完流,记得要关闭,虽然有时候并不是必须的-">每次使用完流,记得要关闭,虽然有时候并不是必须的.</h2><p><code>streamname.close();</code></p>
<h2 id="重定向">重定向</h2><p>   在Linux终端或者Windows命令提示符模式下,使用重定向可以改变输入源和输出源</p>
<p>   <code>~$ program &lt;input.filetype&gt;output.filetype</code> </p>
<p>   在Linux和Unix下, <code>&gt;</code> <code>&lt;</code> 默认是标准输出和标准输入, <code>2&gt;</code> 则是标准错误(即<code>std::cerr</code>)</p>
<h2 id="输出流">输出流</h2><ol>
<li><p><code>ostream</code> 类提供了 <code>put()</code> 和 <code>write()</code> 方法用来输出 </p>
<pre><code><span class="built_in">cout</span>.put(<span class="string">'W'</span>); <span class="comment">//输出字符Ｗ,可以拼接使用就像重载之后的 '&lt;&lt;'</span>
<span class="built_in">cout</span>.write(<span class="string">"Candy Bob"</span>,<span class="number">5</span>); <span class="comment">//输出第一个参数的第二个参数个长度</span>
</code></pre></li>
<li><p>刷新输出缓冲区可以有两种方法,原理都是重载 <code>&lt;&lt;</code> </p>
<ul>
<li><p>前者与后者的差别就在与后者刷新缓冲区后多了一个换行操作</p>
<pre><code><span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; flush; <span class="comment">//相当于flush(cout);</span>
<span class="built_in">cout</span> &lt;&lt; <span class="string">"Show Now!"</span> &lt;&lt; endl;  
</code></pre></li>
</ul>
</li>
<li><p>可以通过流操作修改现实的进制, 默认十进制,十六进制,八进制 </br></p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="//wushxin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo网站布置错误解决]]></title>
    <link href="//wushxin.top/2015/05/09/Hexo%E7%BD%91%E7%AB%99%E5%B8%83%E7%BD%AE%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3.html"/>
    <id>//wushxin.top/2015/05/09/Hexo网站布置错误解决.html</id>
    <published>2015-05-09T12:10:30.000Z</published>
    <updated>2015-06-12T01:27:05.988Z</updated>
    <content type="html"><![CDATA[<h2 id="布置Hexo博客">布置Hexo博客</h2><h4 id="发布于Github_pages时的错误总结">发布于Github pages时的错误总结</h4><p>在布置一个个人博客的时候，我们总会遇到各种各样的错误，这里来总结一下，不记录那些常规步骤，因为网上特别多，搜集常见错误。</p>
<ul>
<li>本人布置建设并布置该网站在2015.5.9日，Hexo的版本已经到3了，并且在这个版本出现了一个和以前不同的配置，所以导致许多后来者按照前人的脚步跳进了深坑，当然你降至版本2也是可以使用前人的设置的。<br>首先是在你配置好本地之后，验证可行了，那么你就可以选择发布到Github Pages上了，这个时候，在<strong>_config.yml</strong>文件中修改末尾项为:<pre><code><span class="attribute">deploy</span>:
    <span class="attribute">type</span>: git #此处在版本<span class="number">2</span>时为github
    <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/......</span>
    ...
</code></pre>在这个地方容易出错的是<strong>type:</strong>后方容易被误导，版本2请填写github，版本3除了填写git以外，还需要在外头<strong>Git bash</strong>里使用命令:<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span>
</code></pre>有了这个命令就能分分钟解决你的问题。<a id="more"></a></li>
<li><p>还有一个问题，在我们使用命令:</p>
<pre><code><span class="title">hexo</span> init <span class="string">"Blog_name"</span>
</code></pre><p>初始化建立一个博客之后，我们需要使用命令:</p>
<pre><code>npm <span class="keyword">install</span>
</code></pre><p>来下载依赖包，可是这个命令中需要下载的某些东西是从Google下载的，所以很多人在搭建的时候卡在这一步一动不动，原因是中国屏蔽了谷歌，然后就没有然后了，我建议使用VPN直接连接外网后重新使用该命令，而不要像网上那样自行下载某些部分。</p>
</li>
<li><p>偶尔在最后一步使用:</p>
<pre><code><span class="title">hexo</span> deploy
</code></pre><p>进行上传布局的时候，会在输入完用户名密码以后出现错误，请你按照这个格式进行(_config.yml中):</p>
<pre><code><span class="string">repository:</span> <span class="string">https:</span><span class="comment">//github.com/yourname/yourname.github.io.git</span>
</code></pre><p>如此就行了</p>
</li>
<li><p>有时候会遇到，标签失效，或者说两个标签指向了同一个路径，那么你可以看看自己的标签是否有符号例如<code>C</code>和<code>C++</code>，那么就会导致两个都指向同一个路径，这时候只需要把<code>C++</code>改成<code>Cpp</code>即可。</p>
</li>
</ul>
<h4 id="这就是我今天遇到的所有问题，建设虽难，可不要放弃啊。">这就是我今天遇到的所有问题，建设虽难，可不要放弃啊。</h4><h3 id="技巧">技巧</h3><ul>
<li><p>对于那些使用googleapi站点的链接来说，由于国内把谷歌墙了，所以可改用百度静态CDN库，在目录文件：</p>
<pre><code><span class="command">\themes</span><span class="command">\landscape</span><span class="command">\layout</span><span class="command">\_</span>partial<span class="command">\after</span>-footer.ejs
</code></pre><p>  中修改jQuery的引用网址为百度cdn的地址即可。</p>
</li>
<li><p>对于<strong>RSS</strong>功能，请使用如下命令：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span>
</code></pre><p>  亲测，如果不加<strong>- -save</strong>参数有的环境下这个插件无法正常的工作。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="布置Hexo博客">布置Hexo博客</h2><h4 id="发布于Github_pages时的错误总结">发布于Github pages时的错误总结</h4><p>在布置一个个人博客的时候，我们总会遇到各种各样的错误，这里来总结一下，不记录那些常规步骤，因为网上特别多，搜集常见错误。</p>
<ul>
<li>本人布置建设并布置该网站在2015.5.9日，Hexo的版本已经到3了，并且在这个版本出现了一个和以前不同的配置，所以导致许多后来者按照前人的脚步跳进了深坑，当然你降至版本2也是可以使用前人的设置的。<br>首先是在你配置好本地之后，验证可行了，那么你就可以选择发布到Github Pages上了，这个时候，在<strong>_config.yml</strong>文件中修改末尾项为:<pre><code><span class="attribute">deploy</span>:
    <span class="attribute">type</span>: git #此处在版本<span class="number">2</span>时为github
    <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/......</span>
    ...
</code></pre>在这个地方容易出错的是<strong>type:</strong>后方容易被误导，版本2请填写github，版本3除了填写git以外，还需要在外头<strong>Git bash</strong>里使用命令:<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span>
</code></pre>有了这个命令就能分分钟解决你的问题。]]>
    
    </summary>
    
      <category term="杂货居" scheme="//wushxin.top/tags/%E6%9D%82%E8%B4%A7%E5%B1%85/"/>
    
      <category term="网站" scheme="//wushxin.top/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>